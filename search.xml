<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>vue中axios中post跨域SpringBoot获取不到RequestBody数据</title>
      <link href="/552952049.html"/>
      <url>/552952049.html</url>
      
        <content type="html"><![CDATA[<p>目前使用axios实现vue中与后台数据交互,目前GET,DELETE都是正常使用,但是会有跨域的问题,我就是临时在返回头加上了Access-Control-Allow-Origin:”*”</p><p>但是一直由于POST提交数据后台数据一直获取不到RequestBody,我之前使用postman测试都是可以通过的,显示<strong>status failure</strong>后台也根本不报错,因为获取不到</p><p>开始是以为是我格式问题换了几种数据</p><pre class="line-numbers language-js"><code class="language-js">        <span class="token comment" spellcheck="true">/*axios.post('http://localhost:8080/xxx/model/'+path,modelIds)                        .then(response => {                            this.searchContent()                        })                        .catch(function (error) {                            console.log(error);                        });*/</span> <span class="token comment" spellcheck="true">/*     axios.post('http://localhost:8080/xxx/process/model/27501', {                        comment: 'Fred',                        userName: 'Flintstone'                    })                        .then(function (response) {                            console.log(response);                        })                        .catch(function (error) {                            console.log(error);                        });*/</span><span class="token keyword">const</span> options <span class="token operator">=</span> <span class="token punctuation">{</span>                        method<span class="token punctuation">:</span> <span class="token string">'POST'</span><span class="token punctuation">,</span>                        headers<span class="token punctuation">:</span> <span class="token punctuation">{</span> <span class="token string">'content-type'</span><span class="token punctuation">:</span> <span class="token string">'application/json'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>                        data<span class="token punctuation">:</span> modelIds<span class="token punctuation">,</span>                        url<span class="token punctuation">:</span><span class="token string">'http://localhost:8080/xxx/model/'</span><span class="token operator">+</span>path                    <span class="token punctuation">}</span><span class="token punctuation">;</span>                    <span class="token function">axios</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>还有就是PUT提交时 application/x-www-form-urlencoded,后台用RequestParam,或者不写都可以接受,对象的话要set,get方法,我刚开始用的form-data,SpringBoot是获取不到数据的</p><p>我目前用的是nginx,代理</p>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> axios </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx详细的配置和用途</title>
      <link href="/2474801124.html"/>
      <url>/2474801124.html</url>
      
        <content type="html"><![CDATA[<p>补充域名相关的知识</p><pre><code>www.xxx.com` ,`www.zzz.xxx.com`,`www.xxx.com/getName</code></pre><blockquote><p>www: World Wide Web 万维网</p><p>xxx: 注册的名称</p><p>zzz: 子域名(Second-level domain；英文缩写：SLD)</p><p>com:顶级域名(Top-level domains)是org,</p><p>URL: <a href="http://www.example.net/index.html,www.xxx.com/getName" target="_blank" rel="noopener">http://www.example.net/index.html,www.xxx.com/getName</a></p></blockquote><p>对于第三个需要配置 server-&gt;多个location配置</p><p>对于第二中需要配置多个server,或者server-&gt;server_name</p><p>转载地址<a href="https://zhuanlan.zhihu.com/p/36148885" target="_blank" rel="noopener">nginx 常用配置记录-知乎专栏</a></p><hr><h3 id="server模块"><a href="#server模块" class="headerlink" title="server模块"></a><strong>server模块</strong></h3><p>server模块是http的子模块，它用来定义一个虚拟主机</p><p>例子：</p><pre><code>server {    listen      80;    server_name localhost www.example.com;    root        /Users/yangyi/www;# 全局定义，表示在该server下web的根目录    client_max_body_size 100M;    keepalive_timeout 20;    index       index.php index.html index.htm;     charset     utf-8;    access_log  logs/host.access.log  main; #用来指定此虚拟主机的访问日志存放路径，输出格式为main。    error_log   logs/host.error.log  error; #错误日志存放路径，输出格式为error。    error_page  404  /404.html; #状态码为404时的时候的网页地址,还可定义500,502之类的    ....}</code></pre><p>以上一些配置为在该server下具有全局性，例如 root，可在location中重新定义root</p><h2 id="关于server-name"><a href="#关于server-name" class="headerlink" title="关于server_name"></a>关于server_name</h2><blockquote><p>用来指定IP地址或者域名，多个域名之间用空格分开</p></blockquote><p>当我们想定义多个server监听同一个端口但访问的host不一样时，server_name就派上用场了。nginx会根据HTTP请求的header Host选择nginx配置文件里符合条件的server_name的server配置</p><p>匹配顺序如下</p><ol><li>完全匹配的server_name;</li><li>后缀匹配: *.example.com;</li><li>前缀匹配: <a href="http://www.example.*/" target="_blank" rel="noopener">www.example.*</a>;</li><li>正则匹配: ~\w+.com;</li><li>listen指令里配置了default或default_server的server;如｀listen 80 default｀</li><li>第一个匹配上listen的server。</li></ol><p>所以当我们监听的的端口只有一个server配置的时候，server_name 可以不填</p><h2 id="关于root和alias的区别"><a href="#关于root和alias的区别" class="headerlink" title="关于root和alias的区别"></a>关于root和alias的区别</h2><p>两者作用差不多，区别在于最终映射的地址不同，例：</p><pre><code>location /request_path/image/ {    # 如果现在访问 /request_path/image/a/b.jpg,root映    # 射的地址为/local_path/image/request_path/image/a/b.jpg,    # 而alias为/local_path/image/a/b.jpg    root    /local_path/image/;    alias   /local_path/image/; }</code></pre><h2 id="关于error-page"><a href="#关于error-page" class="headerlink" title="关于error_page"></a>关于error_page</h2><p>语法：error_page code … [=[response]] uri<br>使用字段: http, server, location, if in location</p><p>产生的效果为内部跳转(internal redirect)，即用户页面地址不变，但内容实际上为设置的uri对应的内容<br>我们也可以自定义设置返回的状态码，如：<br>error_page 502 503 =200 /50x.html;<br>这样用户访问产生502 、503的时候给用户的返回状态是200，内容是50x.html。<br>还有一种写法是 <code>=</code> 后面不带状态码，是针对相应的内容不是一个静态的页面，最终返回的状态码取决于对应url服务返回的状态码。</p><h2 id="location模块"><a href="#location模块" class="headerlink" title="location模块"></a>location模块</h2><blockquote><p>最主要和最复杂的配置，通过定位和解析url，判断该选择什么配置，支持正则和条件判断；</p></blockquote><p>简单例子，匹配所有请求</p><pre><code>location / {    root   /home/www/html;    index  index.php index.html index.htm;}</code></pre><p>一个正则匹配的例子：</p><pre><code># 匹配.php结尾的请求location ~ \.php$ {    ....}</code></pre><p>一个反向代理的例子：</p><pre><code># 匹配到/api开头的路由时候，将请求转发到http://192.168.0.1，但是通常不是直接填写地址，而是设置一个`upstream`配置，后面会提到location /api {    proxy_pass  http://192.168.0.1; #请求转向地址192.168.0.1    #不修改被代理服务器返回的响应头中的location头    proxy_redirect off;    #使用nginx反向代理后，如果要使服务获取真实的用户信息，用以下的设置    proxy_set_header Host $host;    proxy_set_header X-Real-IP $remote_addr;    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;}</code></pre><p>vue-router、react-router等路由框架要开启history模式可以选择的nginx配置的例子</p><pre><code>location / {  alias     static/;  try_files $uri $uri/ /index.html;}</code></pre><p><strong>location的匹配规则和顺序</strong></p><ol><li>第一种是 <strong>=</strong> 类型，表示精确匹配，优先级最高，一旦匹配到忽略之后的正则匹配</li><li><strong>^~</strong> 类型，表示前缀匹配，是字符串开头匹配而非正则匹配，当匹配到该规则时，停止往下面的搜索，所以如果存在两个<strong>^~</strong> 匹配的时候要注意有顺序之分。优先级比正则高。</li><li><code>~</code> 和 <code>~*</code>,正则匹配，两者区别是后者不区分大小写。有顺序之分，匹配到第一个正则停止搜索。</li><li><code>/uri</code>,普通字符串匹配，无顺序之分，会选择匹配长度最长的配置。</li><li><code>/</code> 通用匹配，匹配所有请求</li></ol><p>还有一种特殊匹配类型 <code>@url</code>，只用于nginx内部跳转，例:</p><pre><code>location / {    root /var/www/html;    error_page 404 @40x;}location @40x {  root /var/www/errors/40x.html;}</code></pre><h2 id="upstream模块"><a href="#upstream模块" class="headerlink" title="upstream模块"></a>upstream模块</h2><blockquote><p>upstream后端服务器提供简单的负载均衡（轮循调度和客户端 IP）。</p></blockquote><p>例子：</p><pre><code>upstream backend  {  server backend1.example.com weight=5;  server backend2.example.com:8080;  server unix:/tmp/backend3;} server {  location / {    proxy_pass  http://backend;  }}</code></pre><p>有常用两种负载均衡支持调度算法，分别是 <strong>weight</strong> 和 <strong>ip_hash</strong> 。weight 模式下可以为每个 server 设置weight值，weight值越大，分配到的访问机率越高，ip_hash 为同一个ip的<br>分配同一个后端服务器，这样我们不用解决session共享问题。</p><h2 id="include"><a href="#include" class="headerlink" title="include"></a>include</h2><blockquote><p>include指令 使nginx配置更加灵活，将部分配置直接拆分出来,分成不同的配置文件</p></blockquote><p>例子：</p><pre><code>http {    include mime.types;    include vhost/*.conf; # 虚拟主机配置}</code></pre><h2 id="关于-mime-types："><a href="#关于-mime-types：" class="headerlink" title="关于 mime.types："></a>关于 mime.types：</h2><p>mime type 和 文件扩展名的对应关系一般放在 mime.types 里，然后 用 <code>include mime.types</code>;<br>mime.types作用：通过文件的扩展名设置了Content-Type，Nginx如果没找到对应文件的扩展名的话，就使用默认的Type，默认Type通用 <code>default_type</code> 定义，比如 default_type application/octet-stream ;<br>完整的 mime.types 配置：<a href="https://link.zhihu.com/?target=https%3A//github.com/h5bp/server-configs-nginx/blob/master/mime.types">https://github.com/h5bp/server-configs-nginx/blob/master/mime.types</a></p><h2 id="关于-vhost-conf"><a href="#关于-vhost-conf" class="headerlink" title="关于 vhost/*.conf :"></a>关于 vhost/*.conf :</h2><p>一个虚拟主机对一个文件配置，放到vhost文件夹下面，然后通过include指令包含进来，这样更便于维护和管理</p><h2 id="gzip"><a href="#gzip" class="headerlink" title="gzip"></a>gzip</h2><blockquote><p>gzip 压缩，用来对静态资源进行压缩，需要客户端同时支持才有效。</p></blockquote><p>配置：</p><pre><code>http {    #开启gzip压缩    gzip  on;    #IE6的某些版本对gzip的压缩支持很不好,故关闭    gzip_disable &quot;MSIE [1-6]\.(?!.*SV1)&quot;;    #HTTP1.0以上的版本都启动gzip    gzip_http_version 1.0；    #指定哪些类型的相应才启用gzip压缩，多个用空格分隔    gzip_types     application/javascript     application/json     text/css     text/plain;    # 压缩等级，可选1-9，值越大压缩时间越长压缩率越高，    # 通常选5，能压缩到原来的1/4    gzip_comp_level 5;}</code></pre><h2 id="rewrite模块（ngx-http-rewrite-mode）"><a href="#rewrite模块（ngx-http-rewrite-mode）" class="headerlink" title="rewrite模块（ngx_http_rewrite_mode）"></a>rewrite模块（ngx_http_rewrite_mode）</h2><p>rewrite模块配合很多模块一起使用，包含几个指令：</p><ol><li>break</li><li>if</li><li>return</li><li>rewrite</li><li>rewrite_log</li><li>set</li><li>uninitialized_variable_warn</li></ol><p>这里简单介绍下break、if、return，重点介绍 rewrite</p><h2 id="break"><a href="#break" class="headerlink" title="break"></a>break</h2><p>语法: break;<br>使用字段: server, location, if<br>此指令的意思是停止执行当前虚拟主机的后续rewrite指令集</p><p>例子</p><pre><code># 如果访问的文件名不存在，反向代理到localhost 。这里的break也是停止rewrite检查if (!-f $request_filename) {    break;    proxy_pass http://127.0.0.1;}</code></pre><h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><p>语法: if (condition) { … }<br>使用字段: server, location<br>if 判断一个条件，如果条件成立，则后面的大括号内的语句将执行，相关配置从上级继承。</p><p>条件(conditon)可以是如下任何操作：</p><ol><li>当表达式只是一个变量时，如果值为空或任何以0开头的字符串都会当做false；</li><li>使用“=”和“!=”比较一个变量和字符串；</li><li>使用“<del>”做正则表达式匹配，“</del>*”做不区分大小写的正则匹配，“!~”做区分大小写的正则不匹配；</li><li>使用“-f”和“!-f” 检查一个文件是否存在；</li><li>使用“-d”和“!-d”检查一个目录是否存在；</li><li>使用“-e”和“!-e”检查一个文件、目录、符号链接是否存在；</li><li>使用“-x”和“ !-x”检查一个文件是否可执行；</li></ol><pre><code># 如果提交方法为POST，则返回状态405（Method not allowed）if ($request_method = POST) {    return 405;}</code></pre><h2 id="return"><a href="#return" class="headerlink" title="return"></a>return</h2><p>语法: return code [text];<br>return code URL;<br>return URL;<br>使用字段: server, location, if<br>停止处理并为客户端返回状态码，非标准的444状态码将关闭连接，不发送任何响应头。可以使用的状态码有：204，400，402-406，408，410, 411, 413, 416与500-504。如果状态码附带文字段落，该文本将被放置在响应主体。相反，如果状态码后面是一个URL，该URL将成为location头部值。没有状态码的URL将被视为一个302状态码，这种情况下URL需要以“http://”, “https://”, 或者 “$scheme”开头。</p><h2 id="rewrite"><a href="#rewrite" class="headerlink" title="rewrite"></a>rewrite</h2><p>语法: rewrite regex replacement [flag];<br>使用字段: server, location, if<br>使用nginx提供的全局变量或自己设置的变量，然后结合正则表达式和标志位实现url重写以及重定向。多条 rewrite 顺序靠前且匹配的优先执行。可以通过设置 flag 停止继续处理。如果replacement 以“http://”, “https://”, 或者 “$scheme”开头，那么将立即停止处理并临时重定向给客户端。</p><p>flag可以是如下参数：</p><ul><li>last，完成该rewrite规则的执行后，停止处理后续rewrite指令集；然后查找匹配改变后URI的新location；</li><li>break，完成该rewrite规则的执行后，停止处理后续rewrite指令集，并不再重新查找；但是当前location内剩余非rewrite语句和location外的的非rewrite语句可以执行；</li><li>redirect，返回302临时重定向，地址栏会显示跳转后的地址；</li><li>permanent，返回301永久重定向，地址栏会显示跳转后的地址；即表示如果客户端不清理浏览器缓存，那么返回的结果将永久保存在客户端浏览器中了。</li></ul><p>因为301和302不能简单的只返回状态码，还必须有重定向的URL，这就是return指令无法返回301,302的原因了。两种重定向的方式对客户端来说是一样的，就是重新加载另外一个url。我们在实际设置中推荐只使用永久重定向，因为临时重定向可能造成在url为A页面，但显示的是B页面的内容，造成网址劫持。</p><p>比较难以理解的是 last 和 break，让我们先了解 nginx 运行的11个阶段，注意到第四阶段：</p><pre><code>typedef enum {      NGX_HTTP_POST_READ_PHASE = 0,   //读取请求头        NGX_HTTP_SERVER_REWRITE_PHASE,   //执行rewrite        NGX_HTTP_FIND_CONFIG_PHASE,  //根据uri替换location      NGX_HTTP_REWRITE_PHASE,      //根据替换结果继续执行rewrite      NGX_HTTP_POST_REWRITE_PHASE, //执行rewrite后处理        NGX_HTTP_PREACCESS_PHASE,    //认证预处理   请求限制，连接限制        NGX_HTTP_ACCESS_PHASE,       //认证处理      NGX_HTTP_POST_ACCESS_PHASE,  //认证后处理， 认证不通过， 丢包        NGX_HTTP_TRY_FILES_PHASE,    //尝试try标签      NGX_HTTP_CONTENT_PHASE,      //内容处理        NGX_HTTP_LOG_PHASE           //日志处理  } ngx_http_phases;</code></pre><p>所以我们再来理解last与break的区别：<br>last： 停止当前这个请求，并根据rewrite匹配的规则重新发起一个请求。新请求又从第一阶段开始执行…<br>break：相对last，break并不会重新发起一个请求，只是跳过当前的rewrite阶段，并执行本请求后续的执行阶段…</p><p>通过实例会更加清晰的理解</p><pre><code>server {    listen 80 default_server;    server_name dcshi.com;    root www;    location /break/ {        rewrite ^/break/(.*) /test/$1 break;        echo &quot;break page&quot;;    }     location /last/ {         rewrite ^/last/(.*) /test/$1 last;         echo &quot;last page&quot;;    }        location /test/ {       echo &quot;test page&quot;;    }}</code></pre><p>请求:<a href="https://link.zhihu.com/?target=http%3A//dcshi.com/break/">http://dcshi.com/break/</a>***<br>输出: break page<br>分析：正如上面讨论所说，break是跳过当前请求的rewrite阶段，并继续执行本请求的其他阶段，很明显，对于/foo 对应的content阶段的输出为 echo “break page”; (content阶段，可以简单理解为产生数据输出的阶段，如返回静态页面内容也是在content阶段；echo指令也是运行在content阶段，一般情况下content阶段只能对应一个输出指令，如同一个location配置两个echo，最终只会有一个echo指令被执行)；当然如果你把/break/里的echo 指令注释，然后再次访问/break/xx会报404，这也跟我们预期一样：虽然/break/xx被重定向到/test/xx,但是break指令不会重新开启一个新的请求继续匹配，所以nginx是不会匹配到下面的/test/这个location；在echo指令被注释的情况下，/break/ 这location里只能执行nginx默认的content指令，即尝试找/test/xx这个html页面并输出起内容，事实上，这个页面不存在，所以会报404的错误。</p><p>请求: <a href="https://link.zhihu.com/?target=http%3A//dcshi.com/last/">http://dcshi.com/last/</a>***<br>输出: test page<br>分析: last与break最大的不同是，last会重新发起一个新请求，并重新匹配location，所以对于/last,重新匹配请求以后会匹配到/test/,所以最终对应的content阶段的输出是test page;</p><p>解释完了 last 和 break ，我们再写一个实例用来说明 rewrite 可以做什么事情。通过rewrite将不带www的请求统一转向为www：</p><pre><code>server {    # ........    server_name www.abc.com ;//只留一个    # ......｝server {  server_name  abc.com;  rewrite ^(.*)$ http://www.abc.com$1 permanent; }</code></pre><p>或者是：</p><pre><code>server {   listen 80;   server_name abc.com www.abc.com;   if ( $host != &#39;www.abc.com&#39;  ) {       rewrite ^/(.*) http://www.abc.com/$1 permanent;   }   location / {       root /data/www/www;       index index.html index.htm;   }}</code></pre><p>参考：</p><p><a href="https://link.zhihu.com/?target=http%3A//tool.oschina.net/apidocs/apidoc%3Fapi%3Dnginx-zh">在线文档-nginx-zh</a></p><p><a href="https://link.zhihu.com/?target=https%3A//www.jianshu.com/p/bed000e1830b">WEB请求处理二：Nginx请求反向代理</a></p><p><a href="https://link.zhihu.com/?target=http%3A//blog.sina.com.cn/s/blog_4f9fc6e10102ux0w.html">http://blog.sina.com.cn/s/blog_4f9fc6e10102ux0w.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo的next主题换到Yelee(Yilia)</title>
      <link href="/1815339691.html"/>
      <url>/1815339691.html</url>
      
        <content type="html"><![CDATA[<p>原有的主题是已经配过valine的 <a href="https://valine.js.org/configuration" target="_blank" rel="noopener">配置valine</a>,</p><h4 id="LAYOUT-PARTIAL-ARTICLE-EJS"><a href="#LAYOUT-PARTIAL-ARTICLE-EJS" class="headerlink" title="LAYOUT/_PARTIAL/ARTICLE.EJS"></a>LAYOUT/_PARTIAL/ARTICLE.EJS</h4><p>重写了一下 style，应该可以做到响应式布局了</p><pre class="line-numbers language-ejs"><code class="language-ejs"><% if (theme.valine && theme.valine.appid && theme.valine.appkey){ %>    <section id="comments" class="comments" style="margin:30px;padding:15px;background:#fff}">      <style>        @media screen and (max-width:800px){.comments{margin:auto;padding:10px;background:#fff}}      </style>      <%- partial('../POST/valine', {        key: post.slug,        title: post.title,        url: config.url+url_for(post.path)        }) %>  </section><% } %><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="LAYOUT-PARTIAL-POST-VALINE-EJS"><a href="#LAYOUT-PARTIAL-POST-VALINE-EJS" class="headerlink" title="LAYOUT/_PARTIAL/POST/VALINE.EJS"></a>LAYOUT/_PARTIAL/POST/VALINE.EJS</h4><pre class="line-numbers language-ejs"><code class="language-ejs"><div id="vcomment" class="comment"></div><!--载入js，在 body之前插入即可--><!--Leancloud 操作库:--><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><!--Valine 的核心代码库--><script src='//cdn.jsdelivr.net/npm/valine/dist/Valine.min.js'></script><script>  var notify = '<%= theme.valine.notify %>' == true ? true : false;  var verify = '<%= theme.valine.verify %>' == true ? true : false;  new Valine({      // AV 对象来自上面引入av-min.js(老司机们不要开车➳♡゛扎心了老铁)      av: AV,      el: '#vcomment',      emoticon_url: 'https://cloud.panjunwen.com/alu',      emoticon_list: ["狂汗.png","不说话.png","汗.png","坐等.png","献花.png","不高兴.png","中刀.png","害羞.png","皱眉.png","小眼睛.png","暗地观察.png"],      app_id: '<%= theme.valine.appid %>',      app_key: '<%= theme.valine.appkey %>',      placeholder: '<%= theme.valine.placeholder %>'    });if(window.location.hash){          var checkExist = setInterval(function() {            if (document.getElementById(window.location.hash.replace("#",""))) {              location.href = window.location.hash;              clearInterval(checkExist);            }          }, 250);        }</script><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>起初参考<a href="https://blog.xxwhite.com/2017/Valine.html" target="_blank" rel="noopener">MonoLogueChi博客</a>,不知道什么原因:( 在主页的界面的每个标题下面都有一个留言的窗口</p><p>于是我将加到 <code>ARTICLE.EJS</code> 换了地方 <code>themes/hexo-theme-yelee/layout/_partial/post/nav.ejs</code> ,注意换了路径需要将</p><blockquote><p>&lt;%- partial(‘../POST/valine’, {<br>key: post.slug,<br>title: post.title,<br>url: config.url+url_for(post.path)<br>}) %&gt;</p></blockquote><p>中的<code>../POST/valine</code>相对地址也跟着换掉</p><h3 id="自动生成摘要"><a href="#自动生成摘要" class="headerlink" title="自动生成摘要"></a>自动生成摘要</h3><p><a href="http://moxfive.coding.me/yelee/2.Basic-Usage/post-excerpt.html" target="_blank" rel="noopener">官方推荐的文章摘要格式</a></p><blockquote><h3 id="方法一-lt-more-gt"><a href="#方法一-lt-more-gt" class="headerlink" title="方法一: &lt;!-- more --&gt;"></a>方法一: <code>&lt;!-- more --&gt;</code></h3><pre><code>&gt; title: Hello World&gt; date: 2015-12-03 00:00:00&gt; ---&gt; &lt;Excerpt in index | 首页摘要&gt;&gt; +&lt;!-- more --&gt;&gt; &lt;The rest of contents | 余下全文&gt;&gt;</code></pre></blockquote><blockquote><blockquote><p><code>&lt;!-- more --&gt;</code> 之前最好不要有空格等字符；</p></blockquote><h3 id="方法二-description-in-Front-matter"><a href="#方法二-description-in-Front-matter" class="headerlink" title="方法二: description in Front-matter"></a>方法二: <code>description</code> in <a href="https://hexo.io/zh-cn/docs/front-matter.html" target="_blank" rel="noopener">Front-matter</a></h3><pre><code>&gt; title: Hello World&gt; date: 2015-12-03 00:00:00&gt; +description: &quot;Welcome to Hexo! This is your very first post.&quot;&gt; ---&gt; &lt;Contents&gt;&gt;</code></pre></blockquote><blockquote><blockquote><p>通过 <code>description</code> 添加的摘要只能为纯文本；</p></blockquote></blockquote><p>但是很复杂每次写的时候都要添加对于标签重复劳动,对于之前的文章都要这样去设置很机械,后面发现了</p><p>有 <code>hexo-auto-excerpt</code> 可以使用</p><ol><li><p>npm install –save hexo-auto-excerpt</p></li><li><p>将<code>layout/_partial/article.ejs</code>，在<code>div.article-entry</code>中的代码换成下面的</p><pre><code>&lt;% if (index){ %&gt;    &lt;% if (post.excerpt) { %&gt;        &lt;%- post.excerpt %&gt;    &lt;% } else if (theme.auto_excerpt.enable) { %&gt;        &lt;% var br_position = 0 %&gt;        &lt;% for (var br_count = 0; br_count &lt; theme.auto_excerpt.lines; br_count++) { %&gt;            &lt;% br_position = post.content.indexOf(&#39;\n&#39;,br_position + 1) %&gt;            &lt;% if(br_position &lt; 0) { break } %&gt;        &lt;% } %&gt;        &lt;% if(br_position &gt; 0) { %&gt;            &lt;% show_all_content = false %&gt;            &lt;p&gt;&lt;%- post.content.substring(0, br_position + 1) %&gt;&lt;p&gt;        &lt;% } %&gt;    &lt;% } %&gt;    &lt;% } else { %&gt;    &lt;%- partial(&#39;toc&#39;, { post: post}) %&gt;    &lt;%- post.content %&gt;&lt;% } %&gt;</code></pre></li><li><p>_config.yml 添加下面代码</p><pre><code>auto_excerpt:    enable: true    lines: 3</code></pre></li></ol><p><a href="https://whyour.cn/post/hexo-yilia-auto-excerpt.html" target="_blank" rel="noopener">hexo博文摘要生成方案</a></p><h3 id="Yelee-Yilia-打赏和调节版本署名的样式"><a href="#Yelee-Yilia-打赏和调节版本署名的样式" class="headerlink" title="Yelee(Yilia)打赏和调节版本署名的样式"></a>Yelee(Yilia)打赏和调节版本署名的样式</h3><p>yelee没有打赏功能目前需要自己实现目前需要修改</p><ol><li><p>_config.yml</p><pre><code># 打赏type设定：0-关闭打赏； 1-文章对应的md文件里有reward:true属性，才有打赏； 2-所有文章均有打赏reward_type: 2# 打赏wordingreward_wording: &#39;加个鸡腿&#39;# 支付宝二维码图片地址，跟你设置头像的方式一样。比如：/assets/img/alipay.jpgalipay: /pics/weixin.png# 微信二维码图片地址weixin: /pics/alipay.jpg</code></pre></li><li><p>layout/_partial/article.ejs</p><pre><code>&lt;% if (((theme.reward_type === 2 &amp;&amp; !post.reward) || (theme.reward_type === 1 &amp;&amp; post.reward)) &amp;&amp; !index){ %&gt;          &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/share/reward.css&quot; /&gt;        &lt;div class=&quot;page-reward&quot;&gt;          &lt;a href=&quot;javascript:;&quot; class=&quot;page-reward-btn tooltip-top&quot;&gt;            &lt;div class=&quot;tooltip tooltip-east&quot;&gt;              &lt;span class=&quot;tooltip-item&quot;&gt;                赏              &lt;/span&gt;              &lt;span class=&quot;tooltip-content&quot;&gt;                &lt;span class=&quot;tooltip-text&quot;&gt;                  &lt;span class=&quot;tooltip-inner&quot;&gt;                    &lt;p class=&quot;reward-p&quot;&gt;&lt;i class=&quot;icon icon-quo-left&quot;&gt;&lt;/i&gt;&lt;%= theme.reward_wording%&gt;&lt;i                        class=&quot;icon icon-quo-right&quot;&gt;&lt;/i&gt;&lt;/p&gt;                    &lt;div class=&quot;reward-box&quot;&gt;                      &lt;% if(theme.alipay) {%&gt;                      &lt;div class=&quot;reward-box-item&quot;&gt;                        &lt;img class=&quot;reward-img&quot; src=&quot;&lt;%= theme.alipay%&gt;&quot;&gt;                        &lt;span class=&quot;reward-type&quot;&gt;支付宝&lt;/span&gt;                      &lt;/div&gt;                      &lt;% } %&gt;                      &lt;% if(theme.weixin) {%&gt;                      &lt;div class=&quot;reward-box-item&quot;&gt;                        &lt;img class=&quot;reward-img&quot; src=&quot;&lt;%= theme.weixin%&gt;&quot;&gt;                        &lt;span class=&quot;reward-type&quot;&gt;微信&lt;/span&gt;                      &lt;/div&gt;                      &lt;% } %&gt;                    &lt;/div&gt;                  &lt;/span&gt;                &lt;/span&gt;              &lt;/span&gt;            &lt;/div&gt;          &lt;/a&gt;        &lt;/div&gt;   &lt;% } %&gt;</code></pre></li><li><p>最后是在source下的share文件夹下保存css文件 地址../share/reward.css</p></li></ol><p>修改版本署名的样式 /themes/hexo-theme-yelee/layout/_partial/post/nav.ejs</p><pre><code>&lt;div class=&quot;is_copyright&quot;&gt;  &lt;ui class=post-copyright&gt;      &lt;li&gt;&lt;strong&gt;&lt;%= __(&#39;copyright_info.title&#39;) %&gt;:&lt;/strong&gt;&lt;a href=&quot;&lt;%- url_for(post.path) %&gt;&quot;&gt;&lt;%= post.title %&gt;&lt;/a&gt;&lt;/li&gt;     &lt;li&gt;&lt;strong&gt;&lt;%= __(&#39;copyright_info.author&#39;) %&gt;:&lt;/strong&gt;&lt;a href=&quot;/&quot; title=&quot;&lt;%= __(&#39;tooltip.back2home&#39;) %&gt;&quot;&gt;&lt;%=theme.author%&gt;&lt;/a&gt; &lt;/li&gt;     &lt;li&gt;&lt;strong&gt;&lt;%= __(&#39;copyright_info.date&#39;) %&gt;:&lt;/strong&gt;&lt;%= post.date.format(&quot;YYYY-MM-DD, HH:mm:ss&quot;) %&gt;  &lt;/li&gt;     &lt;li&gt; &lt;strong&gt;&lt;%= __(&#39;copyright_info.updated&#39;) %&gt;:&lt;/strong&gt;&lt;%= post.updated.format(&quot;YYYY-MM-DD, HH:mm:ss&quot;) %&gt; &lt;/li&gt;     &lt;li&gt;         &lt;strong&gt;&lt;%= __(&#39;copyright_info.url&#39;) %&gt;:&lt;/strong&gt;&lt;a class=&quot;post-url&quot; href=&quot;&lt;%- url_for(post.path) %&gt;&quot; title=&quot;&lt;%= post.title %&gt;&quot;&gt;&lt;%= post.permalink %&gt;&lt;/a&gt;         &lt;strong class=&quot;copy-path&quot; data-clipboard-text=&quot;&lt;%= __(&#39;copyright_info.from&#39;) %&gt; &lt;%= post.permalink %&gt;　　&lt;%= __(&#39;copyright_info.by&#39;) %&gt; &lt;%=theme.author%&gt;&quot; title=&quot;&lt;%= __(&#39;tooltip.copyPath&#39;) %&gt;&quot;&gt;&lt;i class=&quot;fa fa-clipboard&quot;&gt;&lt;/i&gt;&lt;/strong&gt;         &lt;script&gt; var clipboard = new Clipboard(&#39;.copy-path&#39;); &lt;/script&gt;    &lt;/li&gt;     &lt;li&gt;         &lt;strong&gt;&lt;%= __(&#39;copyright_info.license&#39;) %&gt;:&lt;/strong&gt;&lt;i class=&quot;fa fa-creative-commons&quot;&gt;&lt;/i&gt; &lt;a rel=&quot;license&quot; href=&quot;http://creativecommons.org/licenses/by-nc-sa/4.0/&quot; title=&quot;CC BY-NC-SA 4.0 International&quot; target = &quot;_blank&quot;&gt;&quot;&lt;%= __(&#39;copyright_info.cc&#39;) %&gt;&quot;&lt;/a&gt; &lt;%= __(&#39;copyright_info.notice&#39;) %&gt;    &lt;/li&gt; &lt;/ui&gt;&lt;/div&gt;</code></pre><h3 id="代码区前后有很多空行"><a href="#代码区前后有很多空行" class="headerlink" title="代码区前后有很多空行"></a>代码区前后有很多空行</h3><pre class="line-numbers language-css"><code class="language-css"><span class="token number">.</span>article-entry  pre, code    <span class="token property">font-family</span><span class="token punctuation">:</span> font-mono, monospace, font-chs    <span class="token property">font-size</span><span class="token punctuation">:</span> <span class="token number">1</span>em## 后面加这几个  <span class="token number">.</span><span class="token property">line</span><span class="token punctuation">:</span>after    <span class="token property">content</span><span class="token punctuation">:</span> <span class="token string">''</span>    <span class="token property">display</span><span class="token punctuation">:</span> inline-block<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><a href="https://github.com/MOxFIVE/hexo-theme-yelee/issues/142#issuecomment-253408991" target="_blank" rel="noopener">解决链接</a></p><h3 id="添加统计字数"><a href="#添加统计字数" class="headerlink" title="添加统计字数"></a>添加统计字数</h3><pre><code>&lt;% if (post.tags &amp;&amp; post.tags.length){ %&gt;-    &lt;div class=&quot;article-tag tagcloud&quot;&gt;+    &lt;div class=&quot;article-tag tagcloud&quot; style=&quot;display: flex; flex-wrap: wrap&quot;&gt;        &lt;%-          list_tags(post.tags, {            show_count: false,            class: &#39;article-tag&#39;          })        %&gt;+       &lt;span class=&quot;post-count&quot;&gt;总字数&lt;%= wordcount(post.content) %&gt;&lt;/span&gt;+       &lt;span class=&quot;post-count&quot;&gt;预计阅读&lt;%= min2read(post.content) %&gt;分钟&lt;/span&gt;    &lt;/div&gt;&lt;% } %&gt;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> Yelee </tag>
            
            <tag> Yilia </tag>
            
            <tag> hexo主题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用yandex搭建自定义域名的邮件服务</title>
      <link href="/2045142583.html"/>
      <url>/2045142583.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.daweibro.com/node/255" target="_blank" rel="noopener">2019年最新Yandex免费域名邮箱申请使用全攻略</a></p><p>我注册的域名是免费的 <a href="https://my.freenom.com/clientarea.php" target="_blank" rel="noopener">注册ml域名的地址</a>下面的注册好的列表</p><p>注册不成功显示 Not available 可以使用这个入口<a href="http://www.point.ml/en/index.html?lang=en" target="_blank" rel="noopener">http://www.point.ml/en/index.html?lang=en</a></p><p><a href="../img/1586576471104.png"><img src="../img/1586576471104.png" alt="1586576471104"></a></p><p>刚开始用的是<a href="https://www.bajiedns.com/这个dns,但是配置后依照没反应" target="_blank" rel="noopener">https://www.bajiedns.com/这个dns,但是配置后依照没反应</a> dns.la,he dns.com 这两个都要手机号码而且后面操作也麻烦,我后面选择<a href="https://www.dnspod.cn/" target="_blank" rel="noopener">dnspod</a>之前用的就是这个后面是要变收费 ,看页面也没提免费解析,</p><p>1 .修改nameservr(NS)-&gt;f1g1ns1.dnspod.net ,f1g1ns2.dnspod.net.</p><p>2 .验证这个域名是你的在yandex哪会有 yandex-verification 的部分</p><p>3 .解析域名到mx.yandex.com 这样才能使用他们的邮件服务</p><p>4 .添加一个TXT记录，子域名为“mail._domainkey”，值为“v=DKIM1; k=rsa; t=s jjj”。</p><p><a href="../img/1586576874444.png"><img src="../img/1586576874444.png" alt="1586576874444"></a></p><p>上述配置完后就可以使用 adduser 创建用户后,注意创建后也要在网页<a href="https://mail.yandex.xn--com-kb0e97on6apa447xdkj502bmbdpt7bsb3ay84a/" target="_blank" rel="noopener">https://mail.yandex.com登陆同意协议后方能使用</a></p><pre><code>IMAP：imap.yandex.com 端口：993(SSL)POP3：pop.yandex.com 端口：995(SSL)SMTP：smtp.yandex.com 端口：465(SSL)</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> mail </tag>
            
            <tag> yandex </tag>
            
            <tag> 域名 </tag>
            
            <tag> 邮件服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu进程(daemon)管理,启动和停止</title>
      <link href="/1520204912.html"/>
      <url>/1520204912.html</url>
      
        <content type="html"><![CDATA[<p>systemctl list-units –all –type=service</p><p>systemctl list-units –all –type=service –no-pager</p><p><a href="http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html" target="_blank" rel="noopener">Systemd 入门教程：命令篇</a></p><p>ystemd 是 Linux 系统工具，用来启动<a href="http://www.ruanyifeng.com/blog/2016/02/linux-daemon.html" target="_blank" rel="noopener">守护进程</a>，已成为大多数发行版的标准配置。</p><p>正确使用的一种，利用systemctl命令。 您的系统可能使用其他服务初始化命令，例如常用服务。 但是，当命令systemctl可用时，使用list-units选项应该会产生良好的结果。 添加了一些额外的参数，这些参数可以自行解释。</p><h3 id="Linux启动过程"><a href="#Linux启动过程" class="headerlink" title="Linux启动过程"></a>Linux启动过程</h3><p>也可以设置每次登录自动执行脚本，在/etc/profile.d/目录下新建sh脚本，<br>/etc/profile会遍历/etc/profile.d/*.sh</p><p>另外，几个脚本的区别：<br>（1） /etc/profile： 此文件为系统的每个用户设置环境信息,当用户第一次登录时,该文件被执行. 并从/etc/profile.d目录的配置文件中搜集shell的设置。</p><p>（2） /etc/bashrc: 为每一个运行bash shell的用户执行此文件.当bash shell被打开时,该文件被读取（即每次新开一个终端，都会执行bashrc）。</p><p>（3） ~/.bash_profile: 每个用户都可使用该文件输入专用于自己使用的shell信息,当用户登录时,该文件仅仅执行一次。默认情况下,设置一些环境变量,执行用户的.bashrc文件。</p><p>（4） ~/.bashrc: 该文件包含专用于你的bash shell的bash信息,当登录时以及每次打开新的shell时,该该文件被读取。</p><p>（5） <del>/.bash_logout: 当每次退出系统(退出bash shell)时,执行该文件. 另外,/etc/profile中设定的变量(全局)的可以作用于任何用户,而</del>/.bashrc等中设定的变量(局部)只能继承 /etc/profile中的变量,他们是”父子”关系。</p><p>（6） <del>/.bash_profile: 是交互式、login 方式进入 bash 运行的</del>/.bashrc 是交互式 non-login 方式进入 bash 运行的通常二者设置大致相同，所以通常前者会调用后者。</p><p><a href="javascript:;"></a></p>]]></content>
      
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树莓派内网穿透</title>
      <link href="/2070834639.html"/>
      <url>/2070834639.html</url>
      
        <content type="html"><![CDATA[<p>下面是我了解的提供内网穿透的网站,也可以使用比较传统的花生壳</p><ul><li><p><a href="https://www.natfrp.com/" target="_blank" rel="noopener">Sakura Frp </a>我用的这个</p></li><li><p><a href="http://www.ngrok.cc/" target="_blank" rel="noopener">Sunny-Ngrok </a>支持ngrok,frp两种客户端 还是推荐的</p></li><li><p><a href="https://natapp.cn/" target="_blank" rel="noopener">natapp</a> 第一个pass 要手机号码注册而且后面使用其服务还要实名(支付宝验证)</p></li><li><p><a href="../xiaomy.net">网云穿内网穿透</a></p><p>这个看介绍还不错 但是没有树莓派的软件,树莓派目前的 linux-arm不能用64位的,它提供的是wyc_linux_64所以就放弃的,但是它有提供Java版,但是要配置jre环境就算了</p></li></ul><p><a href="../img/1586077499502.png"><img src="../img/1586077499502.png" alt="1586077499502"></a></p><p>大概使用Sakura Frp步骤</p><ol><li><p>下载对应的软件</p><p>这个是注意事项</p><pre><code>由于客户端更新，所有用户将需要重新下载最新版本的客户端，请老用户访问左侧软件下载获取最新版本客户端。**为了避免滥用，所有国内节点将不会转发未实名用户的HTTP流量（特指使用TCP隧道建立的对HTTP协议web服务器的映射），如希望使用国内节点建站请实名认证或加群(747976298)联系我(Q:2792020)并提供已备案的域名然后使用HTTP/HTTPS隧道。**</code></pre><p><a href="https://qianqu.me/frp/frpc_linux_arm" target="_blank" rel="noopener">https://qianqu.me/frp/frpc_linux_arm</a> 下载树莓派的链接</p></li><li><p>创建隧道</p><p><a href="../img/1586077969123.png"><img src="../img/1586077969123.png" alt="1586077969123"></a></p></li><li><p>启动</p><pre><code>chmod +x frpc_linux_arm    将文件传输到你创建的文件下面  sudo ./frpc_linux_arm             完成后在平级的文件夹下面会有frp_user.txt的配置文件      然后在终端下面会显示</code></pre></li></ol><p>本地：127.0.0.1:80 请把域名: yun.imlike.cc 的CNAME记录更改为: us-la-kr.sakurafrp.com (或更改A记录为: 98.126.219.155)</p><pre><code>此时直接访问us-la-kr.sakurafrp.com 是503 Service Unavailable错误,还有就是上面提到的告示,使用国内的节点需要通过站长的通过否则也会导致页面错误</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 树莓派 </tag>
            
            <tag> 内网穿透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树莓派使用cloudreve搭建nas和离线下载</title>
      <link href="/1661309199.html"/>
      <url>/1661309199.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.coolapk.com/feed/17682984?shareKey=MzYxMmY3MTc4YzNjNWU4N2RkYmU~&shareUid=902662&shareFrom=com.coolapk.market_9.0.2" target="_blank" rel="noopener"><strong>树莓派搭建满速家庭云网盘（Lv.1）</strong></a></p><p><a href="https://www.coolapk.com/feed/17772116?shareKey=OTA2MTE2NGIxNDhiNWU4N2U2ZjQ~&shareUid=902662&shareFrom=com.coolapk.market_9.0.2" target="_blank" rel="noopener"><strong>[干货Get!]Android搭建Cloudreve私人云盘</strong></a></p><p><a href="../img/1586074575520.png"><img src="../img/1586074575520.png" alt="1586074575520"></a></p><h3 id="允许SHH使用root登陆"><a href="#允许SHH使用root登陆" class="headerlink" title="允许SHH使用root登陆"></a>允许SHH使用root登陆</h3><p>sudo passwd 来重置root用户的密码</p><p> <strong>vim /etc/ssh/sshd_config</strong></p><p>注释掉 PermitRootLogin without-password</p><p>使用 PermitRootLogin yes</p><h3 id="连接树莓派将文件传过去"><a href="#连接树莓派将文件传过去" class="headerlink" title="连接树莓派将文件传过去"></a>连接树莓派将文件传过去</h3><p>现在下载 <a href="https://github.com/cloudreve/Cloudreve/releases" target="_blank" rel="noopener">https://github.com/cloudreve/Cloudreve/releases</a> 选择<a href="https://github.com/cloudreve/Cloudreve/releases/download/3.0.0-rc1/cloudreve_3.0.0-rc1_linux_arm.tar.gz" target="_blank" rel="noopener">cloudreve_3.0.0-rc1_linux_arm.tar.gz</a></p><p><a href="../img/1586075347405.png"><img src="../img/1586075347405.png" alt="1586075347405"></a></p><p>sudo mkdir /home/cloud</p><p>使用ftp的客户端连接注意使用 root</p><p>将下载cloudreve_3.0.0-rc1_linux_arm.tar.gz 放到 /home/cloud下</p><p>sudo tar -xzvf cloudreve_3.0.0-rc1_linux_arm.tar.gz 解压后也是个单文件cloudreve</p><p>sudo ./cloudreve</p><p>后面终端会打印出来用户<a href="mailto:admin@cloudreve.org">admin@cloudreve.org</a> 和密码</p><h3 id="初始化cloudreve-3-0-0-rc1-linux-arm和设置"><a href="#初始化cloudreve-3-0-0-rc1-linux-arm和设置" class="headerlink" title="初始化cloudreve_3.0.0-rc1_linux_arm和设置"></a>初始化cloudreve_3.0.0-rc1_linux_arm和设置</h3><p>登陆后下面是初始化的页面</p><p><a href="../img/1586074929312.png"><img src="../img/1586074929312.png" alt="1586074929312"></a></p><h4 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h4><p><a href="../img/1586075685498.png"><img src="../img/1586075685498.png" alt="1586075685498"></a></p><p>只有这个入口可以设置用户(包括管理员)使用的存储的地址,可以本地-&gt;这个本地可以选择硬盘挂载路径,也可以用onedrive</p><h3 id="设置cloudreve后台启动"><a href="#设置cloudreve后台启动" class="headerlink" title="设置cloudreve后台启动"></a>设置cloudreve后台启动</h3><p>vim /usr/lib/systemd/system/cloudreve.service</p><p>粘贴以下内容然后文内的 PATH_TO_CLOUDREVE 更换为程序所在目录</p><pre><code>[Unit]Description=CloudreveDocumentation=[查看链接](https://docs.cloudreve.org/)After=network.targetWants=network.target[Service]WorkingDirectory=/PATH_TO_CLOUDREVEExecStart=/PATH_TO_CLOUDREVE/cloudreveRestart=on-abnormalRestartSec=5sKillMode=mixedStandardOutput=nullStandardError=syslog[Install]WantedBy=multi-user.target</code></pre><p>然后Ctrl+o保存Ctrl+x退出</p><p>然后配置进程<br>更新配置<br>systemctl daemon-reload<br>启动服务<br>systemctl start cloudreve<br>设置开机启动<br>systemctl enable cloudreve</p><p>然后我们就可以通过以下指令来管理服务了<br># 启动服务<br>systemctl start cloudreve</p><p># 停止服务<br>systemctl stop cloudreve</p><p># 重启服务<br>systemctl restart cloudreve</p><p># 查看状态<br>systemctl status cloudreve</p><h2 id="软连接到挂载的硬盘"><a href="#软连接到挂载的硬盘" class="headerlink" title="软连接到挂载的硬盘"></a>软连接到挂载的硬盘</h2><p>ln -s /home/device /home/cloud/uploads/1/disk</p><p>fdisk -l 查看分区和挂载状况</p><pre><code>sudo su 建一个目录作为U盘的挂接点。比如说要把U盘挂载到 /mnt/usb，那么需要采用下列命令新建 /mnt/usb。       mkdir /mnt/usb       然后就可以采用mount命令把U盘挂载在/mnt/usb。       mount /dev/sdb1 /mnt/usb       输入命令 cd /mnt/usb进入目录/mnt/usb，然后输入 ls命令就可以查看U盘里的内容了。mount  /dev/sda1  /home/cloud/uploads/1/diskmount  /dev/sda1 /home/device</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 树莓派 </tag>
            
            <tag> cloud </tag>
            
            <tag> nas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树莓派nginx代理转发到本机端口</title>
      <link href="/981520166.html"/>
      <url>/981520166.html</url>
      
        <content type="html"><![CDATA[<p>sudo apt-get update</p><p>sudo apt-get install nginx</p><p>安装成功后 sudo /etc/init.d/nginx start 启动一下访问树莓派的IP能访问成功就可以了</p><p>选择/etc/nginx/nginx.conf</p><pre><code>http {                   server{                            listen 80;                            server_name yun.imlike.cc;                             location / {                             # 一些基本反向代理配置以及获取请求真是IP地址                                    proxy_redirect off;                                    proxy_set_header Host $host;                                    proxy_set_header X-Real-Ip $remote_addr;                                    proxy_set_header X-Forwarded-For $remote_addr;                                    proxy_pass http://你要跳转IP:端口;                            }                           # access_log /home/wwwlogs/git.aboutme.ink.log;                    }                       server{                            listen 80;                            server_name portal.imlike.cc;                             location / {                             # 一些基本反向代理配置以及获取请求真是IP地址                                    proxy_redirect off;                                    proxy_set_header Host $host;                                    proxy_set_header X-Real-Ip $remote_addr;                                    proxy_set_header X-Forwarded-For $remote_addr;                                      proxy_pass http://你要跳转IP:端口;                            }                           # access_log /home/wwwlogs/git.aboutme.ink.log;                    }}</code></pre><p>sudo /etc/init.d/nginx restart 重启一下</p><h3 id="优化访问"><a href="#优化访问" class="headerlink" title="优化访问"></a>优化访问</h3><p>目前是已经知道树莓派的IP的有两种优化的</p><ol><li><p>使用host改本地访问</p><p>目前我将host改为</p><p>192.168.2.189 yun.imlike.cc<br>192.168.2.189 portal.imlike.cc</p><p>这样这两个域名将会解析到192.168.2.189IP上,由于由于nginx上面的配置会解析 server_name对应的yun.imlike.cc,portal.imlike.cc效果如下</p><p><a href="../img/1586076685372.png"><img src="../img/1586076685372.png" alt="1586076685372"></a></p></li><li><p>使用路由器改变DNS解析,使其解析到树莓派IP</p><p>该方式还没实现,原理是一样的</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> nginx </tag>
            
            <tag> 树莓派 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树莓派docker搭建配置</title>
      <link href="/1469044090.html"/>
      <url>/1469044090.html</url>
      
        <content type="html"><![CDATA[<h3 id="搭建docker环境"><a href="#搭建docker环境" class="headerlink" title="搭建docker环境"></a>搭建docker环境</h3><p>如果你过去安装过 docker，先删掉:</p><pre><code>sudo apt-get remove docker docker-engine docker.io</code></pre><p>首先安装依赖:</p><pre><code>sudo apt-get install apt-transport-https ca-certificates curl gnupg2 software-properties-common</code></pre><p>信任 Docker 的 GPG 公钥:</p><pre><code>curl -fsSL https://download.docker.com/linux/debian/gpg | sudo apt-key add -</code></pre><p>如果你是树莓派或其它ARM架构计算机，请运行:</p><pre><code>echo &quot;deb [arch=armhf] https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/debian \     $(lsb_release -cs) stable&quot; | \    sudo tee /etc/apt/sources.list.d/docker.list</code></pre><p>最后安装</p><pre><code>sudo apt-get updatesudo apt-get install docker-ce</code></pre><h2 id="使用脚本自动安装"><a href="#使用脚本自动安装" class="headerlink" title="使用脚本自动安装"></a>使用脚本自动安装</h2><p>在测试或开发环境中 Docker 官方为了简化安装流程，提供了一套便捷的安装脚本，Raspbian 系统上可以使用这套脚本安装，另外可以通过 <code>--mirror</code> 选项使用国内源进行安装：</p><pre><code>$ curl -fsSL get.docker.com -o get-docker.sh$ sudo sh get-docker.sh --mirror Aliyun# $ sudo sh get-docker.sh --mirror AzureChinaCloud</code></pre><p>执行这个命令后，脚本就会自动的将一切准备工作做好，并且把 Docker CE 的稳定(stable)版本安装在系统中。</p><h2 id="启动-Docker-CE"><a href="#启动-Docker-CE" class="headerlink" title="启动 Docker CE"></a>启动 Docker CE</h2><pre><code>$ sudo systemctl enable docker$ sudo systemctl start docker</code></pre><h2 id="建立-docker-用户组"><a href="#建立-docker-用户组" class="headerlink" title="建立 docker 用户组"></a>建立 docker 用户组</h2><p>默认情况下，<code>docker</code> 命令会使用 <a href="https://en.wikipedia.org/wiki/Unix_domain_socket" target="_blank" rel="noopener">Unix socket</a> 与 Docker 引擎通讯。而只有 <code>root</code> 用户和 <code>docker</code> 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 <code>root</code> 用户。因此，更好地做法是将需要使用 <code>docker</code> 的用户加入 <code>docker</code> 用户组。</p><p>建立 <code>docker</code> 组：</p><pre><code>$ sudo groupadd docker</code></pre><p>将当前用户加入 <code>docker</code> 组：</p><pre><code>$ sudo usermod -aG docker $USER</code></pre><p><strong>退出当前终端并重新登录，进行如下测试。</strong></p><h3 id="测试-Docker-是否安装正确"><a href="#测试-Docker-是否安装正确" class="headerlink" title="测试 Docker 是否安装正确"></a>测试 Docker 是否安装正确</h3><pre><code>$ docker run hello-worldUnable to find image &#39;hello-world:latest&#39; locallylatest: Pulling from library/hello-world4ee5c797bcd7: Pull complete Digest: sha256:f9dfddf63636d84ef479d645ab5885156ae030f611a56f3a7ac7f2fdd86d7e4eStatus: Downloaded newer image for hello-world:latestHello from Docker!This message shows that your installation appears to be working correctly.To generate this message, Docker took the following steps:1. The Docker client contacted the Docker daemon.2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub.   (arm32v7)3. The Docker daemon created a new container from that image which runs the   executable that produces the output you are currently reading.4. The Docker daemon streamed that output to the Docker client, which sent it   to your terminal.To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bashShare images, automate workflows, and more with a free Docker ID: https://hub.docker.com/For more examples and ideas, visit: https://docs.docker.com/get-started/</code></pre><h3 id="docker-compose的安装"><a href="#docker-compose的安装" class="headerlink" title="docker-compose的安装"></a>docker-compose的安装</h3><p>开始是找的国内的镜像,但是下载一直是8k的文件不能执行打开就是文件下载失败这种内容,可能是我这个网络问题</p><pre><code>curl -L https://get.daocloud.io/docker/compose/releases/download/1.25.4/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-composechmod +x /usr/local/bin/docker-compose</code></pre><p>后面我找到别的资源</p><p>至此Docker就安装好了，再安装docker compose。<br>先看有没有pip或pip3，有就直接卸了。然后安装：</p><p>Bash</p><pre><code>$ apt-get remove python-pip python3-pip$ wget https://bootstrap.pypa.io/get-pip.py$ python get-pip.py$ python3 get-pip.py</code></pre><p>然后安装一些依赖库</p><pre><code>apt install python-dev python3-dev libevent-dev python-scipy libssl-dev libffi-devapt install apt-transport-https ca-certificates curl gnupg2 software-properties-commonpip install cryptography</code></pre><p>查看pip版本:</p><pre><code>root@raspberrypi:~# pip3 --versionpip 19.1.1 from /usr/local/lib/python3.5/dist-packages/pip (python 3.5)root@raspberrypi:~#</code></pre><p>安装docker compose<br>这里通过pip的方式安装，所以先安装pip</p><pre><code>$ pip3 install docker-compose</code></pre><p>如果你报了什么</p><pre><code>TypeError: unsupported operand type(s) for -=: &#39;Retry&#39; and &#39;int&#39;</code></pre><p>这样的错误，多半是用了上古时代的pip，参考上述方式卸载重装，然后重启一下。如果是下面这样的错</p><pre><code>pip._vendor.urllib3.exceptions.ReadTimeoutError: HTTPSConnectionPool(host=&#39;www.piwheels.org&#39;, port=443): Read timed out.</code></pre><p><strong>是由于网络连接超时，重新执行命令就好，或者用国内镜像下载。可以多试几次</strong></p><p>安装好了查看版本：</p><pre><code>root@raspberrypi:~# docker-compose --versiondocker-compose version 1.24.1, build 4667896root@raspberrypi:~#</code></pre><p>sudo pip3 install docker-compose</p><h3 id="设置docker镜像"><a href="#设置docker镜像" class="headerlink" title="设置docker镜像"></a>设置docker镜像</h3><pre><code>sudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-&#39;EOF&#39;{    &quot;registry-mirrors&quot;: [        &quot;https://1nj0zren.mirror.aliyuncs.com&quot;,        &quot;https://docker.mirrors.ustc.edu.cn&quot;,        &quot;http://f1361db2.m.daocloud.io&quot;,        &quot;https://registry.docker-cn.com&quot;    ]}EOFsudo systemctl daemon-reloadsudo systemctl restart docker</code></pre><p>镜像加速器 镜像加速器地址 专属加速器<a href="../1469044090.html#">？</a> 其它加速<a href="../1469044090.html#">？</a></p><p><a href="https://docker-cn.com/registry-mirror" target="_blank" rel="noopener">Docker 中国官方镜像</a> <code>https://registry.docker-cn.com</code></p><p>Docker Hub <a href="https://daocloud.io/mirror" target="_blank" rel="noopener">DaoCloud 镜像站</a></p><p><code>http://f1361db2.m.daocloud.io</code> 可登录，系统分配 Docker Hub</p><p><a href="https://github.com/Azure/container-service-for-azure-china/blob/master/aks/README.md#22-container-registry-proxy" target="_blank" rel="noopener">Azure 中国镜像</a> <code>https://dockerhub.azk8s.cn</code> Docker Hub、GCR、Quay <a href="https://mirrors.ustc.edu.cn/help/dockerhub.html" target="_blank" rel="noopener">科大镜像站</a> <code>https://docker.mirrors.ustc.edu.cn</code> Docker Hub、<a href="https://github.com/ustclug/mirrorrequest/issues/91" target="_blank" rel="noopener">GCR</a>、<a href="https://github.com/ustclug/mirrorrequest/issues/135" target="_blank" rel="noopener">Quay</a> <a href="https://cr.console.aliyun.com/" target="_blank" rel="noopener">阿里云</a> <code>https://&lt;your_code&gt;.mirror.aliyuncs.com</code> 需登录，系统分配 Docker Hub <a href="https://kirk-enterprise.github.io/hub-docs/#/user-guide/mirror" target="_blank" rel="noopener">七牛云</a> <code>https://reg-mirror.qiniu.com</code> Docker Hub、GCR、Quay <a href="https://c.163yun.com/hub" target="_blank" rel="noopener">网易云</a> <code>https://hub-mirror.c.163.com</code> Docker Hub <a href="https://cloud.tencent.com/document/product/457/9113" target="_blank" rel="noopener">腾讯云</a> <code>https://mirror.ccs.tencentyun.com</code> Docker Hub</p><p>作者：y0ngb1n链接：<a href="https://juejin.im/post/5cd2cf01f265da0374189441来源：掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。" target="_blank" rel="noopener">https://juejin.im/post/5cd2cf01f265da0374189441来源：掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</a></p><p>###</p><pre><code>#查看 Docker 版本docker -``vsudo` `docker pull 仓库/镜像:版本（留空的话默认为 latest）sudo` `docker run 加参数，用来创建容器#查看运行容器sudo` `docker ``ps#查看所有下载的镜像sudo` `docker images#进入容器终端sudo` `docker ``exec` `-i -t ha ``/bin/bash#实时查看10行的 ha 日志sudo` `docker logs -f -t --``tail` `10 ha#重启 systemctl 守护进程sudo` `systemctl daemon-reload#设置 Docker 开机启动sudo` `systemctl ``enable` `docker#开启 Docker 服务sudo` `systemctl start docker</code></pre><h3 id="常用配置和工具命令"><a href="#常用配置和工具命令" class="headerlink" title="常用配置和工具命令"></a>常用配置和工具命令</h3><pre><code>#查看 Docker 版本docker -vsudo docker pull 仓库/镜像:版本（留空的话默认为 latest）sudo docker run 加参数，用来创建容器#查看运行容器sudo docker ps#查看所有下载的镜像sudo docker images#进入容器终端sudo docker exec -i -t ha /bin/bash#实时查看10行的 ha 日志sudo docker logs -f -t --tail 10 ha#重启 systemctl 守护进程sudo systemctl daemon-reload#设置 Docker 开机启动sudo systemctl enable docker#开启 Docker 服务sudo systemctl start docker #下载 Docker 图形化界面 portainersudo docker pull portainer/portainer#创建 portainer 容器sudo docker volume create portainer_data#运行 portainersudo docker run -d -p 9000:9000 --name portainer --restart always -v /var/run/docker.sock:/var/run</code></pre><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>docker images,docker ps</p><p>docker pull nextcloud</p><p>docker pull portainer/portainer</p><pre><code>docker run -ti -d --name kevin-portainer -p 9000:9000 --restart=always -v /var/run/docker.sock:/var/run/docker.sock  portainer/portainerdocker run -d -p 9000:9000 -p 8000:8000 --name portainer --restart unless-stopped -v /var/run/docker.sock:/var/run/docker.sock  portainer/portainer</code></pre><p><a href="../img/1585911408361.png"><img src="../img/1585911408361.png" alt="1585911408361"></a></p><pre><code>docker run --name=my_portainer -d -p 9001:9001 -v /var/run/docker.sock:/var/run/docker.sock -v portainer_volume:/data portainer/portainer该容器命名为my_portainer，将容器中portainer默认端口9000，映射到宿主机端口9000，使用socket映射 /var/run/docker.sock:/var/run/docker.sock，指定volume映射（即将portainer_volume对应的宿主机目录挂载到容器的/data目录），容器基于portainer/portainer镜像启动</code></pre><p><a href="../img/1585911501671.png"><img src="../img/1585911501671.png" alt="1585911501671"></a></p><pre><code>mkdir /home/nextclouddocker run --name nextcloud -p 8080:80   -v /home/nextcloud:/var/www/html/data -d nextcloud参数说明：–name：设定容器名称为nextcloud-p 8080:80 ：端口映射，将宿主机8080端口映射到容器中的80端口-v /data/nextcloud:/var/www/html/data将容器中项目的data目录映射到本地/data/nextcloud目录下方便配置和数据保存-d 是以后台形式启动</code></pre><p><a href="../img/1585911463432.png"><img src="../img/1585911463432.png" alt="1585911463432"></a></p><p><a href="https://cloud.tencent.com/developer/article/1371476" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1371476</a></p><p>中间找不文件就选择下面这个命令</p><pre><code>cd /var/lib/find . -name &quot;config.php&quot;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> 树莓派 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树莓派设置用户和ssh,VN连接</title>
      <link href="/2385605860.html"/>
      <url>/2385605860.html</url>
      
        <content type="html"><![CDATA[<p>启动后的树莓派页面</p><p><a href="../img/1585892445445.png"><img src="../img/1585892445445.png" alt="1585892445445"></a></p><h2 id="ssh-连接使用private-key"><a href="#ssh-连接使用private-key" class="headerlink" title="ssh 连接使用private-key"></a>ssh 连接使用private-key</h2><p>首先是需要你已经生成了本地的秘钥,然后将本地的公钥加入到对方的authorized_keys中ssh-copy-id传过去</p><p>否则可以直接用用户和密码登陆</p><pre><code>cat ~/.ssh/id_rsa.pub | ssh  USERNAME@IP-ADDRESS &#39;cat &gt;&gt; .ssh/authorized_keys&#39;ssh-copy-id YOU-USERNAME@IP-ADDRESS</code></pre><h3 id="设置国内源"><a href="#设置国内源" class="headerlink" title="设置国内源"></a>设置国内源</h3><p><a href="https://mirror.tuna.tsinghua.edu.cn/help/raspbian/" target="_blank" rel="noopener">https://mirror.tuna.tsinghua.edu.cn/help/raspbian/</a></p><p>树莓派选择Debian 10 (buster)</p><pre><code># 编辑 `/etc/apt/sources.list` 文件，删除原文件所有内容，用以下内容取代：deb http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ buster main non-free contribdeb-src http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ buster main non-free contrib# 编辑 `/etc/apt/sources.list.d/raspi.list` 文件，删除原文件所有内容，用以下内容取代：deb http://mirrors.tuna.tsinghua.edu.cn/raspberrypi/ buster main ui</code></pre><h3 id="设置期间的问题"><a href="#设置期间的问题" class="headerlink" title="设置期间的问题"></a>设置期间的问题</h3><ol><li><p>sudo root 报su: 鉴定故障</p><pre><code>entos7 su 鉴定故障解决方法Linux(fedora\centos\ubuntu等)终端窗口运行 su 输入密码，提示鉴定失败。根据网上查询的原因是：安装linux时，未输入ROOT密码；或新建用户，勾选“设为管理员”，仅为新用户设置密码。未设置ROOT密码，系统检测失败。亲测解决方法如下：打开终端 ：sudo passwd root输入当前用户密码，然后输入设置的root密码。(重新设置root密码）</code></pre></li><li><p>sudo chmod -777 /home</p><pre><code>sudo: /etc/sudoers 可被任何人写sudo: 没有找到有效的 sudoers 资源，退出sudo: 无法初始化策略插件</code></pre><pre><code>/etc/sudoers下面的权限修改回去需要直接修改说不定就直接出什么问题了sudo su - chmod 777 /etc/sudoers echo &#39;username  ALL=(ALL)    ALL&#39; &gt;&gt; /etc/sudoers</code></pre></li><li><p>Ubuntu vi 上下左右变ABCD问题解决方法</p><pre><code>一.执行命令 sudo apt-get remove vim-common 二 .  sudo apt-get install vimcp /etc/vim/vimrc ~/.vimrc  //没网用这个</code></pre></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 树莓派 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue和element-ui初步使用</title>
      <link href="/3181160514.html"/>
      <url>/3181160514.html</url>
      
        <content type="html"><![CDATA[<p>是一套用于构建用户界面的<strong>渐进式框架</strong>。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与<a href="https://cn.vuejs.org/v2/guide/single-file-components.html" target="_blank" rel="noopener">现代化的工具链</a>以及各种<a href="https://github.com/vuejs/awesome-vue#libraries--plugins" target="_blank" rel="noopener">支持类库</a>结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。是一种 MVVM (Model-View-ViewModel)</p><ol><li><h3 id="使用vue首先是需要导入vue-js-下面就是简单的vue对象"><a href="#使用vue首先是需要导入vue-js-下面就是简单的vue对象" class="headerlink" title="使用vue首先是需要导入vue.js,下面就是简单的vue对象"></a>使用vue首先是需要导入vue.js,下面就是简单的vue对象</h3></li></ol><pre><code>![processInstance](/home/leek/桌面/processInstance.png)&lt;div id=&quot;app&quot;&gt;    &lt;h2&gt;{{name}} 显示&lt;/h2&gt;&lt;/div&gt;&lt;script src=&quot;./node_modules/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt;    // 生成一个Vue实例    var app = new Vue({        el:&quot;#app&quot;, // el,即element。要渲染的的页面元素        data:{ // 数据            name:&quot;like&quot;        }    })&lt;/script&gt;</code></pre><ol><li><h3 id="标签绑定数据"><a href="#标签绑定数据" class="headerlink" title="标签绑定数据"></a>标签绑定数据</h3></li></ol><p>常见数据绑定的熟悉是</p><ul><li><a href="https://cn.vuejs.org/v2/api/#v-text" target="_blank" rel="noopener">v-text</a> 绑定的值直接显示不解析</li><li><a href="https://cn.vuejs.org/v2/api/#v-html" target="_blank" rel="noopener">v-html</a> <strong>内容按普通 HTML 插入 - 不会作为 Vue 模板进行编译</strong></li><li><a href="https://cn.vuejs.org/v2/api/#v-show" target="_blank" rel="noopener">v-show</a> 是否显示</li><li><a href="https://cn.vuejs.org/v2/api/#v-if" target="_blank" rel="noopener">v-if</a> <strong>内容按普通 HTML 插入 - 不会作为 Vue 模板进行编译</strong></li><li><a href="https://cn.vuejs.org/v2/api/#v-for" target="_blank" rel="noopener">v-for</a></li></ul><pre><code> &lt;div v-for=&quot;(item, index) in items&quot;&gt;&lt;/div&gt;&lt;div v-for=&quot;(val, key) in object&quot;&gt;&lt;/div&gt; &lt;div v-for=&quot;(val, name, index) in object&quot;&gt;&lt;/div&gt;</code></pre><ul><li><p><a href="https://cn.vuejs.org/v2/api/#v-on" target="_blank" rel="noopener">v-on</a> 可以用@缩写@click,@node-click</p></li><li><p><a href="https://cn.vuejs.org/v2/api/#v-bind" target="_blank" rel="noopener">v-bind</a> 可以用:缩写</p><pre><code>.prop - 作为一个 DOM property 绑定而不是作为 attribute 绑定。(差别在哪里？).camel - (2.1.0+) 将 kebab-case 特性名转换为 camelCase. (从 2.1.0 开始支持).sync (2.3.0+) 语法糖，会扩展成一个更新父组件绑定值的 v-on 侦听器。</code></pre></li></ul><ol><li><h3 id="vue的声明周期"><a href="#vue的声明周期" class="headerlink" title="vue的声明周期"></a>vue的声明周期</h3></li></ol><p><a href="../img/lifecycle.png"><img src="../img/lifecycle.png" alt="lifecycle"></a></p><pre><code>var app = new Vue({    el: &quot;#app&quot;,    data: {        num: 0    },    beforeCreate() {        console.log(&quot;创建前&quot;)    },    created() {        console.log(&quot;创建&quot;)    },    beforeMount() {        console.log(&quot;计数前&quot;)    },    mounted() {        console.log(&quot;计数了&quot;)    },})</code></pre><h2 id="element-UI相关的"><a href="#element-UI相关的" class="headerlink" title="element-UI相关的"></a>element-UI相关的</h2><ol><li><h3 id="element-UI"><a href="#element-UI" class="headerlink" title="element-UI"></a>element-UI</h3><p>网站快速成型工具:一套为开发者、设计师和产品经理准备的基于 Vue 2.0 的桌面端组件库 <a href="https://element.eleme.cn/#/zh-CN/component/container" target="_blank" rel="noopener">网站</a></p></li><li><h3 id="element-UI-目前我看到的标签-表格"><a href="#element-UI-目前我看到的标签-表格" class="headerlink" title="element-UI 目前我看到的标签(表格,)"></a>element-UI 目前我看到的标签(表格,)</h3><h4 id="标签1-gt-el-pagination-用于分页-下面是它的相关参数"><a href="#标签1-gt-el-pagination-用于分页-下面是它的相关参数" class="headerlink" title="标签1-&gt;el-pagination 用于分页 下面是它的相关参数"></a>标签1-&gt;el-pagination 用于分页 下面是它的相关参数</h4><p>Attributes</p><p>| 参数 | 说明 | 类型 | 可选值 | 默认值 |<br>| ——————- | ———————————————————— | ——– | ———————————————————— | ————————————– |<br>| small | 是否使用小型分页样式 | boolean | — | false |<br>| background | 是否为分页按钮添加背景色 | boolean | — | false |<br>| page-size | 每页显示条目个数，支持 .sync 修饰符 | number | — | 10 |<br>| total | 总条目数 | number | — | — |<br>| page-count | 总页数，total 和 page-count 设置任意一个就可以达到显示页码的功能；如果要支持 page-sizes 的更改，则需要使用 total 属性 | Number | — | — |<br>| pager-count | 页码按钮的数量，当总页数超过该值时会折叠 | number | 大于等于 5 且小于等于 21 的奇数 | 7 |<br>| current-page | 当前页数，支持 .sync 修饰符 | number | — | 1 |<br>| layout | 组件布局，子组件名用逗号分隔 | String | <code>sizes</code>, <code>prev</code>, <code>pager</code>, <code>next</code>, <code>jumper</code>, <code>-&gt;</code>, <code>total</code>, <code>slot</code> | ‘prev, pager, next, jumper, -&gt;, total’ |<br>| page-sizes | 每页显示个数选择器的选项设置 | number[] | — | [10, 20, 30, 40, 50, 100] |<br>| popper-class | 每页显示个数选择器的下拉框类名 | string | — | — |<br>| prev-text | 替代图标显示的上一页文字 | string | — | — |<br>| next-text | 替代图标显示的下一页文字 | string | — | — |<br>| disabled | 是否禁用 | boolean | — | false |<br>| hide-on-single-page | 只有一页时是否隐藏 | boolean | — | - |</p><h3 id="¶-Events"><a href="#¶-Events" class="headerlink" title="¶ Events"></a><a href="https://element.eleme.cn/#/zh-CN/component/pagination#events" target="_blank" rel="noopener">¶</a> Events</h3><p>| 事件名称 | 说明 | 回调参数 |<br>| ————– | ———————————- | ——– |<br>| size-change | pageSize 改变时会触发 | 每页条数 |<br>| current-change | currentPage 改变时会触发 | 当前页 |<br>| prev-click | 用户点击上一页按钮改变当前页后触发 | 当前页 |<br>| next-click | 用户点击下一页按钮改变当前页后触发 | 当前页 |</p><h4 id="标签2-gt-el-tooltip-用于显示提示"><a href="#标签2-gt-el-tooltip-用于显示提示" class="headerlink" title="标签2-&gt;el-tooltip 用于显示提示"></a>标签2-&gt;el-tooltip 用于显示提示</h4></li></ol><p>Attributes</p><table><thead><tr><th align="center">参数</th><th align="center">说明</th><th align="center">类型</th><th align="center">可选值</th><th align="center">默认值</th></tr></thead><tbody><tr><td align="center">effect</td><td align="center">默认提供的主题</td><td align="center">String</td><td align="center">dark/light</td><td align="center">dark</td></tr><tr><td align="center">content</td><td align="center">显示的内容，也可以通过 <code>slot#content</code> 传入 DOM</td><td align="center">String</td><td align="center">—</td><td align="center">—</td></tr><tr><td align="center">placement</td><td align="center">Tooltip 的出现位置</td><td align="center">String</td><td align="center">top/top-start/top-end/bottom/bottom-start/bottom-end/left/left-start/left-end/right/right-start/right-end</td><td align="center">bottom</td></tr><tr><td align="center">value / v-model</td><td align="center">状态是否可见</td><td align="center">Boolean</td><td align="center">—</td><td align="center">false</td></tr><tr><td align="center">disabled</td><td align="center">Tooltip 是否可用</td><td align="center">Boolean</td><td align="center">—</td><td align="center">false</td></tr><tr><td align="center">offset</td><td align="center">出现位置的偏移量</td><td align="center">Number</td><td align="center">—</td><td align="center">0</td></tr><tr><td align="center">transition</td><td align="center">定义渐变动画</td><td align="center">String</td><td align="center">—</td><td align="center">el-fade-in-linear</td></tr><tr><td align="center">visible-arrow</td><td align="center">是否显示 Tooltip 箭头，更多参数可见<a href="https://github.com/element-component/vue-popper" target="_blank" rel="noopener">Vue-popper</a></td><td align="center">Boolean</td><td align="center">—</td><td align="center">true</td></tr><tr><td align="center">popper-options</td><td align="center"><a href="https://popper.js.org/documentation.html" target="_blank" rel="noopener">popper.js</a> 的参数</td><td align="center">Object</td><td align="center">参考 <a href="https://popper.js.org/documentation.html" target="_blank" rel="noopener">popper.js</a> 文档</td><td align="center">{ boundariesElement: ‘body’, gpuAcceleration: false }</td></tr><tr><td align="center">open-delay</td><td align="center">延迟出现，单位毫秒</td><td align="center">Number</td><td align="center">—</td><td align="center">0</td></tr><tr><td align="center">manual</td><td align="center">手动控制模式，设置为 true 后，mouseenter 和 mouseleave 事件将不会生效</td><td align="center">Boolean</td><td align="center">—</td><td align="center">false</td></tr><tr><td align="center">popper-class</td><td align="center">为 Tooltip 的 popper 添加类名</td><td align="center">String</td><td align="center">—</td><td align="center">—</td></tr><tr><td align="center">enterable</td><td align="center">鼠标是否可进入到 tooltip 中</td><td align="center">Boolean</td><td align="center">—</td><td align="center">true</td></tr><tr><td align="center">hide-after</td><td align="center">Tooltip 出现后自动隐藏延时，单位毫秒，为 0 则不会自动隐藏</td><td align="center">number</td><td align="center">—</td><td align="center">0</td></tr><tr><td align="center">tabindex</td><td align="center">Tooltip 组件的 <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex" target="_blank" rel="noopener">tabindex</a></td><td align="center">number</td><td align="center">—</td><td align="center">0</td></tr></tbody></table><h4 id="标签3-gt-el-table-用于显示表格-目前主要是用这个"><a href="#标签3-gt-el-table-用于显示表格-目前主要是用这个" class="headerlink" title="标签3-&gt;el-table 用于显示表格,目前主要是用这个"></a>标签3-&gt;el-table 用于显示表格,目前主要是用这个</h4><p>Table Attributes</p><table><thead><tr><th align="center">参数</th><th align="center">说明</th><th align="center">类型</th><th align="center">可选值</th><th align="center">默认值</th></tr></thead><tbody><tr><td align="center">data</td><td align="center">显示的数据</td><td align="center">array</td><td align="center">—</td><td align="center">—</td></tr><tr><td align="center">height</td><td align="center">Table 的高度，默认为自动高度。如果 height 为 number 类型，单位 px；如果 height 为 string 类型，则这个高度会设置为 Table 的 style.height 的值，Table 的高度会受控于外部样式。</td><td align="center">string/number</td><td align="center">—</td><td align="center">—</td></tr><tr><td align="center">max-height</td><td align="center">Table 的最大高度。合法的值为数字或者单位为 px 的高度。</td><td align="center">string/number</td><td align="center">—</td><td align="center">—</td></tr><tr><td align="center">stripe</td><td align="center">是否为斑马纹 table</td><td align="center">boolean</td><td align="center">—</td><td align="center">false</td></tr><tr><td align="center">border</td><td align="center">是否带有纵向边框</td><td align="center">boolean</td><td align="center">—</td><td align="center">false</td></tr><tr><td align="center">size</td><td align="center">Table 的尺寸</td><td align="center">string</td><td align="center">medium / small / mini</td><td align="center">—</td></tr><tr><td align="center">fit</td><td align="center">列的宽度是否自撑开</td><td align="center">boolean</td><td align="center">—</td><td align="center">true</td></tr><tr><td align="center">show-header</td><td align="center">是否显示表头</td><td align="center">boolean</td><td align="center">—</td><td align="center">true</td></tr><tr><td align="center">highlight-current-row</td><td align="center">是否要高亮当前行</td><td align="center">boolean</td><td align="center">—</td><td align="center">false</td></tr><tr><td align="center">current-row-key</td><td align="center">当前行的 key，只写属性</td><td align="center">String,Number</td><td align="center">—</td><td align="center">—</td></tr><tr><td align="center">row-class-name</td><td align="center">行的 className 的回调方法，也可以使用字符串为所有行设置一个固定的 className。</td><td align="center">Function({row, rowIndex})/String</td><td align="center">—</td><td align="center">—</td></tr><tr><td align="center">row-style</td><td align="center">行的 style 的回调方法，也可以使用一个固定的 Object 为所有行设置一样的 Style。</td><td align="center">Function({row, rowIndex})/Object</td><td align="center">—</td><td align="center">—</td></tr><tr><td align="center">cell-class-name</td><td align="center">单元格的 className 的回调方法，也可以使用字符串为所有单元格设置一个固定的 className。</td><td align="center">Function({row, column, rowIndex, columnIndex})/String</td><td align="center">—</td><td align="center">—</td></tr><tr><td align="center">cell-style</td><td align="center">单元格的 style 的回调方法，也可以使用一个固定的 Object 为所有单元格设置一样的 Style。</td><td align="center">Function({row, column, rowIndex, columnIndex})/Object</td><td align="center">—</td><td align="center">—</td></tr><tr><td align="center">header-row-class-name</td><td align="center">表头行的 className 的回调方法，也可以使用字符串为所有表头行设置一个固定的 className。</td><td align="center">Function({row, rowIndex})/String</td><td align="center">—</td><td align="center">—</td></tr><tr><td align="center">header-row-style</td><td align="center">表头行的 style 的回调方法，也可以使用一个固定的 Object 为所有表头行设置一样的 Style。</td><td align="center">Function({row, rowIndex})/Object</td><td align="center">—</td><td align="center">—</td></tr><tr><td align="center">header-cell-class-name</td><td align="center">表头单元格的 className 的回调方法，也可以使用字符串为所有表头单元格设置一个固定的 className。</td><td align="center">Function({row, column, rowIndex, columnIndex})/String</td><td align="center">—</td><td align="center">—</td></tr><tr><td align="center">header-cell-style</td><td align="center">表头单元格的 style 的回调方法，也可以使用一个固定的 Object 为所有表头单元格设置一样的 Style。</td><td align="center">Function({row, column, rowIndex, columnIndex})/Object</td><td align="center">—</td><td align="center">—</td></tr><tr><td align="center">row-key</td><td align="center">行数据的 Key，用来优化 Table 的渲染；在使用 reserve-selection 功能与显示树形数据时，该属性是必填的。类型为 String 时，支持多层访问：<code>user.info.id</code>，但不支持 <code>user.info[0].id</code>，此种情况请使用 <code>Function</code>。</td><td align="center">Function(row)/String</td><td align="center">—</td><td align="center">—</td></tr><tr><td align="center">empty-text</td><td align="center">空数据时显示的文本内容，也可以通过 <code>slot=&quot;empty&quot;</code> 设置</td><td align="center">String</td><td align="center">—</td><td align="center">暂无数据</td></tr><tr><td align="center">default-expand-all</td><td align="center">是否默认展开所有行，当 Table 包含展开行存在或者为树形表格时有效</td><td align="center">Boolean</td><td align="center">—</td><td align="center">false</td></tr><tr><td align="center">expand-row-keys</td><td align="center">可以通过该属性设置 Table 目前的展开行，需要设置 row-key 属性才能使用，该属性为展开行的 keys 数组。</td><td align="center">Array</td><td align="center">—</td><td align="center"></td></tr><tr><td align="center">default-sort</td><td align="center">默认的排序列的 prop 和顺序。它的<code>prop</code>属性指定默认的排序的列，<code>order</code>指定默认排序的顺序</td><td align="center">Object</td><td align="center"><code>order</code>: ascending, descending</td><td align="center">如果只指定了<code>prop</code>, 没有指定<code>order</code>, 则默认顺序是ascending</td></tr><tr><td align="center">tooltip-effect</td><td align="center">tooltip <code>effect</code> 属性</td><td align="center">String</td><td align="center">dark/light</td><td align="center"></td></tr><tr><td align="center">show-summary</td><td align="center">是否在表尾显示合计行</td><td align="center">Boolean</td><td align="center">—</td><td align="center">false</td></tr><tr><td align="center">sum-text</td><td align="center">合计行第一列的文本</td><td align="center">String</td><td align="center">—</td><td align="center">合计</td></tr><tr><td align="center">summary-method</td><td align="center">自定义的合计计算方法</td><td align="center">Function({ columns, data })</td><td align="center">—</td><td align="center">—</td></tr><tr><td align="center">span-method</td><td align="center">合并行或列的计算方法</td><td align="center">Function({ row, column, rowIndex, columnIndex })</td><td align="center">—</td><td align="center">—</td></tr><tr><td align="center">select-on-indeterminate</td><td align="center">在多选表格中，当仅有部分行被选中时，点击表头的多选框时的行为。若为 true，则选中所有行；若为 false，则取消选择所有行</td><td align="center">Boolean</td><td align="center">—</td><td align="center">true</td></tr><tr><td align="center">indent</td><td align="center">展示树形数据时，树节点的缩进</td><td align="center">Number</td><td align="center">—</td><td align="center">16</td></tr><tr><td align="center">lazy</td><td align="center">是否懒加载子节点数据</td><td align="center">Boolean</td><td align="center">—</td><td align="center">—</td></tr><tr><td align="center">load</td><td align="center">加载子节点数据的函数，lazy 为 true 时生效，函数第二个参数包含了节点的层级信息</td><td align="center">Function(row, treeNode, resolve)</td><td align="center">—</td><td align="center">—</td></tr><tr><td align="center">tree-props</td><td align="center">渲染嵌套数据的配置选项</td><td align="center">Object</td><td align="center">—</td><td align="center">{ hasChildren: ‘hasChildren’, children: ‘children’ }</td></tr></tbody></table><p><a href="https://element.eleme.cn/#/zh-CN/component/table#table-events" target="_blank" rel="noopener">¶</a> Table Events</p><table><thead><tr><th align="center">事件名</th><th align="center">说明</th><th align="center">参数</th><th></th></tr></thead><tbody><tr><td align="center">select</td><td align="center">当用户手动勾选数据行的 Checkbox 时触发的事件</td><td align="center">selection, row</td><td></td></tr><tr><td align="center">select-all</td><td align="center">当用户手动勾选全选 Checkbox 时触发的事件</td><td align="center">selection</td><td></td></tr><tr><td align="center">selection-change</td><td align="center">当选择项发生变化时会触发该事件</td><td align="center">selection</td><td></td></tr><tr><td align="center">cell-mouse-enter</td><td align="center">当单元格 hover 进入时会触发该事件</td><td align="center">row, column, cell, event</td><td></td></tr><tr><td align="center">cell-mouse-leave</td><td align="center">当单元格 hover 退出时会触发该事件</td><td align="center">row, column, cell, event</td><td></td></tr><tr><td align="center">cell-click</td><td align="center">当某个单元格被点击时会触发该事件</td><td align="center">row, column, cell, event</td><td></td></tr><tr><td align="center">cell-dblclick</td><td align="center">当某个单元格被双击击时会触发该事件</td><td align="center">row, column, cell, event</td><td></td></tr><tr><td align="center">row-click</td><td align="center">当某一行被点击时会触发该事件</td><td align="center">row, column, event</td><td></td></tr><tr><td align="center">row-contextmenu</td><td align="center">当某一行被鼠标右键点击时会触发该事件</td><td align="center">row, column, event</td><td></td></tr><tr><td align="center">row-dblclick</td><td align="center">当某一行被双击时会触发该事件</td><td align="center">row, column, event</td><td></td></tr><tr><td align="center">header-click</td><td align="center">当某一列的表头被点击时会触发该事件</td><td align="center">column, event</td><td></td></tr><tr><td align="center">header-contextmenu</td><td align="center">当某一列的表头被鼠标右键点击时触发该事件</td><td align="center">column, event</td><td></td></tr><tr><td align="center">sort-change</td><td align="center">当表格的排序条件发生变化的时候会触发该事件</td><td align="center">{ column, prop, order }</td><td></td></tr><tr><td align="center">filter-change</td><td align="center">当表格的筛选条件发生变化的时候会触发该事件，参数的值是一个对象，对象的 key 是 column 的 columnKey，对应的 value 为用户选择的筛选条件的数组。</td><td align="center">filters</td><td></td></tr><tr><td align="center">current-change</td><td align="center">当表格的当前行发生变化的时候会触发该事件，如果要高亮当前行，请打开表格的 highlight-current-row 属性</td><td align="center">currentRow, oldCurrentRow</td><td></td></tr><tr><td align="center">header-dragend</td><td align="center">当拖动表头改变了列的宽度的时候会触发该事件</td><td align="center">newWidth, oldWidth, column, event</td><td></td></tr><tr><td align="center">expand-change</td><td align="center">当用户对某一行展开或者关闭的时候会触发该事件（展开行时，回调的第二个参数为 expandedRows；树形表格时第二参数为 expanded）</td><td align="center">row, (expandedRows \</td><td>expanded)</td></tr></tbody></table><p><a href="https://element.eleme.cn/#/zh-CN/component/table#table-methods" target="_blank" rel="noopener">¶</a> Table Methods</p><table><thead><tr><th align="center">方法名</th><th align="center">说明</th><th align="center">参数</th></tr></thead><tbody><tr><td align="center">clearSelection</td><td align="center">用于多选表格，清空用户的选择</td><td align="center">—</td></tr><tr><td align="center">toggleRowSelection</td><td align="center">用于多选表格，切换某一行的选中状态，如果使用了第二个参数，则是设置这一行选中与否（selected 为 true 则选中）</td><td align="center">row, selected</td></tr><tr><td align="center">toggleAllSelection</td><td align="center">用于多选表格，切换所有行的选中状态</td><td align="center">-</td></tr><tr><td align="center">toggleRowExpansion</td><td align="center">用于可展开表格与树形表格，切换某一行的展开状态，如果使用了第二个参数，则是设置这一行展开与否（expanded 为 true 则展开）</td><td align="center">row, expanded</td></tr><tr><td align="center">setCurrentRow</td><td align="center">用于单选表格，设定某一行为选中行，如果调用时不加参数，则会取消目前高亮行的选中状态。</td><td align="center">row</td></tr><tr><td align="center">clearSort</td><td align="center">用于清空排序条件，数据会恢复成未排序的状态</td><td align="center">—</td></tr><tr><td align="center">clearFilter</td><td align="center">不传入参数时用于清空所有过滤条件，数据会恢复成未过滤的状态，也可传入由columnKey组成的数组以清除指定列的过滤条件</td><td align="center">columnKey</td></tr><tr><td align="center">doLayout</td><td align="center">对 Table 进行重新布局。当 Table 或其祖先元素由隐藏切换为显示时，可能需要调用此方法</td><td align="center">—</td></tr><tr><td align="center">sort</td><td align="center">手动对 Table 进行排序。参数<code>prop</code>属性指定排序列，<code>order</code>指定排序顺序。</td><td align="center">prop: string, order: string</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VUE初级教程</title>
      <link href="/1664911364.html"/>
      <url>/1664911364.html</url>
      
        <content type="html"><![CDATA[<p><a href="http://caibaojian.com/fetching-data-with-vue-js.html" target="_blank" rel="noopener">使用Vue.js和Axios从第三方API获取请求数据</a></p><p><a href="https://www.cnblogs.com/jianxian/p/11938752.html" target="_blank" rel="noopener">axios之Vue请求初始化数据放在Created还是Mounted？</a></p><h2 id="axios介绍"><a href="#axios介绍" class="headerlink" title="axios介绍"></a>axios介绍</h2><p>基于Promise的HTTP客户端，用于浏览器和node.js <a href="https://github.com/axios/axios" target="_blank" rel="noopener">axios-github</a></p><ul><li>制作<a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest" target="_blank" rel="noopener">的XMLHttpRequest</a>从浏览器</li><li>让<a href="http://nodejs.org/api/http.html" target="_blank" rel="noopener">HTTP</a>从node.js的请求</li><li>支持<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener">Promise</a> API</li><li>拦截请求和响应</li><li>转换请求和响应数据</li><li>取消请求</li><li>JSON数据的自动转换</li><li>客户端支持以防止<a href="http://en.wikipedia.org/wiki/Cross-site_request_forgery" target="_blank" rel="noopener">XSRF</a></li></ul><h3 id="vue的初始化过程"><a href="#vue的初始化过程" class="headerlink" title="vue的初始化过程"></a>vue的初始化过程</h3><p><a href="../img/lifecycle.png"><img src="../img/lifecycle.png" alt="lifecycle"></a></p><pre><code>var app = new Vue({        el: &quot;#app&quot;,        data: {            num: 0        },        beforeCreate() {                console.log(&quot;创建前&quot;)        },        created() {            console.log(&quot;创建&quot;)        },        beforeMount() {            console.log(&quot;计数前&quot;)        },        mounted() {            console.log(&quot;计数了&quot;)        },    })</code></pre><h2 id="之前赋值不到vue的data里"><a href="#之前赋值不到vue的data里" class="headerlink" title="之前赋值不到vue的data里"></a>之前赋值不到vue的data里</h2><p>最开始放在 created(),mounted()都可以赋值过去</p><pre><code>var mydata=&quot;&quot; ;var app = new Vue({        el: &quot;#app&quot;,        data: {            num: 0,            tableDataA:mydata        },        beforeCreate() {                console.log(&quot;创建前&quot;)        },        created() {            console.log(&quot;创建&quot;)        },        beforeMount() {            console.log(&quot;计数前&quot;)        },        mounted() {            console.log(&quot;计数了&quot;)        },    })axios.get(&#39;http://localhost:8081/BackSpace/test&#39;)    .then(function (response) {    // mydata=response.data 刚开始使用的这个 但是一直赋值不过去        //这个方法也不行,this不能指代当前这个app对象    this.tableDataA=response.data})    .catch(function (error) {    console.log(error);});</code></pre><p>成功的版本</p><pre><code>axios.get(&#39;http://localhost:8081/BackSpace/test&#39;).then(response =&gt; {this.tableDataA=response.data}).catch(function (error) {console.log(error);});</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VScode优化和插件推荐</title>
      <link href="/2425517015.html"/>
      <url>/2425517015.html</url>
      
        <content type="html"><![CDATA[<h4 id="Auto-Close-Tag-自动闭合标签"><a href="#Auto-Close-Tag-自动闭合标签" class="headerlink" title="Auto Close Tag 自动闭合标签"></a>Auto Close Tag 自动闭合标签</h4><h4 id="Auto-Rename-Tag-尾部闭合标签同步修改"><a href="#Auto-Rename-Tag-尾部闭合标签同步修改" class="headerlink" title="Auto Rename Tag 尾部闭合标签同步修改"></a>Auto Rename Tag 尾部闭合标签同步修改</h4><h4 id="Live-Server-实时预览"><a href="#Live-Server-实时预览" class="headerlink" title="Live Server 实时预览"></a>Live Server 实时预览</h4><h4 id="Bracket-Pair-Colorizer-用不同颜色高亮显示匹配的括号"><a href="#Bracket-Pair-Colorizer-用不同颜色高亮显示匹配的括号" class="headerlink" title="Bracket Pair Colorizer 用不同颜色高亮显示匹配的括号"></a>Bracket Pair Colorizer 用不同颜色高亮显示匹配的括号</h4><h4 id="Highlight-Matching-Tag-高亮显示匹配标签"><a href="#Highlight-Matching-Tag-高亮显示匹配标签" class="headerlink" title="Highlight Matching Tag 高亮显示匹配标签"></a>Highlight Matching Tag 高亮显示匹配标签</h4><h4 id="Vscode-icons-VSCode-文件图标"><a href="#Vscode-icons-VSCode-文件图标" class="headerlink" title="Vscode-icons VSCode 文件图标"></a>Vscode-icons VSCode 文件图标</h4><h3 id="优化字段的字体"><a href="#优化字段的字体" class="headerlink" title="优化字段的字体"></a>优化字段的字体</h3><p> 需要编辑 Editor: Font Family 下我的设置<strong>‘Droid Sans Mono’, ‘monospace’, monospace, ‘Droid Sans Fallback’</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下搭建vue环境以及出现No command &#39;vue&#39;found</title>
      <link href="/3693735390.html"/>
      <url>/3693735390.html</url>
      
        <content type="html"><![CDATA[<h3 id="搭建nodejs环境"><a href="#搭建nodejs环境" class="headerlink" title="搭建nodejs环境"></a>搭建nodejs环境</h3><pre><code>1. 下载node的Linux版2. 解压后放在/user/local/ 下或者其他位置3. 设置国内的淘宝源  npm config set registry=https://registry.npm.taobao.org    或者使用npm install -g cnpm --registry=https://registry.npm.taobao.org安装完成后同样要建软链接，否则在使用                cnpm时会报No command &#39;cnpm&#39; found的错误。sudo ln -s /home/formularoom/env/node-v8.1.2-linux-x64/bin/cnpm /usr/local/bin/cnpm</code></pre><p>常见npm设置命令 npm config get/set xxxx ,其中xxx代指prefix ,registry等,其对于的配置文件地址 ~/.npmrc</p><h3 id="下载vuejs"><a href="#下载vuejs" class="headerlink" title="下载vuejs"></a>下载vuejs</h3><pre><code>npm install -g vue-cli</code></pre><h3 id="出现-No-command-‘vue’found"><a href="#出现-No-command-‘vue’found" class="headerlink" title="出现 No command ‘vue’found"></a>出现 No command ‘vue’found</h3><p>由于 /usr/local/bin下面没有对于命令所以显示找不到这个命令,需要建立软链接</p><p>sudo ln -s /usr/local/node-v8.9.3-linux-x64/bin/vue /usr/local/bin/vue</p><p><a href="https://blog.csdn.net/FormulaRoom/article/details/73920741" target="_blank" rel="noopener">Linux下Vue开发环境搭建一篇全搞定</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> npm </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>提交文件MultipartFile后ZipEntry.size一直为-1</title>
      <link href="/3269460028.html"/>
      <url>/3269460028.html</url>
      
        <content type="html"><![CDATA[<p>先看一下代码</p><pre><code>public static void importModels(MultipartFile file) throws IOException, InvalidFormatException {        ZipInputStream zipInputStream = new ZipInputStream(file.getInputStream(), Charset.defaultCharset());        BufferedInputStream bs = new BufferedInputStream(zipInputStream);        Map&lt;String, Map&gt; stringMapMap;        Map&lt;String,String&gt; modelJsons=new HashMap&lt;&gt;();        ZipEntry zipEntry;        String zipFileName;        while((zipEntry = zipInputStream.getNextEntry()) != null){            if (zipEntry.isDirectory()) {                // do nothing            } else if(zipEntry.getName().endsWith(&quot;json&quot;)){                String name = zipEntry.getName();                long size = zipEntry.getSize();                if (size == -1) {                    ByteArrayOutputStream baos = new ByteArrayOutputStream();                    while (true) {                        int bytes = zipInputStream.read();                        if (bytes == -1) {break;}                        baos.write(bytes);                    }                    baos.close();                    System.out.println(String.format(&quot;Name:%s,Content:%s&quot;,name,new String(baos.toByteArray())));                } else { // ZipEntry的size正常                    byte[] bytes = new byte[(int) zipEntry.getSize()];                    zipInputStream.read(bytes, 0, (int) zipEntry.getSize());                    System.out.println(String.format(&quot;Name:%s,Content:%s&quot;,name,new String(bytes)));                }            }else if (zipEntry.getName().endsWith(&quot;xlxs&quot;)){               //do other things            }else{                return;            }        }        return;    }</code></pre><h2 id="文件提交后台"><a href="#文件提交后台" class="headerlink" title="文件提交后台"></a>文件提交后台</h2><p>是提交后天后文件并不是在本地,网上之前有提供zipfile后读取在我这边是不可能实现</p><pre><code>  while((ze = zin.getNextEntry()) != null){BufferedReader bufferedReader = new BufferedReader(  new InputStreamReader(zin));                BufferedReader reader = new BufferedReader(new InputStreamReader(file.getInputStream()));                String str;                while ((str = reader.readLine()) != null){                    System.out.println(str);                }  }</code></pre><p>上面的读取的是整个Zip文件,和要求不符</p><p><a href="http://cxis.me/2018/03/03/上传Zip文件不解压读取文件内容时ZipEntry的size为-1的问题/" target="_blank" rel="noopener">上传Zip文件不解压读取文件内容时ZipEntry的size为-1的问题</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu导致不能复制剪切板</title>
      <link href="/3534202997.html"/>
      <url>/3534202997.html</url>
      
        <content type="html"><![CDATA[<h3 id="剪切板不能共享"><a href="#剪切板不能共享" class="headerlink" title="剪切板不能共享"></a>剪切板不能共享</h3><p> 以Ubuntu为主机(host)的系统,在vmware的虚拟机(guest)一直无法复制剪切板上的文字,网上看到的都是给Linux的虚拟机安装 vmware tools 的过程,刚开始以为是Linux主机导致 vmware workspace无法安装</p><p> 因为我看到所有Windows安装VMware Workstation的软件在有vmware tools后都有重新安装 tools的<a href="../img/vm.png"><img src="../img/vm.png" alt="img"></a></p><p>所以后面我都以为是系统缘故导致的</p><h3 id="确定原因和解决方案"><a href="#确定原因和解决方案" class="headerlink" title="确定原因和解决方案"></a>确定原因和解决方案</h3><p>最近有不文档需要复制,我就准备重新下载安装VMware Workstation<a href="https://my.vmware.com/cn/web/vmware/details?downloadGroup=WKST-1551-LX&productId=799&rPId=39514" target="_blank" rel="noopener">链接地址</a></p><pre><code>Name: VMware-Workstation-Full-15.5.1-15018445.x86_64.bundle发行日期: 2019-11-12内部版本号: 15018445This Workstation bundle includes the full product and VMware Tools for Linux 64-bit operating systems.MD5SUM: dfaa7c3b858df839db6d006437142e98SHA1SUM: c82e66f28fb5cc6fac4c38c55727cc45b916d107SHA256SUM: 490f8fe8d874c27601c155c1b2c0055ad0d4f14feb32fa9f18643659a147d3c6</code></pre><p>发现其实是附带了tools,然后我就找到<a href="https://my.vmware.com/web/vmware/details?downloadGroup=VMTOOLS10310&productId=742" target="_blank" rel="noopener">Download VMware Tools 10.3.10</a> 的链接,然后下载解压下面是目录结构</p><p><a href="../img/1583206861166.png"><img src="../img/1583206861166.png" alt="1583206861166"></a></p><p>给对于虚拟机安装上后就可以复制了下面是 <a href="https://docs.vmware.com/en/VMware-Workstation-Pro/15.0/com.vmware.ws.using.doc/GUID-08BB9465-D40A-4E16-9E15-8C016CC8166F.html" target="_blank" rel="noopener">Linux的安装步骤方法1</a> <a href="https://www.jianshu.com/p/34e85ad3cfad" target="_blank" rel="noopener">Linux的安装步骤方法2</a></p><p>需要注意的的tools安装文件已经在上面压缩包里面都有了,所以直接解压执行省略步骤方法前面的几个步骤</p>]]></content>
      
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
            <tag> vmware </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>activiti用法和结构</title>
      <link href="/745403789.html"/>
      <url>/745403789.html</url>
      
        <content type="html"><![CDATA[<p>rocessengineConfiguration -&gt;processEngine-&gt;respositoryService</p><pre><code>taskSerivice 对于任务的查询                           identityService 用户先关的查询                           formService                           runtimeService                           ManagementService                           HistoryService                           对于上面的接口</code></pre><p>ProcessEngines.getDefaultProcessEngine()会在第一次调用时 初始化并创建一个流程引擎，以后再调用就会返回相同的流程引擎。 使用对应的方法可以创建和关闭所有流程引擎：ProcessEngines.init() 和 ProcessEngines.destroy()。</p><p>RepositoryService可能是使用Activiti引擎时最先接触的服务。 它提供了管理和控制发布包和流程定义的操作。 这里不涉及太多细节，流程定义是BPMN 2.0流程的java实现。 它包含了一个流程每个环节的结构和行为。 发布包是Activiti引擎的打包单位。一个发布包可以包含多个BPMN 2.0 xml文件和其他资源。 开发者可以自由选择把任意资源包含到发布包中。 既可以把一个单独的BPMN 2.0 xml文件放到发布包里，也可以把整个流程和相关资源都放在一起。 （比如，’hr-processes’实例可以包含hr流程相关的任何资源）。 可以通过RepositoryService来部署这种发布包。 发布一个发布包，意味着把它上传到引擎中，所有流程都会在保存进数据库之前分析解析好。 从这点来说，系统知道这个发布包的存在，发布包中包含的流程就已经可以启动了。</p><p>RuntimeService正好是完全相反的。它负责启动一个流程定义的新实例。 如上所述，流程定义定义了流程各个节点的结构和行为。 流程实例就是这样一个流程定义的实例。对每个流程定义来说，同一时间会有很多实例在执行。 RuntimeService也可以用来获取和保存流程变量。 这些数据是特定于某个流程实例的，并会被很多流程中的节点使用 （比如，一个排他网关常常使用流程变量来决定选择哪条路径继续流程）。 Runtimeservice也能查询流程实例和执行。 执行对应BPMN 2.0中的’token’。基本上执行指向流程实例当前在哪里。 最后，RuntimeService可以在流程实例等待外部触发时使用，这时可以用来继续流程实例。 流程实例可以有很多暂停状态，而服务提供了多种方法来’触发’实例， 接受外部触发后，流程实例就会继续向下执行。</p><p>它是Activiti这类BPMN引擎的核心功能之一。 所有与任务有关的功能都包含在TaskService中：<br>查询分配给用户或组的任务</p><pre><code>创建独立运行任务。这些任务与流程实例无关。手工设置任务的执行者，或者这些用户通过何种方式与任务关联。认领并完成一个任务。认领意味着一个人期望成为任务的执行者， 即这个用户会完成这个任务。完成意味着“做这个任务要求的事情”。 通常来说会有很多种处理形式。</code></pre><p>IdentityService非常简单。它可以管理（创建，更新，删除，查询…）群组和用户。 请注意， Activiti执行时并没有对用户进行检查。 例如，任务可以分配给任何人，但是引擎不会校验系统中是否存在这个用户。 这是Activiti引擎也可以使用外部服务，比如ldap，活动目录，等等。</p><p>FormService是一个可选服务。即使不使用它，Activiti也可以完美运行， 不会损失任何功能。这个服务提供了启动表单和任务表单两个概念。 启动表单会在流程实例启动之前展示给用户， 任务表单会在用户完成任务时展示。Activiti支持在BPMN 2.0流程定义中设置这些表单。 这个服务以一种简单的方式将数据暴露出来。再次重申，它时可选的， 表单也不一定要嵌入到流程定义中。</p><p>HistoryService提供了Activiti引擎手机的所有历史数据。 在执行流程时，引擎会保存很多数据（根据配置），比如流程实例启动时间，任务的参与者， 完成任务的时间，每个流程实例的执行路径，等等。 这个服务主要通过查询功能来获得这些数据。</p><p>ManagementService在使用Activiti的定制环境中基本上不会用到。 它可以查询数据库的表和表的元数据。另外，它提供了查询和管理异步操作的功能。 Activiti的异步操作用途很多，比如定时器，异步操作， 延迟暂停、激活，等等。后续，会讨论这些功能的更多细节。</p><h3 id="支持的事件类型"><a href="#支持的事件类型" class="headerlink" title="支持的事件类型"></a>支持的事件类型</h3><p>下面是引擎中可能出现的所有activiti事件类型。每个类型都对应<code>org.activiti.engine.delegate.event.ActivitiEventType</code>中的一个枚举值。</p><p>Table 3.2. 支持的事件**</p><table><thead><tr><th align="center">事件名称</th><th align="left">描述</th><th align="center">事件类型</th></tr></thead><tbody><tr><td align="center">ENGINE_CREATED</td><td align="left">监听器监听的流程引擎已经创建完毕，并准备好接受API调用。</td><td align="center"><code>org.activiti...ActivitiEvent</code></td></tr><tr><td align="center">ENGINE_CLOSED</td><td align="left">监听器监听的流程引擎已经关闭，不再接受API调用。</td><td align="center"><code>org.activiti...ActivitiEvent</code></td></tr><tr><td align="center">ENTITY_CREATED</td><td align="left">创建了一个新实体。实体包含在事件中。</td><td align="center"><code>org.activiti...ActivitiEntityEvent</code></td></tr><tr><td align="center">ENTITY_INITIALIZED</td><td align="left">创建了一个新实体，初始化也完成了。如果这个实体的创建会包含子实体的创建，这个事件会在子实体都创建/初始化完成后被触发，这是与<code>ENTITY_CREATED</code>的区别。</td><td align="center"><code>org.activiti...ActivitiEntityEvent</code></td></tr><tr><td align="center">ENTITY_UPDATED</td><td align="left">更新了已存在的实体。实体包含在事件中。</td><td align="center"><code>org.activiti...ActivitiEntityEvent</code></td></tr><tr><td align="center">ENTITY_DELETED</td><td align="left">删除了已存在的实体。实体包含在事件中。</td><td align="center"><code>org.activiti...ActivitiEntityEvent</code></td></tr><tr><td align="center">ENTITY_SUSPENDED</td><td align="left">暂停了已存在的实体。实体包含在事件中。会被ProcessDefinitions, ProcessInstances 和 Tasks抛出。</td><td align="center"><code>org.activiti...ActivitiEntityEvent</code></td></tr><tr><td align="center">ENTITY_ACTIVATED</td><td align="left">激活了已存在的实体，实体包含在事件中。会被ProcessDefinitions, ProcessInstances 和 Tasks抛出。</td><td align="center"><code>org.activiti...ActivitiEntityEvent</code></td></tr><tr><td align="center">JOB_EXECUTION_SUCCESS</td><td align="left">作业执行成功。job包含在事件中。</td><td align="center"><code>org.activiti...ActivitiEntityEvent</code></td></tr><tr><td align="center">JOB_EXECUTION_FAILURE</td><td align="left">作业执行失败。作业和异常信息包含在事件中。</td><td align="center"><code>org.activiti...ActivitiEntityEvent</code> and <code>org.activiti...ActivitiExceptionEvent</code></td></tr><tr><td align="center">JOB_RETRIES_DECREMENTED</td><td align="left">因为作业执行失败，导致重试次数减少。作业包含在事件中。</td><td align="center"><code>org.activiti...ActivitiEntityEvent</code></td></tr><tr><td align="center">TIMER_FIRED</td><td align="left">触发了定时器。job包含在事件中。</td><td align="center"><code>org.activiti...ActivitiEntityEvent</code></td></tr><tr><td align="center">JOB_CANCELED</td><td align="left">取消了一个作业。事件包含取消的作业。作业可以通过API调用取消， 任务完成后对应的边界定时器也会取消，在新流程定义发布时也会取消。</td><td align="center"><code>org.activiti...ActivitiEntityEvent</code></td></tr><tr><td align="center">ACTIVITY_STARTED</td><td align="left">一个节点开始执行</td><td align="center"><code>org.activiti...ActivitiActivityEvent</code></td></tr><tr><td align="center">ACTIVITY_COMPLETED</td><td align="left">一个节点成功结束</td><td align="center"><code>org.activiti...ActivitiActivityEvent</code></td></tr><tr><td align="center">ACTIVITY_SIGNALED</td><td align="left">一个节点收到了一个信号</td><td align="center"><code>org.activiti...ActivitiSignalEvent</code></td></tr><tr><td align="center">ACTIVITY_MESSAGE_RECEIVED</td><td align="left">一个节点收到了一个消息。在节点收到消息之前触发。收到后，会触发<code>ACTIVITY_SIGNAL</code>或<code>ACTIVITY_STARTED</code>，这会根据节点的类型（边界事件，事件子流程开始事件）</td><td align="center"><code>org.activiti...ActivitiMessageEvent</code></td></tr><tr><td align="center">ACTIVITY_ERROR_RECEIVED</td><td align="left">一个节点收到了一个错误事件。在节点实际处理错误之前触发。 事件的<code>activityId</code>对应着处理错误的节点。 这个事件后续会是<code>ACTIVITY_SIGNALLED</code>或<code>ACTIVITY_COMPLETE</code>， 如果错误发送成功的话。</td><td align="center"><code>org.activiti...ActivitiErrorEvent</code></td></tr><tr><td align="center">UNCAUGHT_BPMN_ERROR</td><td align="left">抛出了未捕获的BPMN错误。流程没有提供针对这个错误的处理器。 事件的<code>activityId</code>为空。</td><td align="center"><code>org.activiti...ActivitiErrorEvent</code></td></tr><tr><td align="center">ACTIVITY_COMPENSATE</td><td align="left">一个节点将要被补偿。事件包含了将要执行补偿的节点id。</td><td align="center"><code>org.activiti...ActivitiActivityEvent</code></td></tr><tr><td align="center">VARIABLE_CREATED</td><td align="left">创建了一个变量。事件包含变量名，变量值和对应的分支或任务（如果存在）。</td><td align="center"><code>org.activiti...ActivitiVariableEvent</code></td></tr><tr><td align="center">VARIABLE_UPDATED</td><td align="left">更新了一个变量。事件包含变量名，变量值和对应的分支或任务（如果存在）。</td><td align="center"><code>org.activiti...ActivitiVariableEvent</code></td></tr><tr><td align="center">VARIABLE_DELETED</td><td align="left">删除了一个变量。事件包含变量名，变量值和对应的分支或任务（如果存在）。</td><td align="center"><code>org.activiti...ActivitiVariableEvent</code></td></tr><tr><td align="center">TASK_ASSIGNED</td><td align="left">任务被分配给了一个人员。事件包含任务。</td><td align="center"><code>org.activiti...ActivitiEntityEvent</code></td></tr><tr><td align="center">TASK_CREATED</td><td align="left">创建了新任务。它位于<code>ENTITY_CREATE</code>事件之后。当任务是由流程创建时， 这个事件会在TaskListener执行之前被执行。</td><td align="center"><code>org.activiti...ActivitiEntityEvent</code></td></tr><tr><td align="center">TASK_COMPLETED</td><td align="left">任务被完成了。它会在<code>ENTITY_DELETE</code>事件之前触发。当任务是流程一部分时，事件会在流程继续运行之前， 后续事件将是<code>ACTIVITY_COMPLETE</code>，对应着完成任务的节点。</td><td align="center"><code>org.activiti...ActivitiEntityEvent</code></td></tr><tr><td align="center">TASK_TIMEOUT</td><td align="left">任务已超时，在<code>TIMER_FIRED</code>事件之后，会触发用户任务的超时事件， 当这个任务分配了一个定时器的时候。</td><td align="center"><code>org.activiti...ActivitiEntityEvent</code></td></tr><tr><td align="center">PROCESS_COMPLETED</td><td align="left">流程已结束。在最后一个节点的<code>ACTIVITY_COMPLETED</code>事件之后触发。 当流程到达的状态，没有任何后续连线时， 流程就会结束。</td><td align="center"><code>org.activiti...ActivitiEntityEvent</code></td></tr><tr><td align="center">MEMBERSHIP_CREATED</td><td align="left">用户被添加到一个组里。事件包含了用户和组的id。</td><td align="center"><code>org.activiti...ActivitiMembershipEvent</code></td></tr><tr><td align="center">MEMBERSHIP_DELETED</td><td align="left">用户被从一个组中删除。事件包含了用户和组的id。</td><td align="center"><code>org.activiti...ActivitiMembershipEvent</code></td></tr><tr><td align="center">MEMBERSHIPS_DELETED</td><td align="left">所有成员被从一个组中删除。在成员删除之前触发这个事件，所以他们都是可以访问的。 因为性能方面的考虑，不会为每个成员触发单独的<code>MEMBERSHIP_DELETED</code>事件。</td><td align="center"><code>org.activiti...ActivitiMembershipEvent</code></td></tr></tbody></table><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><p>业务流程是软件项目的一部分，它也应该和普通的业务流程一样进行测试： 使用单元测试。 因为Activiti是一个嵌入式的java引擎， 为业务流程编写单元测试和写普通单元测试完全一样。</p><p>Activiti支持JUnit 3和4进行单元测试。使用JUnit 3时， 必须集成<code>org.activiti.engine.test.ActivitiTestCase</code>。 它通过保护的成员变量提供ProcessEngine和服务， 在测试的<code>setup()</code>中， 默认会使用classpath下的<code>activiti.cfg.xml</code>初始化流程引擎。 想使用不同的配置文件，可以重写<em>getConfigurationResource()</em>方法。 如果配置文件相同的话，对应的流程引擎会被静态缓存， 就可以用于多个单元测试。</p><p>继承了<code>ActivitiTestCase</code>你，可以在测试方法上使用 <code>org.activiti.engine.test.Deployment</code>注解。 测试执行前，与测试类在同一个包下的， 格式为<code>testClassName.testMethod.bpmn20.xml</code>的资源文件，会被部署。 测试结束后，发布包也会被删除，包括所有相关的流程实例，任务，等等。 <code>Deployment</code>注解也可以直接设置资源的位置。 参考<a href="http://www.mossle.com/docs/javadocs/org/activiti/engine/test/Deployment.html" target="_blank" rel="noopener">Javadocs</a>获得更多信息。</p><p>把这些放在一起，JUnit 3测试看起来像这样。</p><pre><code>public class MyBusinessProcessTest extends ActivitiTestCase {  @Deployment  public void testSimpleProcess() {    runtimeService.startProcessInstanceByKey(&quot;simpleProcess&quot;);    Task task = taskService.createTaskQuery().singleResult();    assertEquals(&quot;My Task&quot;, task.getName());    taskService.complete(task.getId());    assertEquals(0, runtimeService.createProcessInstanceQuery().count());  }}</code></pre><p>要想在使用JUnit 4编写单元测试时获得同样的功能， 可以使用<code>org.activiti.engine.test.ActivitiRule</code>。 通过它，可以通过getter方法获得流程引擎和各种服务。 和 <code>ActivitiTestCase</code>一样（参考上面章节），使用这个<code>Rule</code> 也会启用<code>org.activiti.engine.test.Deployment</code>注解（参考上面章节使用和配置的介绍）， 它会在classpath下查找默认的配置文件。 如果配置文件相同的话，对应的流程引擎会被静态缓存， 就可以用于多个单元测试。</p><p>下面的代码演示了JUnit 4单元测试并使用了<code>ActivitiRule</code>的例子。</p><pre><code>public class MyBusinessProcessTest {  @Rule  public ActivitiRule activitiRule = new ActivitiRule();  @Test  @Deployment  public void ruleUsageExample() {    RuntimeService runtimeService = activitiRule.getRuntimeService();    runtimeService.startProcessInstanceByKey(&quot;ruleUsage&quot;);    TaskService taskService = activitiRule.getTaskService();    Task task = taskService.createTaskQuery().singleResult();    assertEquals(&quot;My Task&quot;, task.getName());    taskService.complete(task.getId());    assertEquals(0, runtimeService.createProcessInstanceQuery().count());  }}</code></pre><p>当集成Spring时，使用标准的<a href="http://www.mossle.com/docs/activiti/index.html#apiUnitTesting" target="_blank" rel="noopener">Activiti测试工具类</a>是非常容易的对业务流程进行测试。 下面的例子展示了如何在一个典型的基于Spring单元测试测试业务流程：</p><pre><code>@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(&quot;classpath:org/activiti/spring/test/junit4/springTypicalUsageTest-context.xml&quot;)public class MyBusinessProcessTest {  @Autowired  private RuntimeService runtimeService;  @Autowired  private TaskService taskService;  @Autowired  @Rule  public ActivitiRule activitiSpringRule;  @Test  @Deployment  public void simpleProcessTest() {    runtimeService.startProcessInstanceByKey(&quot;simpleProcess&quot;);    Task task = taskService.createTaskQuery().singleResult();    assertEquals(&quot;My Task&quot;, task.getName());    taskService.complete(task.getId());    assertEquals(0, runtimeService.createProcessInstanceQuery().count());  }}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> activiti </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>activiti数据库的分类</title>
      <link href="/2197510555.html"/>
      <url>/2197510555.html</url>
      
        <content type="html"><![CDATA[<p>Activiti数据库表结构</p><p> Activiti工作流总共包含23张数据表，所有的表名默认以“<strong>ACT_</strong>”开头。</p><p>并且表名的第二部分用两个字母表明表的用例，而这个用例也基本上跟Service API匹配。</p><p>u <strong>ACT_GE_*</strong> : “GE”代表“General”（通用），用在各种情况下；</p><p>u <strong>ACT_HI_*</strong> : “HI”代表“History”（历史），这些表中保存的都是历史数据，比如执行过的流程实例、变量、任务，等等。Activit默认提供了4种历史级别：</p><p>Ø <strong>none</strong>: 不保存任何历史记录，可以提高系统性能；</p><p>Ø <strong>activity</strong>：保存所有的流程实例、任务、活动信息；</p><p>Ø <strong>audit</strong>：也是Activiti的<strong>默认</strong>级别，保存所有的流程实例、任务、活动、表单属性；</p><p>Ø <strong>full</strong>：最完整的历史记录，除了包含<strong>audit</strong>级别的信息之外还能保存详细，例如：流程变量。</p><p>对于几种级别根据对功能的要求选择，如果需要日后跟踪详细可以开启<strong>full</strong>。</p><p>u <strong>ACT_ID_*</strong> : “ID”代表“Identity”（身份），这些表中保存的都是身份信息，如用户和组以及两者之间的关系。如果Activiti被集成在某一系统当中的话，这些表可以不用，可以直接使用现有系统中的用户或组信息；</p><p>u <strong>ACT_RE_*</strong> : “RE”代表“Repository”（仓库），这些表中保存一些‘静态’信息，如流程定义和流程资源（如图片、规则等）；</p><p>u <strong>ACT_RU_*</strong> : “RU”代表“Runtime”（运行时），这些表中保存一些流程实例、用户任务、变量等的运行时数据。Activiti只保存流程实例在执行过程中的运行时数据，并且当流程结束后会立即移除这些数据，这是为了保证运行时表尽量的小并运行的足够快；</p><h3 id="Activiti数据表清单"><a href="#Activiti数据表清单" class="headerlink" title="Activiti数据表清单:"></a>Activiti数据表清单:</h3><table><thead><tr><th align="center"><strong>表分类</strong></th><th align="center"><strong>表名</strong></th><th align="center"><strong>解释</strong></th></tr></thead><tbody><tr><td align="center">一般数据</td><td align="center">ACT_GE_BYTEARRAY</td><td align="center">通用的流程定义和流程资源</td></tr><tr><td align="center">ACT_GE_PROPERTY</td><td align="center">系统相关属性</td><td align="center"></td></tr><tr><td align="center">流程历史记录</td><td align="center">ACT_HI_ACTINST</td><td align="center">历史的流程实例</td></tr><tr><td align="center">ACT_HI_ATTACHMENT</td><td align="center">历史的流程附件</td><td align="center"></td></tr><tr><td align="center">ACT_HI_COMMENT</td><td align="center">历史的说明性信息</td><td align="center"></td></tr><tr><td align="center">ACT_HI_DETAIL</td><td align="center">历史的流程运行中的细节信息</td><td align="center"></td></tr><tr><td align="center">ACT_HI_IDENTITYLINK</td><td align="center">历史的流程运行过程中用户关系</td><td align="center"></td></tr><tr><td align="center">ACT_HI_PROCINST</td><td align="center">历史的流程实例</td><td align="center"></td></tr><tr><td align="center">ACT_HI_TASKINST</td><td align="center">历史的任务实例</td><td align="center"></td></tr><tr><td align="center">ACT_HI_VARINST</td><td align="center">历史的流程运行中的变量信息</td><td align="center"></td></tr><tr><td align="center">用户用户组表</td><td align="center">ACT_ID_GROUP</td><td align="center">身份信息-组信息</td></tr><tr><td align="center">ACT_ID_INFO</td><td align="center">身份信息-组信息</td><td align="center"></td></tr><tr><td align="center">ACT_ID_MEMBERSHIP</td><td align="center">身份信息-用户和组关系的中间表</td><td align="center"></td></tr><tr><td align="center">ACT_ID_USER</td><td align="center">身份信息-用户信息</td><td align="center"></td></tr><tr><td align="center">流程定义表</td><td align="center">ACT_RE_DEPLOYMENT</td><td align="center">部署单元信息</td></tr><tr><td align="center">ACT_RE_MODEL</td><td align="center">模型信息</td><td align="center"></td></tr><tr><td align="center">ACT_RE_PROCDEF</td><td align="center">已部署的流程定义</td><td align="center"></td></tr><tr><td align="center">运行实例表</td><td align="center">ACT_RU_EVENT_SUBSCR</td><td align="center">运行时事件</td></tr><tr><td align="center">ACT_RU_EXECUTION</td><td align="center">运行时流程执行实例</td><td align="center"></td></tr><tr><td align="center">ACT_RU_IDENTITYLINK</td><td align="center">运行时用户关系信息</td><td align="center"></td></tr><tr><td align="center">ACT_RU_JOB</td><td align="center">运行时作业</td><td align="center"></td></tr><tr><td align="center">ACT_RU_TASK</td><td align="center">运行时任务</td><td align="center"></td></tr><tr><td align="center">ACT_RU_VARIABLE</td><td align="center">运行时变量表</td><td align="center"></td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> activiti </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚拟机内部连vpn</title>
      <link href="/571302738.html"/>
      <url>/571302738.html</url>
      
        <content type="html"><![CDATA[<p> 最近由于众所周知的原因,目前只能在家里远程办公,由于目前主力系统是Ubuntu,使用vmware horizon client 连接公司Windows虚拟主机会闪退,地址 : <strong>/tmp/vmware-USERNAME/vmware-horizon-client-xxxx.log</strong>,网上搜了一下看不到解决方案,那就只有退而求其次在虚拟机上连接.</p><p> 使用虚拟机一直创建vpn一直报619错误,我之前本地主机连接是没问题的,现在连不上以为我用的win7系统的某些服务是不是没开启,看了一下都开启</p><p><a href="../img/windows_services_list.png"><img src="../img/windows_services_list.png" alt="1580780841225"></a> 后面是我本地主机连上vpn,然后虚拟主机使用这个连接vmware horizon client,同时我发现可能是我VMware workspace软件配置的网卡有问题,所以将网卡由NAT转为桥接</p><p><a href="../img/1580781244753.png"><img src="../img/1580781244753.png" alt="1580781244753"></a></p><p><a href="https://blog.csdn.net/yang5726685/article/details/78566213" target="_blank" rel="noopener">参考链接</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
            <tag> vpn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>maven 从pom.xml 下载jar包</title>
      <link href="/1868978831.html"/>
      <url>/1868978831.html</url>
      
        <content type="html"><![CDATA[<p> 之前一直用IntelliJ IDEA 的直接下载jar包,但是这次一直下载不下来指定版本jar包,看本地的代码库localRepository本地没有,看本地部署的maven中心,所以使用了<a href="https://blog.csdn.net/u011561335/article/details/80322960" target="_blank" rel="noopener">参考地址</a></p><ol><li>创建pom.xml 文件</li></ol><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;     &lt;groupId&gt;Spider&lt;/groupId&gt;    &lt;artifactId&gt;Spider&lt;/artifactId&gt;    &lt;version&gt;1.0&lt;/version&gt;     &lt;dependencies&gt;        &lt;!-- https://mvnrepository.com/artifact/junit/junit --&gt;        &lt;dependency&gt;            &lt;groupId&gt;junit&lt;/groupId&gt;            &lt;artifactId&gt;junit&lt;/artifactId&gt;            &lt;version&gt;4.12&lt;/version&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;     &lt;/dependencies&gt;&lt;/project&gt;</code></pre><ol><li>使用mvn命令 下载后在本地仓库看到, 然后在IntelliJ IDEA刷新</li></ol><pre><code>mvn dependency:copy-dependencies</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ZUUL转发后导致文件乱码</title>
      <link href="/230759535.html"/>
      <url>/230759535.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/Netflix/zuul/wiki/How-it-Works" target="_blank" rel="noopener">spring zuul how it works</a></p><p><a href="https://blog.wangqi.love/articles/Spring-Cloud/Zuul探究(二)%E2%80%94%E2%80%94Zuul%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.html" target="_blank" rel="noopener">Zuul探究(二——Zuul的工作原理</a></p><p><a href="https://www.okcode.net/article/37549" target="_blank" rel="noopener">ZuulServlet的执行流程分析</a></p><p><a href="https://taccisum.github.io/source/zuul/architecture.html" target="_blank" rel="noopener">zuul源码解析 —— zuul整体架构</a></p><p><a href="https://juejin.im/post/5c2db228e51d451be35e74da" target="_blank" rel="noopener">Spring Cloud Netflix Zuul源码分析之请求处理篇-上</a></p><p>dispatcherservlet -&gt; doDispatch( -&gt; getHandler(HandlerExecutionChain) {</p><p>该过程会通过getHandlerInternal方法根据 lookupPath(请求路径)、request(请求)调用ZuulHandlerMapping.lookupHandler方法查找匹配的handler。如果没有</p><p>} ) -&gt;doService</p><p>SimpleControllerHandlerAdapter.handle</p><p>zuulcontroller .handleRequest</p><p>ZuulServlet.service{<br>//Zuul的主要流程发生在ZuulServlet中，它的调用流程如下：</p><p>DispatcherServlet.doService<br>DispatcherServlet.doDispatch<br>SimpleControllerHandlerAdapter.handle<br>ZuulController.handleRequest<br>ServletWrappingController.handleRequestInternal<br>ZuulServlet.service</p><pre><code>RibbonRoutingFilterpublic Object run() {        RequestContext context = RequestContext.getCurrentContext();        this.helper.addIgnoredHeaders();        try {            RibbonCommandContext commandContext = buildCommandContext(context);            ClientHttpResponse response = forward(commandContext);            setResponse(response);            return response;        }        catch (ZuulException ex) {            throw new ZuulRuntimeException(ex);        }        catch (Exception ex) {            throw new ZuulRuntimeException(ex);        }    }</code></pre><p>栈信息</p><pre><code>java.lang.Thread.State: RUNNABLE      at org.springframework.cloud.netflix.zuul.filters.route.RibbonRoutingFilter.getRequestBody(RibbonRoutingFilter.java:199)      at org.springframework.cloud.netflix.zuul.filters.route.RibbonRoutingFilter.buildCommandContext(RibbonRoutingFilter.java:126)      at org.springframework.cloud.netflix.zuul.filters.route.RibbonRoutingFilter.run(RibbonRoutingFilter.java:105)      at com.netflix.zuul.ZuulFilter.runFilter(ZuulFilter.java:112)      at com.netflix.zuul.FilterProcessor.processZuulFilter(FilterProcessor.java:193)      at com.netflix.zuul.FilterProcessor.runFilters(FilterProcessor.java:157)      at com.netflix.zuul.FilterProcessor.route(FilterProcessor.java:118)      at com.netflix.zuul.ZuulRunner.route(ZuulRunner.java:96)      at com.netflix.zuul.http.ZuulServlet.route(ZuulServlet.java:116)      at com.netflix.zuul.http.ZuulServlet.service(ZuulServlet.java:81)      at org.springframework.web.servlet.mvc.ServletWrappingController.handleRequestInternal(ServletWrappingController.java:157)      at org.springframework.cloud.netflix.zuul.web.ZuulController.handleRequest(ZuulController.java:44)      at org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter.handle(SimpleControllerHandlerAdapter.java:50)      at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:963)      at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:897)      at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:970)      at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:872)      at javax.servlet.http.HttpServlet.service(HttpServlet.java:648)      at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:846)      at javax.servlet.http.HttpServlet.service(HttpServlet.java:729)      at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:230)      at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:165)      at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52)      at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:192)      at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:165)      at org.springframework.boot.web.filter.ApplicationContextHeaderFilter.doFilterInternal(ApplicationContextHeaderFilter.java:55)      at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)      at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:192)      at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:165)      at org.springframework.boot.actuate.trace.WebRequestTraceFilter.doFilterInternal(WebRequestTraceFilter.java:108)      at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)      at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:192)      at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:165)      at cn.com.betasoft.dxm.sso.ext.client.filter.SessionValidationFilter.doFilter(SessionValidationFilter.java:98)      at cn.com.betasoft.btrm.portal.config.ExcludeSupportFilter.doFilter(ExcludeSupportFilter.java:21)      at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:192)      at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:165)      at org.jasig.cas.client.util.AssertionThreadLocalFilter.doFilter(AssertionThreadLocalFilter.java:54)      at cn.com.betasoft.btrm.portal.config.ExcludeSupportFilter.doFilter(ExcludeSupportFilter.java:21)      at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:192)      at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:165)      at org.jasig.cas.client.util.HttpServletRequestWrapperFilter.doFilter(HttpServletRequestWrapperFilter.java:75)      at cn.com.betasoft.btrm.portal.config.ExcludeSupportFilter.doFilter(ExcludeSupportFilter.java:21)      at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:192)      at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:165)      at org.jasig.cas.client.authentication.AuthenticationFilter.doFilter(AuthenticationFilter.java:107)      at cn.com.betasoft.btrm.portal.config.ExcludeSupportFilter.doFilter(ExcludeSupportFilter.java:21)      at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:192)      at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:165)      at org.jasig.cas.client.validation.AbstractTicketValidationFilter.doFilter(AbstractTicketValidationFilter.java:201)      at cn.com.betasoft.btrm.portal.config.ExcludeSupportFilter.doFilter(ExcludeSupportFilter.java:21)      at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:192)      at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:165)      at org.jasig.cas.client.session.SingleSignOutFilter.doFilter(SingleSignOutFilter.java:76)      at cn.com.betasoft.btrm.portal.config.ExcludeSupportFilter.doFilter(ExcludeSupportFilter.java:21)      at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:192)      at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:165)      at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:116)      at cn.com.betasoft.btrm.portal.config.ExcludeSupportFilter.doFilter(ExcludeSupportFilter.java:21)      at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:192)      at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:165)      at cn.com.betasoft.btrm.common.serviceconfig.ServiceAssertionConfig$1.doFilter(ServiceAssertionConfig.java:53)      at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:192)      at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:165)      at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:99)      at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)      at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:192)      at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:165)      at org.springframework.web.filter.HttpPutFormContentFilter.doFilterInternal(HttpPutFormContentFilter.java:105)      at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)      at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:192)      at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:165)      at org.springframework.web.filter.HiddenHttpMethodFilter.doFilterInternal(HiddenHttpMethodFilter.java:81)      at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)      at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:192)      at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:165)      at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:197)      at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)      at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:192)      at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:165)      at org.springframework.boot.actuate.autoconfigure.MetricsFilter.doFilterInternal(MetricsFilter.java:106)      at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)      at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:192)      at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:165)      at org.springframework.web.filter.CorsFilter.doFilterInternal(CorsFilter.java:96)      at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)      at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:192)      at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:165)      at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:198)      at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96)      at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:474)      at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:140)      at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:79)      at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:87)      at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:349)      at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:783)      at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:66)      at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:798)      at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1434)      at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)      - locked &lt;0x2a0d&gt; (a org.apache.tomcat.util.net.NioEndpoint$NioSocketWrapper)      at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)      at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)      at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)      at java.lang.Thread.run(Thread.java:748)</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot 读取外部文件</title>
      <link href="/1470057129.html"/>
      <url>/1470057129.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://stackoverflow.com/questions/51883955/how-to-specify-external-location-for-image-store-in-spring-boot-2-0-web-app" target="_blank" rel="noopener">external location for image store in Spring Boot 2.0 web app?</a></p><p>之前有个需求是需要有个urlpatren像 staticFiles/xxx.pdf 请求的url 对应服务器端的某个文件夹可以直接访问,</p><p>WebMvcConfigurer 需要实现或者继承WebMvcConfigurerAdapter</p><pre><code>@Configurationpublic class MvcConfig extends WebMvcConfigurerAdapter  {    @Override    public void addResourceHandlers(ResourceHandlerRegistry registry) {       registry               .addResourceHandler(&quot;/btrm/framework/item/static/**&quot;)               .addResourceLocations(&quot;file:D:\\SVNCODE\\btrm\\&quot;)               .setCachePeriod(200);        super.addResourceHandlers(registry);    }}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot 读取jar包文件</title>
      <link href="/3997187638.html"/>
      <url>/3997187638.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>申请教育邮箱和使用微软 OneDrive API 和腾讯云 SCF 免费搭建个人网盘</title>
      <link href="/18764620.html"/>
      <url>/18764620.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.4spaces.org/apply-edu-email/#comment-977" target="_blank" rel="noopener">参考注册地址</a> 注册的学校是(Red Rocks Community College官网)注册申请时需要用到</p><p><a href="https://www.moerats.com/archives/879/" target="_blank" rel="noopener">参考注册地址2</a> 国西南学院(<code>Southwestern College</code>)</p><p>为什么要申请教育邮箱优点如下</p><ul><li><p>$ 15 <strong>Amazon AWS</strong> 优惠券</p></li><li><p>50美元的 <strong>Digital Ocean</strong> 优惠券。它会在添加到您的帐户（仅限新帐户）后的12个月内过期。</p></li><li><p><strong>Bitnami</strong>：提供为期一年的Business 3计划，通常每月收费49美元。</p></li><li><p><strong>Crowdflower</strong>：访问Crowdflower平台。</p></li><li><p><strong>DNSimple</strong>：提供两年的个人托管DNS计划，通常每月收取5美元。</p></li><li><p><strong>GitHub</strong>：在您还是学生时提供无限的私人存储库。通常，GitHub每月收费7美元。</p></li><li><p>25美元的<strong>HackHands</strong>信用， <strong>这</strong>是一项实时的编程帮助，每天24/7可用。</p></li><li><p>一套 <strong>Microsoft Azure云服务</strong> 和开发人员工具：学生期间，Microsoft Azure，Visual Studio社区和其他Microsoft开发人员工具。</p></li><li><p><strong>NameCheap.com</strong>：提供为期一年的.ME域名注册，每年费用为18.99美元–以及为期一年的SSL证书，费用为每年10美元。</p></li><li><p><strong>Orchestrate</strong>：当您是学生时，访问每月费用为49美元的开发者帐户。它是一个完整的数据库产品组合，包括通过API进行的搜索，时间序列事件，地理位置和图形查询。</p></li><li><p><strong>SendGrid</strong>：当您是学生时，每月为学生计划提供15,000封免费电子邮件。</p></li><li><p><strong>Travis CI</strong>：当您是学生时，访问每月收费69美元的Private版本。</p></li><li><h3 id="LastPass"><a href="#LastPass" class="headerlink" title="LastPass"></a><strong>LastPass</strong></h3></li><li><p>Apple .EDU电子邮件地址从Apple购买产品，可以帮助您节省很多钱。</p></li></ul><h2 id="微软-OneDrive-API-和腾讯云-SCF-免费"><a href="#微软-OneDrive-API-和腾讯云-SCF-免费" class="headerlink" title="微软 OneDrive API 和腾讯云 SCF 免费"></a>微软 OneDrive API 和腾讯云 SCF 免费</h2><p>目前可以使用onedrive 5t 使用软件搭建自己网盘</p><p><a href="https://logi.ml/back-end/scf-onedrive-filelistor.html" target="_blank" rel="noopener">oneDrive搭建个人网盘</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> onedrive </tag>
            
            <tag> 腾讯云 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gnome插件安装和优化</title>
      <link href="/2127448358.html"/>
      <url>/2127448358.html</url>
      
        <content type="html"><![CDATA[<pre><code>sudo apt install -y sudo apt install gnome-tweak-tool sudo apt install gnome-shell-extensions sudo apt install chrome-gnome-shell sudo apt install gtk2-engines-pixbuf sudo apt install libxml2-utils</code></pre><p>之前一直都是安装在~/.local/share/gnome-shell/extensions 之前都是从github 下载后 手动安装</p><p>现在有些插件安装后 优化工具一直没有显示 ,之前 使用 ~/.local/share/gnome-shell/extensions</p><p>没有权限 sudo chmod 777 extensions 给予权限 不然无法使用chrome插件(GNOME Shell integration ) 来安装</p><p>现在chrome插件安装 (GNOME Shell integration)</p><ul><li><p>对于 Google Chrome、Chromium 和 Vivaldi： <a href="https://chrome.google.com/webstore/detail/gnome-shell-integration/gphhapmejobijbbhgpjhcjognlahblep" target="_blank" rel="noopener">Chrome Web 商店</a></p></li><li><p>对于 Firefox： <a href="https://addons.mozilla.org/en/firefox/addon/gnome-shell-integration/" target="_blank" rel="noopener">Mozilla Addons</a></p></li><li><p>对于 Opera： <a href="https://addons.opera.com/en/extensions/details/gnome-shell-integration/" target="_blank" rel="noopener">Opera Addons</a></p><p><a href="../img/105330tx3hptbrx55h5i1i.jpg"><img src="../img/105330tx3hptbrx55h5i1i.jpg" alt="How to install GNOME Shell Extensions"></a></p></li></ul><pre><code>“尽管 GNOME Shell 集成扩展正在运行，但未检测到本地主机连接器。请参阅文档以获取有关安装连接器的信息。”sudo apt install chrome-gnome-shell</code></pre><p>安装玩后访问 <a href="https://extensions.gnome.org/extension" target="_blank" rel="noopener">https://extensions.gnome.org/extension</a> 就会有选择按钮了</p><p><a href="../img/1569134580875.png"><img src="../img/1569134580875.png" alt="1569134580875"></a></p><h3 id="农历插件"><a href="#农历插件" class="headerlink" title="农历插件"></a>农历插件</h3><pre><code>sudo apt-get update安装依赖sudo apt-get install gir1.2-lunar-date-2.0</code></pre><p><a href="../img/1569134876250.png"><img src="../img/1569134876250.png" alt="1569134876250"></a></p><h2 id="拓展的列表和"><a href="#拓展的列表和" class="headerlink" title="拓展的列表和"></a>拓展的列表和</h2><p><a href="../img/28027856634_5a328b1376_b.jpg"><img src="../img/28027856634_5a328b1376_b.jpg" alt="img"></a></p><h3 id="2-1-安装-Dash-to-dock"><a href="#2-1-安装-Dash-to-dock" class="headerlink" title="2.1 安装 Dash to dock ."></a>2.1 安装 Dash to dock .</h3><ul><li><strong>Hide top bar ——全屏自动隐藏顶栏,缺少这个 GNOME3 没法用</strong></li><li><strong>Clipboard Indicator —— 剪切板</strong></li><li><strong>Media player indicator —— 显示音乐播放器的状态</strong></li><li><strong>Battery status —— 显示电池电量的百分比</strong></li><li><strong>Netspeed ——在顶栏上显示网速</strong></li><li><strong>Workspace indicator —— 在顶栏显示当前示工作区的序号</strong></li><li><strong>Activities-configurator ——活动，顶栏颜色，透明等</strong></li><li><strong>User themes ——启用自定义的 shell 主题</strong></li><li><strong>Lunar Calendar ——阴历(依赖 typelib-1_0-LunarDate-2_0)</strong></li><li><strong>Openweather ——天气</strong></li><li><strong>System-monitor ——资源监控 (依赖 NetworkManager-devel libgtop-devel)</strong></li><li>topicon plus —— 通知图标</li></ul><h3 id="2-2通知栏的效果"><a href="#2-2通知栏的效果" class="headerlink" title="2.2通知栏的效果"></a>2.2通知栏的效果</h3><p>[<img src="../img/2019-09-22%2014-48-58%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt="1569135029991">](../img/2019-09-22 14-48-58 的屏幕截图.png)</p><h2 id="3-字体"><a href="#3-字体" class="headerlink" title="3 字体"></a>3 字体</h2><pre><code>单独放在一个文件夹里(fonts),然后sudo cp -r 连着文件夹复制到/usr/share/fonts,(sudo cp -r xxx/fonts /usr/share/fonts (xxx请换为路径))再 chmod 755 -R /usr/share/fonts/fonts , 最后依次执行:sudo mkfontscalesudo mkfontdirsudo fc-cache</code></pre><ul><li><a href="https://biluohc.github.io/articles/xie-gei-ru-keng-da-xi-yi-qie-xuan-ze-gnomede-xiao-bai.html" target="_blank" rel="noopener">[写给入坑大蜥蜴且选择GNOME的小白]</a>)</li><li><a href="https://www.peijun.me/gnome-config.html" target="_blank" rel="noopener">Gnome 配置</a></li><li><a href="https://linux.cn/article-9447-1.html" target="_blank" rel="noopener">如何使用 GNOME Shell 扩展</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
            <tag> gnome </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用lastpass同步密码</title>
      <link href="/2031496132.html"/>
      <url>/2031496132.html</url>
      
        <content type="html"><![CDATA[<ul><li><pre><code>Windows 总结了下网上的答案：1.地址栏输入 chrome://policy/ 查看是哪个 policy2.删除注册表\HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Google\Chrome 下对应的文件夹3.进入 chrome://policy/，点击重新加载策略4.重启</code></pre></li><li><pre><code>Linux 的话只要把 /etc/opt/chrome/policies 文件夹删掉就行了</code></pre></li></ul><p><a href="https://www.v2ex.com/t/552567#;" target="_blank" rel="noopener">参考链接</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
            <tag> lastpass </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu下安装和初始化postgres</title>
      <link href="/18764621.html"/>
      <url>/18764621.html</url>
      
        <content type="html"><![CDATA[<h3 id="安装postgres"><a href="#安装postgres" class="headerlink" title="安装postgres"></a>安装postgres</h3><pre><code>sudo apt-get  updatesudp apt-get postgresql postgresql-contrib</code></pre><ul><li>PostgreSQL安装完成后默认是已经启动的，但是也可以通过下面的方式来手动启动服务</li></ul><pre><code>  sudo /etc/init.d/postgresql start  开启sudo /etc/init.d/postgresql stop  关闭sudo /etc/init.d/postgresql restart  重启</code></pre><h2 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h2><ul><li>创建数据库用户ricky，并指定为超级用户</li></ul><pre><code>sudo -u postgres createuser --superuser username</code></pre><ul><li>配置用户的密码</li></ul><pre><code>sudo -u postgres psql  进入控制台</code></pre><ul><li><p>为刚创建的用户创建数据库</p><pre><code>sudo -u postgres createdb --owner=dbname</code></pre></li><li><p>登录数据库</p></li></ul><pre><code>psql -U username -d dbname -h 127.0.0.1 -p 5432</code></pre><h3 id="修改用户数据"><a href="#修改用户数据" class="headerlink" title="修改用户数据"></a>修改用户数据</h3><pre><code>    修改用户密码    1.  sudo -u postgres psql    2.  ALTER USER username  WITH PASSWORD ``&#39;postgres&#39;``;tips:        密码postgres要用引号引起来        命令最后有分号</code></pre><h3 id="修改linux系统postgres用户的密码"><a href="#修改linux系统postgres用户的密码" class="headerlink" title="修改linux系统postgres用户的密码"></a>修改linux系统postgres用户的密码</h3><p>PostgreSQL会创建一个默认的linux用户postgres，修改该用户密码的方法如下：</p><p>步骤一：删除用户postgres的密码</p><pre><code>`sudo`  `passwd` `-d postgres`</code></pre><p>步骤二：设置用户postgres的密码</p><pre><code>`sudo` `-u postgres ``passwd`</code></pre><p>系统提示输入新的密码</p><pre><code>`Enter new UNIX password:``Retype new UNIX password:``passwd``: password updated successfully`</code></pre><ul><li><a href="https://www.cnblogs.com/kaituorensheng/p/4735191.html" target="_blank" rel="noopener">参考文档</a></li><li><a href="https://www.howtoing.com/how-to-install-and-use-postgresql-on-ubuntu-18-04" target="_blank" rel="noopener">参考文档</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
            <tag> postgres </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>aria2使用rpc下载百度云</title>
      <link href="/3861112470.html"/>
      <url>/3861112470.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-下载并安装"><a href="#1-下载并安装" class="headerlink" title="1.下载并安装"></a>1.下载并安装</h3><p>github地址-&gt;<a href="https://github.com/aria2/aria2" target="_blank" rel="noopener">https://github.com/aria2/aria2</a></p><p>这边提供一下deb 包的下载地址 <a href="https://ugetdm.com/go/ubuntu-64-bionic-aria2-download" target="_blank" rel="noopener">https://ugetdm.com/go/ubuntu-64-bionic-aria2-download</a></p><p>或者 sudo apt-get install aria2</p><p>可以尝试在命令行 使用</p><pre><code>aria2c  --conf-path=&lt;配置地址&gt; -D        # aria2c -c -s 5 http://example.org/mylinux.iso        -c : 断点续传        -s : 使用线程数        2、Download from 2 sources        # aria2c http://a/f.iso   ftp://b/f.iso</code></pre><p>下载相关的命令</p><pre><code>1、Download from WEB# aria2c -c -s 5 http://example.org/mylinux.iso-c : 断点续传-s : 使用线程数2、Download from 2 sources# aria2c http://a/f.iso   ftp://b/f.iso3、Download using 2 connections per host# aria2c -x2 http://a/f.iso4、BitTorrent Magnet URI# aria2c &#39;magnet:?xt=urn:btih:248D0A1CD08284299DE78D5C1ED359BB46717D8C&#39;5、Metalink# aria2c http://example.org/mylinux.metalink6、Download URIs found in text file# aria2c -i uris.txt7、BT# aria2c /tmp/CentOS-6.3-i386-bin-DVD1to2.torrent# aria2c http://mirrors.163.com/centos/6.6/isos/x86_64/CentOS-6.6-x86_64-minimal.torrent</code></pre><h2 id="2-配置Aria2"><a href="#2-配置Aria2" class="headerlink" title="2.配置Aria2"></a>2.配置Aria2</h2><p>一般地址是在 ~/.aria2/aria2.conf</p><p>rpc设置为true</p><pre><code>#用户名#rpc-user=user#密码#rpc-passwd=passwd#上面的认证方式不建议使用,建议使用下面的token方式#设置加密的密钥#rpc-secret=token#允许rpcenable-rpc=true#允许所有来源, web界面跨域权限需要rpc-allow-origin-all=true#允许外部访问，false的话只监听本地端口rpc-listen-all=true#RPC端口, 仅当默认端口被占用时修改#rpc-listen-port=6800#最大同时下载数(任务数), 路由建议值: 3max-concurrent-downloads=5#断点续传continue=true#同服务器连接数max-connection-per-server=5#最小文件分片大小, 下载线程数上限取决于能分出多少片, 对于小文件重要min-split-size=10M#单文件最大线程数, 路由建议值: 5split=10#下载速度限制max-overall-download-limit=0#单文件速度限制max-download-limit=0#上传速度限制max-overall-upload-limit=0#单文件速度限制max-upload-limit=0#断开速度过慢的连接#lowest-speed-limit=0#验证用，需要1.16.1之后的release版本#referer=*#文件保存路径, 默认为当前启动位置dir=/home/leek/save/download#文件缓存, 使用内置的文件缓存, 如果你不相信Linux内核文件缓存和磁盘内置缓存时使用, 需要1.16及以上版本#disk-cache=0#另一种Linux文件缓存方式, 使用前确保您使用的内核支持此选项, 需要1.15及以上版本(?)#enable-mmap=true#文件预分配, 能有效降低文件碎片, 提高磁盘性能. 缺点是预分配时间较长#所需时间 none &lt; falloc ? trunc « prealloc, falloc和trunc需要文件系统和内核支持file-allocation=prealloc</code></pre><h2 id="3-rpc调用-下载百度云"><a href="#3-rpc调用-下载百度云" class="headerlink" title="3.rpc调用 下载百度云"></a>3.rpc调用 下载百度云</h2><p>测试 rpc可用性</p><p><a href="http://127.0.0.1:6800/jsonrpc?jsoncallback=1" target="_blank" rel="noopener">http://127.0.0.1:6800/jsonrpc?jsoncallback=1</a></p><p>有返回既能用否则可能是服务没有起起来</p><p>使用的chrome 油猴插件 百度网盘超级助手选择pandownload -&gt; 调用baiduwp.com 的下载接口直接下载 -&gt; 点击具体文件后选择使用Aria2下载</p><p><a href="../img/1567683581804.png"><img src="../img/1567683581804.png" alt="1567683581804"></a></p><p>参考链接</p><ul><li><a href="http://ivo-wang.github.io/2019/04/18/关于aria2最完整的一篇/" target="_blank" rel="noopener">关于aria2最完整的一篇</a></li><li><a href="https://binux.blog/2012/12/aria2-examples/" target="_blank" rel="noopener">https://binux.blog/2012/12/aria2-examples/</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>floccus利用坚果云WebDAV跨浏览器同步数据</title>
      <link href="/4202359184.html"/>
      <url>/4202359184.html</url>
      
        <content type="html"><![CDATA[<h3 id="floccus介绍"><a href="#floccus介绍" class="headerlink" title="floccus介绍"></a>floccus介绍</h3><pre><code>Floccus 是一款可以通过 Nextcloud，WebDAV 或本地文件（以及任何文件同步解决方案）跨浏览器同步书签的插件，支持 Chrome、Firefox、Kiwi 等浏览器（不支持 iOS）项目地址: https://github.com/marcelklehr/floccusWebDAV ：目前支持 「坚果云、nextcloud / owncloud，box」 等 WebDAV 服务器Nextcloud 书签 ：利用 Nextcloud 自带的书签应用程序进行同步，可通过 Web 访问。(需要nextcloud v12 以上版本)。本地文件同步 ：利用 LoFloccus 4 软件将书签同步到本地, 再利用 Dropbox，Syncthing，rsync 等进行跨设备同步。</code></pre><h3 id="配置坚果云"><a href="#配置坚果云" class="headerlink" title="配置坚果云"></a>配置坚果云</h3><p><a href="../img/1567081469042.png"><img src="../img/1567081469042.png" alt="1567081469042"></a></p><p>尽量和<strong>和我的坚果云文件夹</strong>同级为了后面填写书签同步路径,然后上传一个bookmarks.xbel文件到刚才新建的文件夹里面，没有的<a href="https://upyuncc.naibabiji.com/wp-content/uploads/2019/05/bookmarks.zip" target="_blank" rel="noopener">点这里下载</a>。</p><p>接着坚果云“账户信息”-“安全选项”-“第三方应用管理”，创建一个WebDAV应用，获取密码</p><p><a href="../img/1567080871435.png"><img src="../img/1567080871435.png" alt="1567080871435"></a></p><pre><code>### 安装Firefox chrome 插件</code></pre><p><a href="https://chrome.google.com/webstore/detail/floccus/fnaicdffflnofjppbagibeoednhnbjhg" target="_blank" rel="noopener">Chrome扩展地址</a>（<a href="https://crx.yougaoji.com/crx_download/151" target="_blank" rel="noopener">离线地址</a>）、<a href="https://addons.mozilla.org/en-US/firefox/addon/floccus/" target="_blank" rel="noopener">Firefox扩展地址</a></p><p><a href="../img/1567080794015.png"><img src="../img/1567080794015.png" alt="1567080794015"></a></p><p><a href="../img/1567080971630.png"><img src="../img/1567080971630.png" alt="1567080971630"></a></p><h3 id="最后一个注意的"><a href="#最后一个注意的" class="headerlink" title="最后一个注意的"></a>最后一个注意的</h3><p><a href="../img/1567081020328.png"><img src="../img/1567081020328.png" alt="1567081020328"></a></p><p>不然只能同步一部分的</p><p><a href="javascript:;"></a></p>]]></content>
      
      
      
        <tags>
            
            <tag> webdav </tag>
            
            <tag> 坚果云 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POST与PUT区别RESTFUL风格中</title>
      <link href="/4265857413.html"/>
      <url>/4265857413.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-HTTP协议详解"><a href="#1-HTTP协议详解" class="headerlink" title="1 HTTP协议详解"></a><strong>1 HTTP协议详解</strong></h3><p>转载地址 <strong><a href="http://blog.yikaiba.com/Home/Article/index/id/156.html" target="_blank" rel="noopener">http://blog.yikaiba.com/Home/Article/index/id/156.html</a></strong></p><p>HTTP是HyperText Transfer Protocol（超文本传输协议）的缩写。它的发展是万维网协会（WorldWide Web Consortium）和Internet工作小组IETF（Internet Engineering Task Force）合作的结果，（他们）最终发布了一系列的RFC，RFC 1945定义了HTTP/1.0版本。其中最著名的就是RFC 2616。RFC 2616定义了今天普遍使用的一个版本——HTTP 1.1。</p><p>HTTP协议（HyperText Transfer Protocol，超文本传输协议）是用于从WWW服务器传输超文本到本地浏览器的传送协议。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。</p><p>HTTP协议通常承载于TCP协议之上，有时也承载于TLS或SSL协议层之上，这个时候，就成了我们常说的HTTPS。如下图所示：</p><p><a href="../img/8732AF49534540D8AFCD804A4335A2D2.png"><img src="../img/8732AF49534540D8AFCD804A4335A2D2.png" alt="img"></a></p><p>默认HTTP的端口号为80，HTTPS的端口号为443。</p><p>HTTP协议永远都是客户端发起请求，服务器回送响应。见下图：</p><p><a href="../img/65E389D17A3F4C6AA8A5B6F542DB58AA.png"><img src="../img/65E389D17A3F4C6AA8A5B6F542DB58AA.png" alt="img"></a></p><p>这样就限制了使用HTTP协议，无法实现在客户端没有发起请求的时候，服务器将消息推送给客户端。</p><p>HTTP协议是一个无状态的协议，同一个客户端的这次请求和上次请求是没有对应关系。</p><p><strong>一次HTTP操作称为一个事务，其工作过程可分为四步：</strong></p><p>1）首先客户机与服务器需要建立连接。只要单击某个超级链接，HTTP的工作开始。</p><p>2）建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是MIME信息包括请求修饰符、客户机信息和可能的内容。</p><p>3）服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是MIME信息包括服务器信息、实体信息和可能的内容。</p><p>4）客户端接收服务器所返回的信息通过浏览器显示在用户的显示屏上，然后客户机与服务器断开连接。</p><p>如果在以上过程中的某一步出现错误，那么产生错误的信息将返回到客户端，有显示屏输出。对于用户来说，这些过程是由HTTP自己完成的，用户只要用鼠标点击，等待信息显示就可以了。</p><p><strong>2 HTTP协议详解之请求篇</strong></p><p>http请求由三部分组成，分别是：请求行、消息报头、请求正文</p><p>请求行以一个方法符号开头，以空格分开，后面跟着请求的URI和协议的版本，格式如下：Method Request-URIHTTP-Version CRLF</p><p>其中 Method表示请求方法；Request-URI是一个统一资源标识符；HTTP-Version表示请求的HTTP协议版本；CRLF表示回车和换行（除了作为结尾的CRLF外，不允许出现单独的CR或LF字符）。</p><p><strong>请求方法（所有方法全为大写）有多种，各个方法的解释如下：</strong></p><p>GET 请求获取Request-URI所标识的资源</p><p>POST 在Request-URI所标识的资源后附加新的数据</p><p>HEAD 请求获取由Request-URI所标识的资源的响应消息报头</p><p>PUT 请求服务器存储一个资源，并用Request-URI作为其标识</p><p>DELETE 请求服务器删除Request-URI所标识的资源</p><p>TRACE 请求服务器回送收到的请求信息，主要用于测试或诊断</p><p>CONNECT 保留将来使用</p><p>OPTIONS 请求查询服务器的性能，或者查询与资源相关的选项和需求</p><p>应用举例：</p><p>GET方法：在浏览器的地址栏中输入网址的方式访问网页时，浏览器采用GET方法向服务器获取资源，eg:GET /form.html HTTP/1.1 (CRLF)</p><p>POST方法要求被请求服务器接受附在请求后面的数据，常用于提交表单。</p><p>HEAD方法与GET方法几乎是一样的，对于HEAD请求的回应部分来说，它的HTTP头部中包含的信息与通过GET请求所得到的信息是相同的。利用这个方法，不必传输整个资源内容，就可以得到Request-URI所标识的资源的信息。该方法常用于测试超链接的有效性，是否可以访问，以及最近是否更新。</p><p><strong>3 HTTP协议详解之响应篇</strong></p><p>在接收和解释请求消息后，服务器返回一个HTTP响应消息。</p><p>HTTP响应也是由三个部分组成，分别是：状态行、消息报头、响应正文</p><p><strong>1、状态行格式如下：</strong></p><p>HTTP-VersionStatus-Code Reason-Phrase CRLF</p><p>其中，HTTP-Version表示服务器HTTP协议的版本；Status-Code表示服务器发回的响应状态代码；Reason-Phrase表示状态代码的文本描述。</p><p>状态代码有三位数字组成，第一个数字定义了响应的类别，且有五种可能取值：</p><p>1xx：指示信息–表示请求已接收，继续处理</p><p>2xx：成功–表示请求已被成功接收、理解、接受</p><p>3xx：重定向–要完成请求必须进行更进一步的操作</p><p>4xx：客户端错误–请求有语法错误或请求无法实现</p><p>5xx：服务器端错误–服务器未能实现合法的请求</p><p><strong>2、常见状态代码、状态描述、说明：</strong></p><p><strong>请求收到，继续处理</strong></p><p>100——客户必须继续发出请求</p><p>101——客户要求服务器根据请求转换HTTP协议版本</p><p><strong>操作成功收到，分析、接受</strong></p><p>200——交易成功</p><p>201——提示知道新文件的URL</p><p>202——接受和处理、但处理未完成</p><p>203——返回信息不确定或不完整</p><p>204——请求收到，但返回信息为空</p><p>205——服务器完成了请求，用户代理必须复位当前已经浏览过的文件</p><p>206——服务器已经完成了部分用户的GET请求</p><p><strong>完成此请求必须进一步处理</strong></p><p>300——请求的资源可在多处得到</p><p>301——删除请求数据</p><p>302——在其他地址发现了请求数据</p><p>303——建议客户访问其他URL或访问方式</p><p>304——客户端已经执行了GET，但文件未变化</p><p>305——请求的资源必须从服务器指定的地址得到</p><p>306——前一版本HTTP中使用的代码，现行版本中不再使用</p><p>307——申明请求的资源临时性删除</p><p><strong>请求包含一个错误语法或不能完成</strong></p><p>400——错误请求，如语法错误</p><p>401——未授权</p><p>HTTP 401.1 - 未授权：登录失败</p><p>　　 HTTP 401.2 - 未授权：服务器配置问题导致登录失败</p><p>　　 HTTP 401.3 - ACL 禁止访问资源</p><p>　　 HTTP 401.4 - 未授权：授权被筛选器拒绝</p><p>HTTP 401.5 - 未授权：ISAPI 或 CGI 授权失败</p><p>402——保留有效ChargeTo头响应</p><p>403——禁止访问</p><p>HTTP 403.1 禁止访问：禁止可执行访问</p><p>　　 HTTP 403.2 - 禁止访问：禁止读访问</p><p>　　 HTTP 403.3 - 禁止访问：禁止写访问</p><p>　　 HTTP 403.4 - 禁止访问：要求 SSL</p><p>　　 HTTP 403.5 - 禁止访问：要求 SSL128</p><p>　　 HTTP 403.6 - 禁止访问：IP 地址被拒绝</p><p>　　 HTTP 403.7 - 禁止访问：要求客户证书</p><p>　　 HTTP 403.8 - 禁止访问：禁止站点访问</p><p>　　 HTTP 403.9 - 禁止访问：连接的用户过多</p><p>　　 HTTP 403.10 - 禁止访问：配置无效</p><p>　　 HTTP 403.11 - 禁止访问：密码更改</p><p>　　 HTTP 403.12 - 禁止访问：映射器拒绝访问</p><p>　　 HTTP 403.13 - 禁止访问：客户证书已被吊销</p><p>　　 HTTP 403.15 - 禁止访问：客户访问许可过多</p><p>　　 HTTP 403.16 - 禁止访问：客户证书不可信或者无效</p><p>HTTP 403.17 - 禁止访问：客户证书已经到期或者尚未生效</p><p>404——没有发现文件、查询或URl</p><p>405——用户在Request-Line字段定义的方法不允许</p><p>406——根据用户发送的Accept拖，请求资源不可访问</p><p>407——类似401，用户必须首先在代理服务器上得到授权</p><p>408——客户端没有在用户指定的饿时间内完成请求</p><p>409——对当前资源状态，请求不能完成</p><p>410——服务器上不再有此资源且无进一步的参考地址</p><p>411——服务器拒绝用户定义的Content-Length属性请求</p><p>412——一个或多个请求头字段在当前请求中错误</p><p>413——请求的资源大于服务器允许的大小</p><p>414——请求的资源URL长于服务器允许的长度</p><p>415——请求资源不支持请求项目格式</p><p>416——请求中包含Range请求头字段，在当前请求资源范围内没有range指示值，请求也不包含If-Range请求头字段</p><p>417——服务器不满足请求Expect头字段指定的期望值，如果是代理服务器，可能是下一级服务器不能满足请求长。</p><p><strong>服务器执行一个完全有效请求失败</strong></p><p>　　 HTTP 500 - 内部服务器错误</p><p>　　 HTTP 500.100 - 内部服务器错误 -ASP 错误</p><p>　　 HTTP 500-11 服务器关闭</p><p>　　 HTTP 500-12 应用程序重新启动</p><p>　　 HTTP 500-13 - 服务器太忙</p><p>　　 HTTP 500-14 - 应用程序无效</p><p>　　 HTTP 500-15 - 不允许请求 global.asa</p><p>　　 Error 501 - 未实现</p><p> HTTP 502 - 网关错误</p><p>　　 <em>HTTP 500.100 - 内部服务器错误 -ASP 错误</em></p><p>　　 <em>HTTP 500-11 服务器关闭</em></p><p>　　 <em>HTTP 500-12 应用程序重新启动</em></p><p>　　 <em>HTTP 500-13 - 服务器太忙</em></p><p>　　 <em>HTTP 500-14 - 应用程序无效</em></p><p>　　 <em>HTTP 500-15 - 不允许请求 global.asa</em></p><p>　　 <em>Error 501 - 未实现</em></p><p> <em>HTTP 502 - 网关错误</em></p><p><strong>4 API设计的基本要求</strong></p><p>一个被普遍承认和遵守：RESTful设计原则。它被Roy Felding提出（在他的”基于网络的软件架构“论文中第五章）。而REST的核心原则是将你的API拆分为逻辑上的资源。这些资源通过http被操作（GET ,POST,PUT,DELETE）。</p><p> 显然从API用户的角度来看，”资源“应该是个名词。即使你的内部数据模型和资源已经有了很好的对应，API设计的时候你仍然不需要把它们一对一的都暴露出来。这里的关键是隐藏内部资源，暴露必需的外部资源。</p><p> 一旦定义好了要暴露的资源，你可以定义资源上允许的操作，以及这些操作和你的API的对应关系：</p><p>· GET /tickets # 获取ticket列表</p><p>· GET /tickets/12 # 查看某个具体的ticket</p><p>· POST /tickets # 新建一个ticket</p><p>· PUT /tickets/12 # 更新ticket 12.</p><p>· DELETE /tickets/12 #删除ticekt 12</p><p> 可以看出使用REST的好处在于可以充分利用http的强大实现对资源的CURD功能。而这里你只需要一个endpoint：/tickets,再没有其他什么命名规则和url规则了，cool！</p><p> 但是有的endpoint，需要使用复数使得你的URL更加规整。这让API使用者更加容易理解，对开发者来说也更容易实现。</p><p>如何处理关联？关于如何处理资源之间的管理REST原则也有相关的描述：</p><p>· GET /tickets/12/messages- Retrieves list of messages forticket #12</p><p>· GET /tickets/12/messages/5- Retrieves message #5 forticket #12</p><p>· POST /tickets/12/messages- Creates a new message inticket #12</p><p>· PUT /tickets/12/messages/5- Updates message #5 for ticket#12</p><p>· PATCH /tickets/12/messages/5- Partially updates message#5 for ticket #12</p><p>· DELETE /tickets/12/messages/5- Deletes message #5 forticket #12</p><p> 其中，如果这种关联和资源独立，那么我们可以在资源的输出表示中保存相应资源的endpoint。然后API的使用者就可以通过点击链接找到相关的资源。如果关联和资源联系紧密。资源的输出表示就应该直接保存相应资源信息。（例如这里如果message资源是独立存在的，那么上面 GET/tickets/12/messages就会返回相应message的链接；相反的如果message不独立存在，他和ticket依附存在，则上面的API调用返回直接返回message信息）</p><p><strong>5 get和post区别</strong></p><p> 常用的请求方式是GET和POST.</p><p>GET方式：是以实体的方式得到由请求URI所指定资源的信息，如果请求URI只是一个数据产生过程，那么最终要在响应实体中返回的是处理过程的结果所指向的资源，而不是处理过程的描述。</p><p>POST方式：用来向目的服务器发出请求，要求它接受被附在请求后的实体，并把它当作请求队列中请求URI所指定资源的附加新子项，Post被设计成用统一的方法实现下列功能：</p><p>1）对现有资源的解释；</p><p>2）向电子公告栏、新闻组、邮件列表或类似讨论组发信息；</p><p>3）提交数据块；</p><p>4）通过附加操作来扩展数据库 。</p><p>从上面描述可以看出，Get是向服务器发索取数据的一种请求；而Post是向服务器提交数据的一种请求，要提交的数据位于信息头后面的实体中。</p><p>GET与POST方法有以下区别：</p><p>1） 在客户端，Get方式在通过URL提交数据，数据在URL中可以看到；POST方式，数据放置在HTMLHEADER内提交。</p><p>2） GET方式提交的数据最多只能有1024字节，而POST则没有此限制。</p><p>3） 安全性问题。正如在（1）中提到，使用 Get 的时候，参数会显示在地址栏上，而 Post 不会。所以，如果这些数据是中文数据而且是非敏感数据，那么使用 get；如果用户输入的数据不是中文字符而且包含敏感数据，那么还是使用 post为好。</p><p>4） 安全的和幂等的。所谓安全的意味着该操作用于获取信息而非修改信息。幂等的意味着对同一 URL 的多个请求应该返回同样的结果。完整的定义并不像看起来那样严格。换句话说，GET 请求一般不应产生副作用。从根本上讲，其目标是当用户打开一个链接时，她可以确信从自身的角度来看没有改变资源。比如，新闻站点的头版不断更新。虽然第二次请求会返回不同的一批新闻，该操作仍然被认为是安全的和幂等的，因为它总是返回当前的新闻。反之亦然。POST 请求就不那么轻松了。POST 表示可能改变服务器上的资源的请求。仍然以新闻站点为例，读者对文章的注解应该通过 POST 请求实现，因为在注解提交之后站点已经不同了（比方说文章下面出现一条注解）。</p><p><strong>6 put和post区别</strong></p><p>有的观点认为，应该用POST来创建一个资源，用PUT来更新一个资源；有的观点认为，应该用PUT来创建一个资源，用POST来更新一个资源；还有的观点认为可以用PUT和POST中任何一个来做创建或者更新一个资源。这些观点都只看到了风格，争论起来也只是争论哪种风格更好，其实，用PUT还是POST，不是看这是创建还是更新资源的动作，这不是风格的问题，而是语义的问题。</p><p>举一个简单的例子，假如有一个博客系统提供一个Web API，模式是这样<a href="http://superblogging/blogs/{blog-name}，很简单，将{blog-name}" target="_blank" rel="noopener">http://superblogging/blogs/{blog-name}，很简单，将{blog-name}</a></p><p>替换为我们的blog名字，往这个URI发送一个HTTP PUT或者POST请求，HTTP的body部分就是博文，这是一个很简单的REST API例子。我们应该用</p><p>PUT方法还是POST方法？取决于这个REST服务的行为是否是idempotent的，假如我们发送两个<a href="http://superblogging/blogs/post/Sample请求，服" target="_blank" rel="noopener">http://superblogging/blogs/post/Sample请求，服</a></p><p>务器端是什么样的行为？如果产生了两个博客帖子，那就说明这个服务不是idempotent的，因为多次使用产生了副作用了嘛；如果后一个请求把第一个</p><p>请求覆盖掉了，那这个服务就是idempotent的。前一种情况，应该使用POST方法，后一种情况，应该使用PUT方法。</p>]]></content>
      
      
      
        <tags>
            
            <tag> post </tag>
            
            <tag> put </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>免费短信接码网站</title>
      <link href="/124395117.html"/>
      <url>/124395117.html</url>
      
        <content type="html"><![CDATA[<h2 id="国内平台展开目录"><a href="#国内平台展开目录" class="headerlink" title="国内平台展开目录"></a>国内平台展开目录</h2><ul><li><a href="https://www.pdflibr.com/" target="_blank" rel="noopener">https://www.pdflibr.com</a></li><li><a href="https://www.visitorsms.com/cn" target="_blank" rel="noopener">https://www.visitorsms.com/cn</a></li><li><a href="https://www.becmd.com/" target="_blank" rel="noopener">https://www.becmd.com</a></li><li><a href="http://www.114sim.com/" target="_blank" rel="noopener">http://www.114sim.com</a></li><li><a href="https://yunduanxin.net/" target="_blank" rel="noopener">https://yunduanxin.net</a></li><li><a href="http://www.smszk.com/" target="_blank" rel="noopener">http://www.smszk.com</a></li><li><a href="http://z-sms.com/" target="_blank" rel="noopener">http://z-sms.com</a></li><li><a href="http://www.shejiinn.com/" target="_blank" rel="noopener">http://www.shejiinn.com</a></li><li><a href="https://sms.cngrok.com/" target="_blank" rel="noopener">https://sms.cngrok.com</a></li></ul><h2 id="国外平台展开目录"><a href="#国外平台展开目录" class="headerlink" title="国外平台展开目录"></a>国外平台展开目录</h2><ul><li><a href="https://ch.freephonenum.com/" target="_blank" rel="noopener">https://ch.freephonenum.com</a></li><li><a href="https://smsreceivefree.com/" target="_blank" rel="noopener">https://smsreceivefree.com</a></li><li><a href="https://zh.mytrashmobile.com/" target="_blank" rel="noopener">https://zh.mytrashmobile.com</a></li><li><a href="https://www.receive-sms-online.info/" target="_blank" rel="noopener">https://www.receive-sms-online.info</a></li><li><a href="https://receiveasms.com/" target="_blank" rel="noopener">https://receiveasms.com</a></li><li><a href="https://sms-online.co/receive-free-sms" target="_blank" rel="noopener">https://sms-online.co/receive-free-sms</a></li><li><a href="https://receive-sms.com/" target="_blank" rel="noopener">https://receive-sms.com</a></li></ul><p><a href="https://hao.su/2495/?from=dalao.ru" target="_blank" rel="noopener">引用链接</a></p><h2 id="在线邮箱展开目录"><a href="#在线邮箱展开目录" class="headerlink" title="在线邮箱展开目录"></a>在线邮箱展开目录</h2><blockquote><p>9em</p></blockquote><p><a href="https://9em.org/" target="_blank" rel="noopener">https://9em.org</a></p><p>9em.org 来自不死鸟微信群内大佬，这是一个 10 分钟邮箱服务，邮箱后缀为 [<code>@9em.org](mailto:</code>@9em.org)` 9em 取自 九条命 Email</p><p>在屏幕右上角输入一个你想要的邮箱前缀，就能收取邮件需要注意的是这个邮箱对所有人都是公开的，并且邮件仅在服务器保存十分钟，十分钟后会自动删除</p><blockquote><p>maildrop</p></blockquote><p><a href="https://maildrop.cc/" target="_blank" rel="noopener">https://maildrop.cc</a></p><p>打开 maildrop 会自动生成一个临时的邮箱，如果你不想更改地址，可以直接点右上角的 Go 进入收件箱页面，也可以在右上角修改邮箱前缀地址，在进入临时收件箱页面。</p><blockquote><p>bccto</p></blockquote><p><a href="http://bccto.me/" target="_blank" rel="noopener">http://bccto.me</a></p><p>10 分钟邮箱，可以自定义也可以随机申请的 10 分钟临时邮箱，支持自定义域名，可以将自己的域名绑定 bccto 服务。</p><blockquote><p>10minutemail</p></blockquote><p><a href="https://10minutemail.net/" target="_blank" rel="noopener">https://10minutemail.net</a></p><p>一个 10 分钟邮箱</p><blockquote><p>10minutemail</p></blockquote><p><a href="https://10minutemail.com/" target="_blank" rel="noopener">https://10minutemail.com</a></p><p>10 分钟邮箱，老牌网站 07 年稳定至今。 小部分网站网站封锁了 10minutemail 的域名，可能无法接收，可以当作备用。</p><blockquote><p>666 临时邮箱</p></blockquote><p><a href="https://www.666email.com/" target="_blank" rel="noopener">https://www.666email.com/</a></p><p>UI 很简洁，提供了 2 个域名选择，可以自定义也可以随机生成。</p><blockquote><p>anyalias</p></blockquote><p><a href="https://anyalias.com/" target="_blank" rel="noopener">https://anyalias.com</a><br>anyalias 是一个可以保护隐私的邮箱服务，可以生成一个自定义的邮箱然后转发给你的真实邮箱，从而达到保护隐私的效果，更多介绍查看 <a href="https://hao.su/1474/" target="_blank" rel="noopener">anyalias.com：无限制的免费电子邮件地址</a></p><blockquote><p>eskiimo</p></blockquote><p><a href="https://eskiimo.com/" target="_blank" rel="noopener">https://eskiimo.com</a></p><p>匿名发送邮件给任何人</p><h2 id="在线办公展开目录"><a href="#在线办公展开目录" class="headerlink" title="在线办公展开目录"></a>在线办公展开目录</h2><p><a href="https://shimo.im/" target="_blank" rel="noopener">https://shimo.im</a></p><p>石墨文档</p><p><a href="https://www.notion.so/" target="_blank" rel="noopener">https://www.notion.so</a></p><p>notion</p><p><a href="https://yuque.com/" target="_blank" rel="noopener">https://yuque.com</a></p><p>语雀</p><p><a href="https://docs.qq.com/" target="_blank" rel="noopener">https://docs.qq.com</a></p><p>腾讯文档</p><p><a href="https://tableconvert.com/" target="_blank" rel="noopener">https://tableconvert.com</a></p><p>一个免费的在线表格转换工具 TableConvert</p>]]></content>
      
      
      
        <tags>
            
            <tag> 资源 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu开发软件安装</title>
      <link href="/1625103035.html"/>
      <url>/1625103035.html</url>
      
        <content type="html"><![CDATA[<ul><li><p>2020-03-20 Ubuntu开发软件安装</p><p><strong>kchmviewer</strong>是用与 查看 chm,Windows下是有各种软件Linux下下载过几个软件不是对中文支持不好或者就是容易崩溃的</p><p>DbVisualizer Pro 10.0.26 [Build #3028]是用与数据库连接客户端,相比比较dbevaer是各个自定义功能和方法还方便很多,就是显示信息也是很方便,免费版就是不能直接在表里编辑数据其他完全够用,需要激活我用的最新版找了好久<a href="https://github.com/xiaguliuxiang/dbvisualizer-agent" target="_blank" rel="noopener">链接地址</a></p><p>ZSH这真的是个神器,在终端上编辑和检测输入语法会非常方便,各种插件自定义后完全可以发现全新的世界,同时可以考虑.</p><p>酸酸乳ssr,v2ray连接工具之前用的是Qv2ray.v2.1.2.linux-x64.qt5.13.2.AppImage 好用非常方便用过的最好的连接工具了</p></li></ul><hr><h3 id="Linux-版SecureCRT-SecureFX-8-5-4"><a href="#Linux-版SecureCRT-SecureFX-8-5-4" class="headerlink" title="Linux 版SecureCRT/SecureFX 8.5.4"></a>Linux 版SecureCRT/SecureFX 8.5.4</h3><p>1）下载secureCRT和secureFX**<br>官网下载地址：<a href="https://www.vandyke.com/download/index.html" target="_blank" rel="noopener">https://www.vandyke.com/download/index.html</a><br>scrt-sfx-8.5.4-1942.ubuntu16-64.x86_64.deb secureCRT和secureFX 前面是ssh连接 后面是FTP的连接</p><p><strong>2）进行安装</strong></p><p>sudo dpkg -i scrt-sfx-8.5.4-1942.ubuntu16-64.x86_64.deb<br>如果安装过程中因为缺少依赖而安装失败，只需要通过命令：<strong>apt-get install -f</strong>即可完成依赖的安装</p><p><strong>3）secureCRT和secureFX的License破解</strong><br><strong>破解文件下载：<a href="https://share.weiyun.com/5Mc38uB" target="_blank" rel="noopener">https://share.weiyun.com/5Mc38uB</a> 密码：yetp32</strong></p><pre><code>**sudo  perl securecrt_forgeek_crack.pl /usr/bin/SecureCRT**启动SecureCRT，根据执行结果填写license信息即可3.1) 运行破解secureFX脚本**sudo perl securefx_forgeek_crack.pl /usr/bin/SecureFX**启动SecureFX，根据执行结果填写license信息即可</code></pre><p><a href="https://www.52pojie.cn/thread-1000970-1-1.html" target="_blank" rel="noopener">参考连接</a> 找了好久我这个算是比较新的 网上的大部分都不行 用的一个是都激活不了secureFX 现在可以</p>]]></content>
      
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo提交百度和Google收录站点</title>
      <link href="/3423376587.html"/>
      <url>/3423376587.html</url>
      
        <content type="html"><![CDATA[<h2 id="使用sitemap-提交网站"><a href="#使用sitemap-提交网站" class="headerlink" title="使用sitemap 提交网站"></a>使用sitemap 提交网站</h2><pre><code>安装插件npm install hexo-generator-baidu-sitemap --savenpm install hexo-generator-sitemap --save_config.yml# 自动生成sitemapsitemap:  path: sitemap.xmlbaidusitemap:  path: baidusitemap.xml</code></pre><h3 id="1-百度提交"><a href="#1-百度提交" class="headerlink" title="1 百度提交"></a>1 百度提交</h3><pre><code>https://ziyuan.baidu.com/linksubmit/index浏览器打开   your-url/baidusitemap.xml   看下有没有文件</code></pre><p><a href="../img/1565098183259.png"><img src="../img/1565098183259.png" alt="1565098183259"></a></p><h3 id="2-Google提交"><a href="#2-Google提交" class="headerlink" title="2 Google提交"></a>2 Google提交</h3><pre><code>https://search.google.com/search-console/sitemaps浏览器打开   your-url/sitemap.xml  看下有没有文件提交站点地图</code></pre><h2 id="使用-hexo-baidu-url-submit-自动提交"><a href="#使用-hexo-baidu-url-submit-自动提交" class="headerlink" title="使用 hexo-baidu-url-submit 自动提交"></a>使用 hexo-baidu-url-submit 自动提交</h2><p> <a href="https://github.com/huiwang/hexo-baidu-url-submit" target="_blank" rel="noopener">github地址</a></p><pre><code>npm install hexo-baidu-url-submit --savebaidu_url_submit:  count: 1000 ## 提交最新的一个链接  host: alili.tech ## 在百度站长平台中注册的域名  token: xxxxx ## 请注意这是您的秘钥， 所以请不要把博客源代码发布在公众仓库里!  path: baidu_urls.txt ## 文本文档的地址， 新链接会保存在此文本文档里deploy 配置deploy:- type: baidu_url_submitter # 百度在上面的图片点击自动提交 接口调用地址： http://data.zz.baidu.com/urls?site=XXX &amp;token=XXX前面XXX是你的网站 后面XXX是token的值</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令记录</title>
      <link href="/2125313135.html"/>
      <url>/2125313135.html</url>
      
        <content type="html"><![CDATA[<p>最近常用的Linux 命令</p><h3 id="查询相关"><a href="#查询相关" class="headerlink" title="查询相关"></a>查询相关</h3><pre><code>find .|xargs grep -ri &quot;XXX&quot; -l      查找目录下的所有文件中包含某个字符串 XXX 1   lsof  -i:端口号         # lsof -i:8000        COMMAND   PID USER   FD   TYPE   DEVICE SIZE/OFF NODE NAME        nodejs  26993 root   10u  IPv4 37999514      0t0  TCP *:8000 (LISTEN)        2  netstat -tunlp | grep 端口号            -t (tcp) 仅显示tcp相关选项            -u (udp)仅显示udp相关选项            -n 拒绝显示别名，能显示数字的全部转化为数字            -l 仅列出在Listen(监听)的服务状态            -p 显示建立相关链接的程序名</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建云播基于cloud-torrent</title>
      <link href="/1352061511.html"/>
      <url>/1352061511.html</url>
      
        <content type="html"><![CDATA[<h3 id="基于Aria2-搭建离线云播"><a href="#基于Aria2-搭建离线云播" class="headerlink" title="基于Aria2 搭建离线云播"></a>基于Aria2 搭建离线云播</h3><p>之前撸了个谷歌云的服务器都没怎么用 现在突然记起来了随便搭建了 刚开始是想搭建基于<a href="https://blog.liyuans.com/archives/yunbt.html" target="_blank" rel="noopener">参考链接</a> 离线技术来自于 Aria2</p><p>但是没有安装成功我是 Debian9 没有能安装 脚本里面的是</p><pre><code>安装锐速 serverspeeder-all.sh</code></pre><p>而且启动里面的 mysql 还有thinkPHP 所以不上去是不是有什么其他错误</p><h3 id="换一种搭建方案基于cloud-torrent"><a href="#换一种搭建方案基于cloud-torrent" class="headerlink" title="换一种搭建方案基于cloud-torrent"></a>换一种搭建方案基于<strong>cloud-torrent</strong></h3><p>后面是想看看还有没有其他的搭建方案 搜了一下果然是有比较完善和封装比较好的服务</p><p><a href="https://www.moerats.com/archives/291/" target="_blank" rel="noopener">参考链接</a></p><pre><code>wget -N --no-check-certificate https://raw.githubusercontent.com/ToyoDAdoubiBackup/doubi/master/cloudt.sh &amp;&amp; chmod +x cloudt.sh &amp;&amp; bash cloudt.sh</code></pre><p><a href="https://github.com/jpillora/cloud-torrent" target="_blank" rel="noopener">github地址</a></p><p>说一下中间的坑 因为选择想有绑定时有域名和IP的两种选项我刚好有域名就绑了个子域名后面等后面安装后启动就一直报</p><pre><code>Can&#39;t assign requested address</code></pre><p>我以为是端口占用 杀了对于进程但是不行 我就卸载了对于软件 重新安装 在绑定端口时选择了8080 但是还是不星 但是8080是没有服务占用的</p><p>所以我换成我服务器的IP地址就行了 应该是它需要监听域名的请求但是和本机IP 不能绑定 目前的将我子域名直接解析到对于的云播地址就了</p><p>速度不错</p><p><a href="../img/2019-08-04_19-49.png"><img src="../img/2019-08-04_19-49.png" alt="img"></a></p><p>最后分享应该安卓端也可用的<a href="http://jufengxiazai.com/" target="_blank" rel="noopener">点我下载</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
            <tag> 云播 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建orientDB</title>
      <link href="/2702077458.html"/>
      <url>/2702077458.html</url>
      
        <content type="html"><![CDATA[<pre><code>apt-get update apt-get default_jrecd /optwget https://s3.us-east-2.amazonaws.com/orientdb3/releases/3.0.22/orientdb-3.0.22.tar.gz tar zxvf  3.0.22/orientdb-3.0.22.tar.gz cp -r 3.0.22/orientdb-3.0.22.tar.gz  orientDB  cd orientDB  cd bin  ./server.sh</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> orientDb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>折腾几个小时的Ubuntu启动出错</title>
      <link href="/3716506550.html"/>
      <url>/3716506550.html</url>
      
        <content type="html"><![CDATA[<h3 id="Ubuntu出错"><a href="#Ubuntu出错" class="headerlink" title="Ubuntu出错"></a>Ubuntu出错</h3><p>今天莫名其妙的Ubuntu 出错 ,刚开始显示错误如下</p><p>刚开始显示</p><pre><code>“Couldn’t get size: 0x800000000000000e”加载一段时间后显示 failed start kernel   吓到我了以为关机前是有过升级的 不知道有没有升级内核补丁</code></pre><p>就被这个误导了查了好久</p><p><a href="../img/20190729215017.jpg"><img src="../img/20190729215017.jpg" alt="微信图片_20190729215017"></a></p><h3 id="引导恢复"><a href="#引导恢复" class="headerlink" title="引导恢复"></a>引导恢复</h3><p>这个弄完后就是</p><p>使用 boot-repair</p><p>但是按照网上的添加源后 使用apt-get安装完全不行一直提示什么Pakage万能安装成功提示 apt -get update 莫名其妙 准备直接找 boot-repair.deb 包千辛万苦找到后不能安装 真的是醉了</p><p>后面也是人肉在网上找的关联包 gawk_4.1.3+dfsg-0.1_amd64.deb 先安装这个后面再安装boot-repair_4ppa65_all.deb 对了我的是用U盘进的Ubuntu16</p><p>所以<a href="https://www.lanzous.com/i58030b" target="_blank" rel="noopener">下载链接</a></p><h3 id="最终解决"><a href="#最终解决" class="headerlink" title="最终解决"></a>最终解决</h3><p>其实不是上述问题 在看到有 emergency mode 后我尝试在网搜了一下 原来是我fsb 文件的问题 仔细看打印的日志也正好是这个意思 我的某个分区没有成功挂载 ctrl+d 后直接指明的对应的分区</p><p>我是注释掉了 /etc/fstab 文件里的出错的分区 不知道是什么时候添加的 好坑</p><p><a href="https://www.jianshu.com/p/7433e0bb38e9" target="_blank" rel="noopener">参考博客</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo优化</title>
      <link href="/878762119.html"/>
      <url>/878762119.html</url>
      
        <content type="html"><![CDATA[<h3 id="tags-多标签-multi-category-and-multi-tag-2020年3月31日"><a href="#tags-多标签-multi-category-and-multi-tag-2020年3月31日" class="headerlink" title="tags 多标签 multi category and multi tag -2020年3月31日"></a>tags 多标签 multi category and multi tag -2020年3月31日</h3><pre><code>//文章标签，可空，多标签请用格式[tag1,tag2,tag3]，如下，注意!!&quot;tags:&quot;后面有个空格tags: [tag1, tag2, tag3, ...]// 下面这种方式似乎仅限于hexo 3.0tags:- npm  - vue</code></pre><p>注意tags: 后面不要有空格,-与标签名之间应该有空格</p><p><a href="https://github.com/hexojs/hexo/issues/1520" target="_blank" rel="noopener">How about supporting multi category and multi tag</a></p><hr><h3 id="设置date的格式"><a href="#设置date的格式" class="headerlink" title="设置date的格式"></a>设置date的格式</h3><table><thead><tr><th align="center">变量</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><code>:year</code></td><td align="center">文章的发表年份（4 位数）</td></tr><tr><td align="center"><code>:month</code></td><td align="center">文章的发表月份（2 位数）</td></tr><tr><td align="center"><code>:i_month</code></td><td align="center">文章的发表月份（去掉开头的零）</td></tr><tr><td align="center"><code>:day</code></td><td align="center">文章的发表日期 (2 位数)</td></tr><tr><td align="center"><code>:i_day</code></td><td align="center">文章的发表日期（去掉开头的零）</td></tr><tr><td align="center"><code>:title</code></td><td align="center">文件名称</td></tr><tr><td align="center"><code>:post_title</code></td><td align="center">文章标题</td></tr><tr><td align="center"><code>:id</code></td><td align="center">文章 ID</td></tr><tr><td align="center"><code>:category</code></td><td align="center">分类。如果文章没有分类，则是 <code>default_category</code> 配置信息</td></tr></tbody></table><p><a href="https://github.com/Rozbo/hexo-abbrlink" target="_blank" rel="noopener">github地址</a> 可以参考一下代码风格</p><h3 id="为网页设置统一风格的URL"><a href="#为网页设置统一风格的URL" class="headerlink" title="为网页设置统一风格的URL"></a>为网页设置统一风格的URL</h3><p><a href="https://github.com/Rozbo/hexo-abbrlink" target="_blank" rel="noopener">github地址</a></p><pre><code>npm install hexo-abbrlink --save 安装 该插件 后将_config.yml permalink: :abbrlink.html   # 生成唯一链接  永久链接（Permalinks）abbrlink:  alg: crc32  # 算法：crc16(default) and crc32  rep: dec    # 进制：dec(default) and hex    permalink_defaults: :year/:month/:day/:title/   默认是是这样拼接URL</code></pre><p><a href="https://liziczh.com/hexo-submit.html" target="_blank" rel="noopener">参考链接</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>检查Ubuntu开机的相关操作</title>
      <link href="/2802364883.html"/>
      <url>/2802364883.html</url>
      
        <content type="html"><![CDATA[<p> 开机启动软件都会放在这个目录下/etc/init.d/</p><p> systemd-analyze blame 可以分析开机占用时间比较多点 进程</p><p> sudo systemd-analyze plot &gt; boot.svg 可以想数据导出成 svg 文件</p><p>或者直接查看 开机日志 /var/log/boot.log</p>]]></content>
      
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搜狗输入法linux版  两个图标在托盘 tray</title>
      <link href="/7f98c9f2.html"/>
      <url>/7f98c9f2.html</url>
      
        <content type="html"><![CDATA[<h3 id="托盘水平"><a href="#托盘水平" class="headerlink" title="托盘水平"></a>托盘水平</h3><p><a href="../img/1563915951910.png"><img src="../img/1563915951910.png" alt="img"></a></p><p><a href="../img/1563915998744.png"><img src="../img/1563915998744.png" alt="1563915998744"></a></p><p>起初是因为 fcitx和搜狗冲突了</p><pre><code>1 .)ps -rf |grep fcitx         kill -9 对应进程  2.) killall fcitx 开机后就还行</code></pre><p>然后准备加到开机启动脚本里面 查了一下 可以是 /etc/ini.d 或者local.c 下 然后着手开始干,但是注销用户登录后还是不行,当时就蒙了主要是后面调用不出来搜狗了 有应该是fcitx 上面的汉语输入法 而且很丑,然后就接着查找资料</p><p>最后发现有人的教程里面提到fcitx的配置文件(fcitx-config-gtk3) 可以设置取消界面,就压根不知道为什么要这么配置<a href="https://www.jianshu.com/p/c936a8a2180e" target="_blank" rel="noopener">参考链接</a></p><p><a href="../img/2019-07-24_04-58.png"><img src="../img/2019-07-24_04-58.png" alt="img"></a></p>]]></content>
      
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
            <tag> 搜狗输入法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决deepin-wine 下微信黑窗口问题</title>
      <link href="/835633961.html"/>
      <url>/835633961.html</url>
      
        <content type="html"><![CDATA[<p> 之前一直是有deepin-wine 下微信黑窗口问题 一直拖着没解决　比较不知道怎么去解决当时是有写过一个临时优化的<a href="https://bigleek.ml/2019/03/27/ubuntu优化3/" target="_blank" rel="noopener">点击链接</a> <a href="https://yundantianchang.github.io/blogs/2018/1015-1.html" target="_blank" rel="noopener">参考的的链接</a>当实现的效果是可以但是有反复 后面就没怎么弄 一直是在输入666 这可以可以消除 但是每次弹出来好烦 看到留言区的</p><pre><code>vim  /opt/deepinwine/apps/Deepin-WeChat/run.sh向下面追加wmctrl -l -G -p -x | grep wechat.exe.Wine | grep -v 微信| awk &#39;{print $1}&#39; | xargs -r -i xdotool windowunmap {}</code></pre><p><a href="../img/1563888126000.png"><img src="../img/1563888126000.png" alt="1563888126000"></a></p><p>我修改后是可以跑通的</p><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p><a href="https://github.com/wszqkzqk/deepin-wine-ubuntu/issues/72#issuecomment-486963557" target="_blank" rel="noopener">参考链接</a></p><p>注意要</p><pre><code>1.  sudo chmod +x /opt/deepinwine/apps/Deepin-WeChat/runrun.sh  给执行权限2. 根据deepin-wine 的配置和路径来</code></pre><p>我这边是没成功的不知道为什么</p>]]></content>
      
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
            <tag> deepin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker 简单使用</title>
      <link href="/4262021452.html"/>
      <url>/4262021452.html</url>
      
        <content type="html"><![CDATA[<h3 id="如果已安装不想要docker、docker-engine、docker-ce相关的软件包，则卸载掉："><a href="#如果已安装不想要docker、docker-engine、docker-ce相关的软件包，则卸载掉：" class="headerlink" title="如果已安装不想要docker、docker-engine、docker-ce相关的软件包，则卸载掉："></a>如果已安装不想要docker、docker-engine、docker-ce相关的软件包，则卸载掉：</h3><p>sudo yum -y remove docker docker-common docker-selinux docker-engine docker-engine-selinux container-selinux docker-ce</p><p>#删除所有的镜像、容器、数据卷、配置文件等<br>sudo rm -rf /var/lib/docker</p><h2 id="如果已安装不想要docker、docker-engine、docker-ce相关的软件包"><a href="#如果已安装不想要docker、docker-engine、docker-ce相关的软件包" class="headerlink" title="如果已安装不想要docker、docker-engine、docker-ce相关的软件包"></a>如果已安装不想要docker、docker-engine、docker-ce相关的软件包</h2><p>则卸载掉：<br>sudo yum -y remove docker docker-common docker-selinux docker-engine docker-engine-selinux container-selinux docker-ce</p><p>#删除所有的镜像、容器、数据卷、配置文件等<br>sudo rm -rf /var/lib/docker</p><p>rpm -qa|grep docker</p><p>yum list installed|grep docker</p>]]></content>
      
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP学习笔记</title>
      <link href="/1439793898.html"/>
      <url>/1439793898.html</url>
      
        <content type="html"><![CDATA[<h2 id="PHP学习笔记"><a href="#PHP学习笔记" class="headerlink" title="PHP学习笔记"></a>PHP学习笔记</h2><pre><code>PHP（全称：PHP：Hypertext Preprocessor，即“PHP：超文本预处理器”）是一种开源的通用计算机脚本语言，尤其适用于网络开发并可嵌入HTML中使用。PHP的语法借鉴吸收C语言、Java和Perl等流行计算机语言的特点，易于一般程序员学习。PHP的主要目标是允许网络开发人员快速编写动态页面，但PHP也被用于其他很多领域。[1]PHP最初是由勒多夫在1995年开始开发的；现在PHP的标准由the PHP Group[2]维护。PHP以PHP License作为许可协议，不过因为这个协议限制了PHP名称的使用，所以和开放源代码许可协议GPL不兼容。[3]PHP的应用范围相当广泛，尤其是在网页程序的开发上。一般来说PHP大多运行在网页服务器上，透过运行PHP代码来产生用户浏览的网页。PHP可以在多数的服务器和操作系统上运行，而且使用PHP完全是免费的。根据2013年4月的统计数据，PHP已经被安装在超过2亿4400万个网站和210万台服务器上[4]。PHP在Windows上有专门的官方移植编译项目，并且分多个VC编译器版本和线程安全特性来提供不同的版本支持。----维基百科</code></pre><p><a href="https://www.kancloud.cn/yangweijie/yang_book/30731" target="_blank" rel="noopener">引用链接</a></p><p>PHP常见错误，我认为主要分为3块：</p><h2 id="1、语法错误"><a href="#1、语法错误" class="headerlink" title="1、语法错误"></a>1、语法错误</h2><pre><code>Parse error: syntax error, unexpected T_VARIABLE in E:\gstbook\user.php on line 268</code></pre><p>一般是少分号，在上一行或者下一行都有可能<br><code>Parse error: syntax error, unexpected &#39;.&#39; in F:\www\blog\article.php on line 100</code></p><p>多个“.”，类似的还有多个“;”等等</p><p><code>Notice: Undefined variable: a in ...</code><br>使用了一个没有被定义的变量a</p><pre><code>Parse error: syntax error, unexpected T_ELSE in</code></pre><p>if else if else 句式逻辑错误</p><p><code>Parse error: syntax error, unexpected $end in</code><br>一般是大括号不匹配</p><p><code>Parse error: syntax error, unexpected T_STRING in</code><br>一般是忘了写句末分号</p><p><code>Parse error: syntax error, unexpected T_PRIVATE in</code><br>一般是private函数位置写到了调用自己函数的内部</p><p><code>Warning: Invalid argument supplied for foreach() in</code><br>foreach 的第一个参数必须是一个数组</p><p><code>Warning: Wrong parameter count for a in</code><br>函数参数个数不对</p><pre><code>Warning: session_start() [function.session-start]: Cannot send session cache limiter - headers already sent (output started at F:\www\blog\index.php:10) in F:\www\blog\incl?s\config.inc.php on line 10Warning: annot modify header information - headers already sent by (output started at F:\www\blog\index.php:10) in F:\www\blog\incl?s\config.inc.php on line 12</code></pre><p>session前面不能有输出，同意的cookie也是这样的</p><p><code>Fatal error: Cannot redeclare</code><br>函数已经定义过，不能重新再定义；类也不能同名</p><h2 id="2、SQL语句错误"><a href="#2、SQL语句错误" class="headerlink" title="2、SQL语句错误"></a>2、SQL语句错误</h2><p><code>Warning: mysql_fetch_assoc(): supplied argument is not a valid MySQL result resource in</code><br>说明前面执行SQL 返回失败，一般可能是SQL语句错误 ，如分析不出来，可以Mysql_error () 看具体是哪个地方错了</p><p><code>No database selected</code><br>一般是没有连接数据库</p><p><code>Warning: mysql_connect() [function.mysql-connect]: Access denied for user ‘root’@&#39;localhost’ (using password: YES) in ….. on line 3Access denied for user ‘root’@&#39;localhost’ (using password: YES)</code><br>数据库用户名的密码错误</p><p><code>Unknown database ‘cms07261′</code><br>数据库不存在</p><p><code>Table ‘cms0726.test’ doesn’t exist</code><br>表不存在</p><p><code>Unknown column ‘abc’ in ‘field list’</code><br>字段不存在</p><p><code>Column count doesn’t match val count at row 1</code><br>sql语句中 字段值的个数比字段名个数不一样</p><h2 id="3、模板错误"><a href="#3、模板错误" class="headerlink" title="3、模板错误"></a>3、模板错误</h2><p><code>Fatal error: Smarty error: [in message_list.html line 22]: syntax error: ‘foreach: item’ must be a variable name (literal string)</code><br>foreach 后面的item 后面必须跟一个变量名，不加$，是一个字符串</p><p><code>Fatal error: Smarty error: [in admin/tpl/class_detail.html line 14]: syntax error: unrecognized tag: cs.st?nt_id (Smarty_Compiler.class.php, line 436) in D:\www\web\xmphp\inc\smarty\Smarty.class.php on line 1088</code><br>smarty语法错误：循环数组的时候，少$</p><p><code>Warning: Smarty error: unable to read resource: “message_list1.html” in</code><br>模板文件找不到，看是否是文件名写错或文件存放到别的目录中去了。</p><p><code>Fatal error: Smarty error: [in order_detail.html line 171]: syntax error: unclosed tag \{elseif} (opened line 157). (Smarty_Compiler.class.php, line 317) in F:\www\gstbook\xmphp\inc\smarty\Smarty.class.php on line 1088</code><br>html页面语法错误，少结束标签&lt;%/if%&gt;<br>以后遇到问题，我会及时更新！</p><p>附上PHP错误报表:</p><p>序号代码错误报告</p><table><thead><tr><th align="center">1</th><th align="center">error_reporting(Integer)</th><th align="center">此设置是每个脚本默认错误报告设置。它的参数可以是这里列出的任意常量，表示所有错误的E_ALL或者类似E_ALL&amp;E_NOTICE的一个逻辑表达式。</th></tr></thead><tbody><tr><td align="center">2</td><td align="center">display_error(Boolean)</td><td align="center">此设置控制错误是否作为PHP输出的一部分显示出来，默认设置是on。</td></tr><tr><td align="center">3</td><td align="center">display_startup_errors(Boolean)</td><td align="center">此设置控制在PHP启动时是否显示错误，默认设置是off，而且是用来调试C扩展。</td></tr><tr><td align="center">4</td><td align="center">error_prepend_string(String)</td><td align="center">这个字符串在浏览器中显示错误信息之前直接显示出来。</td></tr><tr><td align="center">5</td><td align="center">track_errors(Boolean)</td><td align="center">当这个设置开启时，一旦一个错误出现，变量$php_errormsg在PHP作用域中被定义。这个变量包含错误信息。</td></tr><tr><td align="center">6</td><td align="center">html_errors(Boolean)</td><td align="center">此设置控制是否在错误信息中采用HTML格式。默认情况下显示的是HTML错误，CLI版本的PHP除外。</td></tr><tr><td align="center">7</td><td align="center">xmlrpc_erroes(Boolean)</td><td align="center">此设置控制错误信息是否启用作为XML－RPC故障显示。</td></tr><tr><td align="center">8</td><td align="center">xmlrpc_error_number(Integer)</td><td align="center">这个XML-RPC故障代码是启用xmlrpc_errors时使用的。</td></tr><tr><td align="center">9</td><td align="center">log_errors(Boolean)</td><td align="center">此设置控制错误是否记录。日志的地址是通过error_log设置决定的。默认情况下，错误被记录到Web服务器的错误日志中。</td></tr><tr><td align="center">10</td><td align="center">log_error_max_len(Integer)</td><td align="center">此设置是当启用log_errors时控制记录的错误信息的最大长度。超过这个长度的信息也会被记录下来，但是会被截断。</td></tr><tr><td align="center">11</td><td align="center">error_log(String)</td><td align="center">此设置决定错误记录的地方。在默认情况下，它们被传送到Web服务器的错误记录机制中，但必须指定一个文件名，或者指定Syslog让系统日志来记录。</td></tr><tr><td align="center">12</td><td align="center">ignore_report_errors(Boolean)</td><td align="center">当启用它时，这个设置让PHP不在同一行中重复显示一样的错误信息。</td></tr><tr><td align="center">13</td><td align="center">ignore_repeated_source(Boolean)</td><td align="center">当启用时，PHP将不显示与前一个显示的错误来自同一个文件同一行错误。如果它没有被启用，它就不起作用。</td></tr></tbody></table><p>2 、PHP错误是通过错误级别进行划分的，范围从通告到严重错误，这个错误级别报告错误的严重性。大部分错误可以用常用的错误处理器来获取，但其中一些则不可恢复。</p><p>PHP错误级别表</p><table><thead><tr><th align="center">序号</th><th align="center">错误代码</th><th align="center">错误级别</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">E_ERROR</td><td align="center">严重错误，不可恢复。例如内存不足、位置异常或类重复声明错误</td></tr><tr><td align="center">2</td><td align="center">E_WARNING</td><td align="center">一个经常发生的错误类型。表示一些操作错误。例如丢失函数参数，连接数据库失败，除数为0等错误。</td></tr><tr><td align="center">3</td><td align="center">E_PARSE</td><td align="center">编译时发生的解析错误，会导致在PHP执行前退出。意味着如果一个文件因为解析错误运行失败，程序将停止运行。</td></tr><tr><td align="center">4</td><td align="center">E_STRICT</td><td align="center">错误级别是唯一不包含在E_ALL常量中。这是为了让PHP4到PHP5的迁移更加容易；你可以在PHP5软件系统中运行PHP4代码。</td></tr><tr><td align="center">5</td><td align="center">E_NOTICE</td><td align="center">运行代码在操作一些未知的动作，例如读取为定义的变量。</td></tr><tr><td align="center">6</td><td align="center">E_CORE_ERROR</td><td align="center">内部错误，扩展启动失败导致的，会导致PHP运行退出。</td></tr><tr><td align="center">7</td><td align="center">E_COMPILE_ERROR</td><td align="center">编译错误，与E_PARSE不同，这个错误会导致PHP运行退出。</td></tr><tr><td align="center">8</td><td align="center">E_WARNING_ERROR</td><td align="center">编译时的警告，可能是使用者发生语法错误。</td></tr><tr><td align="center">9</td><td align="center">E_USER_ERROR</td><td align="center">用户定义错误导致PHP退出执行。用户定义错误(E_USER_*)不是来自PHP本身，而是包含在脚本中。</td></tr><tr><td align="center">10</td><td align="center">E_USER_WARNING</td><td align="center">用户定义错误不会导致PHP退出执行。脚本可以使用它来通知一个执行失败，执行失败PHP也会用E_WARNING来通知。</td></tr><tr><td align="center">11</td><td align="center">E_USER_NOTICE</td><td align="center">用户定义的通告可以用来在脚本中可能存在错误。</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我目前的Ubuntu软件</title>
      <link href="/78752914.html"/>
      <url>/78752914.html</url>
      
        <content type="html"><![CDATA[<p>整理一下我用了这么久后觉得还可以使用的软件</p><p>目前这台电脑没有用与实际开发但是开发工具还是都有的而且还有deb包的,方便;)</p><p>浏览器: chrome firefox (常见插件包括 tempermonkey ,ublock , stylus ,SwitchyOmega, https everywhere )</p><p>开发工具 : IDEA, VScode, VMware ZSH, sublime_text ,DBeaver ,SSH(securet )+ftp(secureFX)</p><p>截屏工具 livepath(录屏软件),flamesflash(截屏),peek(录GIF)</p><p>办公工具 : Xmind WPS typore,foxit(PDF)</p><p>同步工具 onenote 坚果云</p><p>影音播放: spotify(推荐 版权多) 网易云音乐, VLC(要自己找主题和配置快捷键不然真的是反人类)</p><p>下载工具 uget(已经不行了 arai) ,motrix ,Xtreme download,</p><p>其他: ciliber(电子书编辑和阅读) xchm(chm阅读) ,搜狗 deepin-wine(安装 微信 迅雷),SSR(electrol ssr),安卓模拟器(Genymotion 选择个人用户)</p>]]></content>
      
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu优化－onedrive</title>
      <link href="/1097254589.html"/>
      <url>/1097254589.html</url>
      
        <content type="html"><![CDATA[<p>之前是准备用onedrive-dev 但是涉及到太多的以来还有步骤很复杂</p><p>有看到其他</p><pre><code>Easy to configure:$ cat ~/.config/onedrive/configsync_dir = &quot;~/OneDrive&quot;skip_file = &quot;.*|~*|thumbs.db|Games/*.iso&quot;skip_dir = &quot;.*|Music|Movies/FullHD&quot;</code></pre><pre><code>So simple, You already know how to use it:$ onedrive -h    Usage: onedrive [OPTION]...    no option    Sync and exit.-m    --monitor    Keep monitoring for local and remote changes.    --resync    Forget the last saved state, perform a full sync.    -v    --verbose    Print more details, useful for debugging.    -h    --help    This help information.</code></pre><p>配置也很简单 onedrive –download 获取授权链接 登录 onedrive的账号就行了 将返回的URL贴到命令行后 火车如果长时间没相应可以直接ctrc+c 后重新运行</p><p>记录一下chmod的用法</p><pre><code>查看linux文件的权限：ls -l 文件名称查看linux文件夹的权限：ls -ld 文件夹名称（所在目录）修改文件及文件夹权限：sudo chmod -（代表类型）×××（所有者）×××（组用户）×××（其他用户）常用修改权限的命令：sudo chmod 600 ××× （只有所有者有读和写的权限）sudo chmod 644 ××× （所有者有读和写的权限，组用户只有读的权限）sudo chmod 700 ××× （只有所有者有读和写以及执行的权限）sudo chmod 666 ××× （每个人都有读和写的权限）sudo chmod 777 ××× （每个人都有读和写以及执行的权限）查看linux文件的权限：ls -l 文件名称查看linux文件夹的权限：ls -ld 文件夹名称（所在目录）修改文件及文件夹权限：sudo chmod -（代表类型）×××（所有者）×××（组用户）×××（其他用户）常用修改权限的命令：sudo chmod 600 ××× （只有所有者有读和写的权限）sudo chmod 644 ××× （所有者有读和写的权限，组用户只有读的权限）sudo chmod 700 ××× （只有所有者有读和写以及执行的权限）sudo chmod 666 ××× （每个人都有读和写的权限）sudo chmod 777 ××× （每个人都有读和写以及执行的权限）</code></pre><h3 id="aria-下载"><a href="#aria-下载" class="headerlink" title="aria 下载"></a>aria 下载</h3><pre><code>aria2c -c -s10 -k1M -x16 --enable-rpc=false -o &#39;要保存的文件名&#39; --header &quot;User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/61.0.3163.100 Safari/537.36&quot; --header &quot;Cookie: 你的cookie内容&quot; &quot;文件的下载地址&quot;使用cookie 来实现百度云下载,想一些网站会识别cookie判断是否能下载</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>on-my-zsh</title>
      <link href="/37058318.html"/>
      <url>/37058318.html</url>
      
        <content type="html"><![CDATA[<p>补充 添加 找到 <code>~/.zshrc</code> 有一行 <code>plugins=(git)</code>，想加什么插件就把名字放里面就是了，</p><p>1.) autojump</p><p>按照<a href="https://github.com/wting/autojump" target="_blank" rel="noopener">官方文档</a>介绍，需要使用如下命令安装，而不是一些博客中的介绍</p><p>~/.oh-my-zsh/plugins/autojump/autojump.plugin.zsh</p><p>安装好之后，记得<code>source ~/.zshrc</code>，然后你就可以通过<code>j+目录名</code>快速进行目录跳转。支持目录名的模糊匹配和自动补全。</p><ul><li><code>j -stat</code>：可以查看历史路径库</li></ul><p>2.) extract</p><p>解压文件用的，所有的压缩文件，都可以直接<code>x filename</code>，不用记忆参数</p><p>当然，如果你想要用<code>tar</code>命令，可以使用<code>tar -</code>加<code>tab</code>键，zsh会列出参数的含义。</p><hr><p>使用zsh 提交命令行输入的输入效率</p><pre><code># 安装 Zshsudo apt install zsh# 将 Zsh 设置为默认 Shellchsh -s /bin/zsh# 可以通过 echo $SHELL 查看当前默认的 Shell，如果没有改为 /bin/zsh，那么需要重启 Shell。</code></pre><h2 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h2><pre><code>sudo apt install git</code></pre><h2 id="9-zsh-也可以安装fish"><a href="#9-zsh-也可以安装fish" class="headerlink" title="9. zsh(也可以安装fish)"></a>9. zsh(也可以安装fish)</h2><pre><code>sudo apt install zsh# 切换到zshchsh -s /bin/zsh</code></pre><p>安装<code>Oh-my-zsh</code></p><pre><code>sh -c &quot;$(wget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)&quot;</code></pre><p>安装插件<code>highlight</code>，高亮语法</p><pre><code>cd ~/.oh-my-zsh/custom/pluginsgit clone git://github.com/zsh-users/zsh-syntax-highlighting.git</code></pre><p>在<code>Oh-my-zsh</code>的配置文件中<code>~/.zshrc</code>中添加插件</p><pre><code>plugins=( [plugins...] zsh-syntax-highlighting)</code></pre><p>最后使配置生效</p><pre><code>source ~/.zshrc</code></pre><p>~/.oh-my-zsh</p><p>配置文件 ~/.zshrc</p><p>plugins=(git</p><p> autojump</p><p> zsh-syntax-highlighting<br>​ )</p><p>#</p><h2 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a>光标移动</h2><table><thead><tr><th align="center">快捷键</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><code>Ctrl + a</code></td><td align="center">移动光标到行首</td></tr><tr><td align="center"><code>Ctrl + e</code></td><td align="center">移动光标到行尾</td></tr><tr><td align="center"><code>Alt + b</code></td><td align="center">移动光标后退一个单词（词首）</td></tr><tr><td align="center"><code>Alt + f</code></td><td align="center">移动光标前进一个单词（词首）</td></tr><tr><td align="center"><code>Ctrl + f</code></td><td align="center">光标前进一个字母</td></tr><tr><td align="center"><code>Ctrl + b</code></td><td align="center">光标后退一个字母</td></tr><tr><td align="center"><code>Ctrl + xx</code></td><td align="center">当前位置与行首之间光标切换</td></tr></tbody></table><h2 id="剪切粘贴"><a href="#剪切粘贴" class="headerlink" title="剪切粘贴"></a>剪切粘贴</h2><table><thead><tr><th align="center">快捷键</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><code>Ctrl + k</code></td><td align="center">删除从光标到行尾</td></tr><tr><td align="center"><code>Ctrl + u</code></td><td align="center">删除从光标到行首</td></tr><tr><td align="center"><code>Ctrl + w</code></td><td align="center">从光标向前删除一个单词</td></tr><tr><td align="center"><code>Alt + d</code></td><td align="center">从光标向后删除一个单词</td></tr><tr><td align="center"><code>Ctrl + d</code></td><td align="center">删除光标下一个字母</td></tr><tr><td align="center"><code>Ctrl + h</code></td><td align="center">删除光标前一个字母</td></tr><tr><td align="center"><code>Alt + t</code></td><td align="center">swap(当前单词, 上一个单词)</td></tr><tr><td align="center"><code>Ctrl + t</code></td><td align="center">swap(当前字母, 上一个字母)</td></tr><tr><td align="center"><code>Ctrl + y</code></td><td align="center">粘贴上一次删除的文本</td></tr></tbody></table><h1 id="历史命令"><a href="#历史命令" class="headerlink" title="历史命令"></a>历史命令</h1><table><thead><tr><th align="center">快捷键</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><code>Ctrl + r</code></td><td align="center">向后搜索历史命令</td></tr><tr><td align="center"><code>Ctrl + g</code></td><td align="center">退出搜索</td></tr><tr><td align="center"><code>Ctrl + p</code></td><td align="center">历史中上一个命令</td></tr><tr><td align="center"><code>Ctrl + n</code></td><td align="center">历史中下一个命令</td></tr><tr><td align="center"><code>Alt + .</code></td><td align="center">上一个命令的最后一个单词</td></tr></tbody></table><h2 id="终端指令"><a href="#终端指令" class="headerlink" title="终端指令"></a>终端指令</h2><table><thead><tr><th align="center">快捷键</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><code>Ctrl + l</code></td><td align="center">清屏</td></tr><tr><td align="center"><code>Ctrl + s</code></td><td align="center">停止输出（在Zsh中为向前搜索历史命令）</td></tr><tr><td align="center"><code>Ctrl + q</code></td><td align="center">继续输出</td></tr><tr><td align="center"><code>Ctrl + c</code></td><td align="center">终止当前命令</td></tr><tr><td align="center"><code>Ctrl + z</code></td><td align="center">挂起当前命令</td></tr><tr><td align="center"><code>Ctrl + d</code></td><td align="center">结束输入（产生一个EOF）</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
            <tag> zsh </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu下 intellj idea maven下载</title>
      <link href="/3350959125.html"/>
      <url>/3350959125.html</url>
      
        <content type="html"><![CDATA[<p>opt/apache-maven-3.6.0/bin/mvn dependency:resolve -Dclassifier=sources</p><p>直接使用本机自己的maven 该问题应该是idea 调用 maven出来问题</p><pre><code>iptables -A INPUT -p tcp --dport 3306 -j ACCEPT</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
            <tag> intellj </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo常见命令</title>
      <link href="/3173742102.html"/>
      <url>/3173742102.html</url>
      
        <content type="html"><![CDATA[<p>npm install hexo-generator-feed –save 生成 RSS组件</p><p>npm install hexo-wordcount –save 统计字数</p><p>npm install hexo-deployer-git –save git 出现 error deployer not found:git 的错误处理</p><p>留言部分的多说和畅眼都有自己的问题不是很好用 hexo中的这个valine 第三方留言还是比较稳定比gtiment也要好</p><ol><li>npm install leancloud-storage –save # Install leancloud’s js-sdk</li><li>npm install valine –save</li></ol><p>hexot添加valine留言系统,之前的留言系统包括多说,畅言都有一部分问题很不好用,valine算比较好用而且好操作的的</p><p><a href="https://valine.js.org/hexo.html" target="_blank" rel="noopener">hexot添加valine留言</a></p><p>hexo clean &amp;&amp; hexo d -g` 部署和清理缓存</p><p>hexo new <em>** “标题名”</em> 是保存地址 会自动生成一个markdown文件</p><p>开头是</p><pre><code>---title: hexo常见命令date: 2019-04-13 12:37:35tags: hexo---</code></pre><pre><code>YAMLException: can not read a block mapping entry; a multiline key may not be an implicit key at    出现上述问题是YAML格式:后面是必须要有空格的title: Hexohexo new page *** 可以生成对应的页面 如about pags</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu优化--smb局域网分享</title>
      <link href="/2693474031.html"/>
      <url>/2693474031.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/root0/p/9275118.html" target="_blank" rel="noopener">samba实现文件共享</a></p><p>Linux系统与Windows系统之间共享文件资源，小文件可以使用lrzsz，大文件可以使用samba。</p><p>Ubuntu是有自带的文件分享的 分享后</p><p>我是在vmvare上装了Windows的虚拟机经常需要两个局域网上共享文件 用Linux的分享手机也可以使用samba 协议的APP访问局域网 内的文件，还可以正常流媒体在线播放还是比较方便的的</p><p>netstat -an | grep 3306</p><p>tcp 0 0 0.0.0.0:3306 0.0.0.0:* LISTEN<br>tcp 0 0 127.0.0.1:3306 127.0.0.1:52102 ESTABLISHED<br>tcp 0 0 127.0.0.1:3306 127.0.0.1:52104 ESTABLISHED<br>tcp6 0 0 127.0.0.1:52104 127.0.0.1:3306 ESTABLISHED<br>tcp6 0 0 127.0.0.1:52102 127.0.0.1:3306 ESTABLISHED</p><p>bind-address = 127.0.0.1 原本的是这样的</p><p>bind-addres = 0.0.0.0 后面有人说需要 其实主要上面的这个的就行了</p><p>/etc/mysql/mysql.conf.d/mysqld.cnf</p><pre><code>iptables -A INPUT -p tcp --dport 3306 -j ACCEPT</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu折腾--优化wine 微信小黑框处理</title>
      <link href="/3419088444.html"/>
      <url>/3419088444.html</url>
      
        <content type="html"><![CDATA[<h3 id="wine-微信小黑框处理-chatcontactmenu"><a href="#wine-微信小黑框处理-chatcontactmenu" class="headerlink" title="wine 微信小黑框处理 chatcontactmenu"></a>wine 微信小黑框处理 chatcontactmenu</h3><p>wmctrl -l -G -p -x 显示当前窗口</p><p>xdotool windowunmap 0x0340000a 异常对应的窗口</p><p>0x01a0000a 0 2415 0 0 1920 1080 desktop_window.Nautilus lee-XPS 桌面<br>0x02400084 0 2992 2734 -12 595 434 gedit.Gedit lee-XPS *note (~/桌面) - gedit<br>0x0340000a 0 3200 0 56 1 1 wechat.exe.Wine lee-XPS ChatContactMenu<br>0x0340000c 0 3200 1860 1020 60 60 wechat.exe.Wine lee-XPS<br>0x03400009 0 3200 1220 56 1231 1052 wechat.exe.Wine lee-XPS 微信</p><hr><h3 id="flameshot-的截屏软件"><a href="#flameshot-的截屏软件" class="headerlink" title="flameshot 的截屏软件"></a>flameshot 的截屏软件</h3><p>/usr/bin/flameshot gui<br>gnome-screenshot -ac</p><p>更新 Linux压缩包乱码</p><p>压缩文件乱码的解决方案 指定编码解压</p><pre><code>unzip -O GBK zip  或者unzip -O cp936</code></pre><p>本质问题还是zip格式的缺陷，没有字段标志出文件名的编码格式。ZIP在压缩与解压缩的时候默认使用了系统的本地编码，如windows中文环境下为GBK， 日文 环境下是JIS，linux默认编码为UTF8等；那么在不同系统环境下，只要压缩与解压缩的编码不一致，就会出现乱码。</p><h3 id="构建desktop文件"><a href="#构建desktop文件" class="headerlink" title="构建desktop文件"></a>构建desktop文件</h3><pre><code>[Desktop Entry]Version=1.0Name=Firefox Web BrowserName[ar]=متصفح الويب فَيَرفُكْسName[ast]=Restolador web FirefoxName[bn]=ফায়ারফক্স ওয়েব ব্রাউজারName[ca]=Navegador web FirefoxName[cs]=Firefox Webový prohlížečName[da]=Firefox - internetbrowserName[el]=Περιηγητής FirefoxName[es]=Navegador web FirefoxName[et]=Firefoxi veebibrauserName[fa]=مرورگر اینترنتی FirefoxName[fi]=Firefox-selainName[fr]=Navigateur Web FirefoxName[gl]=Navegador web FirefoxName[he]=דפדפן האינטרנט FirefoxName[hr]=Firefox web preglednikName[hu]=Firefox webböngészőName[it]=Firefox Browser WebName[ja]=Firefox ウェブ・ブラウザName[ko]=Firefox 웹 브라우저Name[ku]=Geroka torê FirefoxName[lt]=Firefox interneto naršyklėName[nb]=Firefox NettleserName[nl]=Firefox webbrowserName[nn]=Firefox NettlesarName[no]=Firefox NettleserName[pl]=Przeglądarka WWW FirefoxName[pt]=Firefox Navegador WebName[pt_BR]=Navegador Web FirefoxName[ro]=Firefox – Navigator InternetName[ru]=Веб-браузер FirefoxName[sk]=Firefox - internetový prehliadačName[sl]=Firefox spletni brskalnikName[sv]=Firefox webbläsareName[tr]=Firefox Web TarayıcısıName[ug]=Firefox توركۆرگۈName[uk]=Веб-браузер FirefoxName[vi]=Trình duyệt web FirefoxName[zh_CN]=Firefox 网络浏览器Name[zh_TW]=Firefox 網路瀏覽器Comment=Browse the World Wide WebComment[ar]=تصفح الشبكة العنكبوتية العالميةComment[ast]=Restola pela RedeComment[bn]=ইন্টারনেট ব্রাউজ করুনComment[ca]=Navegueu per la webComment[cs]=Prohlížení stránek World Wide WebuComment[da]=Surf på internettetComment[de]=Im Internet surfenComment[el]=Μπορείτε να περιηγηθείτε στο διαδίκτυο (Web)Comment[es]=Navegue por la webComment[et]=Lehitse veebiComment[fa]=صفحات شبکه جهانی اینترنت را مرور نماییدComment[fi]=Selaa Internetin WWW-sivujaComment[fr]=Naviguer sur le WebComment[gl]=Navegar pola redeComment[he]=גלישה ברחבי האינטרנטComment[hr]=Pretražite webComment[hu]=A világháló böngészéseComment[it]=Esplora il webComment[ja]=ウェブを閲覧しますComment[ko]=웹을 돌아 다닙니다Comment[ku]=Li torê bigereComment[lt]=Naršykite interneteComment[nb]=Surf på nettetComment[nl]=Verken het internetComment[nn]=Surf på nettetComment[no]=Surf på nettetComment[pl]=Przeglądanie stron WWWComment[pt]=Navegue na InternetComment[pt_BR]=Navegue na InternetComment[ro]=Navigați pe InternetComment[ru]=Доступ в ИнтернетComment[sk]=Prehliadanie internetuComment[sl]=Brskajte po spletuComment[sv]=Surfa på webbenComment[tr]=İnternet&#39;te GezininComment[ug]=دۇنيادىكى توربەتلەرنى كۆرگىلى بولىدۇComment[uk]=Перегляд сторінок ІнтернетуComment[vi]=Để duyệt các trang webComment[zh_CN]=浏览互联网Comment[zh_TW]=瀏覽網際網路GenericName=Web BrowserGenericName[ar]=متصفح ويبGenericName[ast]=Restolador WebGenericName[bn]=ওয়েব ব্রাউজারGenericName[ca]=Navegador webGenericName[cs]=Webový prohlížečGenericName[da]=WebbrowserGenericName[el]=Περιηγητής διαδικτύουGenericName[es]=Navegador webGenericName[et]=VeebibrauserGenericName[fa]=مرورگر اینترنتیGenericName[fi]=WWW-selainGenericName[fr]=Navigateur WebGenericName[gl]=Navegador WebGenericName[he]=דפדפן אינטרנטGenericName[hr]=Web preglednikGenericName[hu]=WebböngészőGenericName[it]=Browser webGenericName[ja]=ウェブ・ブラウザGenericName[ko]=웹 브라우저GenericName[ku]=Geroka torêGenericName[lt]=Interneto naršyklėGenericName[nb]=NettleserGenericName[nl]=WebbrowserGenericName[nn]=NettlesarGenericName[no]=NettleserGenericName[pl]=Przeglądarka WWWGenericName[pt]=Navegador WebGenericName[pt_BR]=Navegador WebGenericName[ro]=Navigator InternetGenericName[ru]=Веб-браузерGenericName[sk]=Internetový prehliadačGenericName[sl]=Spletni brskalnikGenericName[sv]=WebbläsareGenericName[tr]=Web TarayıcıGenericName[ug]=توركۆرگۈGenericName[uk]=Веб-браузерGenericName[vi]=Trình duyệt WebGenericName[zh_CN]=网络浏览器GenericName[zh_TW]=網路瀏覽器Keywords=Internet;WWW;Browser;Web;ExplorerKeywords[ar]=انترنت;إنترنت;متصفح;ويب;وبKeywords[ast]=Internet;WWW;Restolador;Web;EsploradorKeywords[ca]=Internet;WWW;Navegador;Web;Explorador;ExplorerKeywords[cs]=Internet;WWW;Prohlížeč;Web;ExplorerKeywords[da]=Internet;Internettet;WWW;Browser;Browse;Web;Surf;NettetKeywords[de]=Internet;WWW;Browser;Web;Explorer;Webseite;Site;surfen;online;browsenKeywords[el]=Internet;WWW;Browser;Web;Explorer;Διαδίκτυο;Περιηγητής;Firefox;Φιρεφοχ;ΙντερνετKeywords[es]=Explorador;Internet;WWWKeywords[fi]=Internet;WWW;Browser;Web;Explorer;selain;Internet-selain;internetselain;verkkoselain;netti;surffaaKeywords[fr]=Internet;WWW;Browser;Web;Explorer;Fureteur;Surfer;NavigateurKeywords[he]=דפדפן;אינטרנט;רשת;אתרים;אתר;פיירפוקס;מוזילה;Keywords[hr]=Internet;WWW;preglednik;WebKeywords[hu]=Internet;WWW;Böngésző;Web;Háló;Net;ExplorerKeywords[it]=Internet;WWW;Browser;Web;NavigatoreKeywords[is]=Internet;WWW;Vafri;Vefur;Netvafri;FlakkKeywords[ja]=Internet;WWW;Web;インターネット;ブラウザ;ウェブ;エクスプローラKeywords[nb]=Internett;WWW;Nettleser;Explorer;Web;Browser;NettsideKeywords[nl]=Internet;WWW;Browser;Web;Explorer;Verkenner;Website;Surfen;OnlineKeywords[pt]=Internet;WWW;Browser;Web;Explorador;NavegadorKeywords[pt_BR]=Internet;WWW;Browser;Web;Explorador;NavegadorKeywords[ru]=Internet;WWW;Browser;Web;Explorer;интернет;браузер;веб;файрфокс;огнелисKeywords[sk]=Internet;WWW;Prehliadač;Web;ExplorerKeywords[sl]=Internet;WWW;Browser;Web;Explorer;Brskalnik;SpletKeywords[tr]=İnternet;WWW;Tarayıcı;Web;Gezgin;Web sitesi;Site;sörf;çevrimiçi;taraKeywords[uk]=Internet;WWW;Browser;Web;Explorer;Інтернет;мережа;переглядач;оглядач;браузер;веб;файрфокс;вогнелис;переглядKeywords[vi]=Internet;WWW;Browser;Web;Explorer;Trình duyệt;Trang webKeywords[zh_CN]=Internet;WWW;Browser;Web;Explorer;网页;浏览;上网;火狐;Firefox;ff;互联网;网站;Keywords[zh_TW]=Internet;WWW;Browser;Web;Explorer;網際網路;網路;瀏覽器;上網;網頁;火狐Exec=firefox %uTerminal=falseX-MultipleArgs=falseType=ApplicationIcon=firefoxCategories=GNOME;GTK;Network;WebBrowser;MimeType=text/html;text/xml;application/xhtml+xml;application/xml;application/rss+xml;application/rdf+xml;image/gif;image/jpeg;image/png;x-scheme-handler/http;x-scheme-handler/https;x-scheme-handler/ftp;x-scheme-handler/chrome;video/webm;application/x-xpinstall;StartupNotify=trueActions=new-window;new-private-window;[Desktop Action new-window]Name=Open a New WindowName[ar]=افتح نافذة جديدةName[ast]=Abrir una ventana nuevaName[bn]=Abrir una ventana nuevaName[ca]=Obre una finestra novaName[cs]=Otevřít nové oknoName[da]=Åbn et nyt vindueName[de]=Ein neues Fenster öffnenName[el]=Νέο παράθυροName[es]=Abrir una ventana nuevaName[fi]=Avaa uusi ikkunaName[fr]=Ouvrir une nouvelle fenêtreName[gl]=Abrir unha nova xanelaName[he]=פתיחת חלון חדשName[hr]=Otvori novi prozorName[hu]=Új ablak nyitásaName[it]=Apri una nuova finestraName[ja]=新しいウィンドウを開くName[ko]=새 창 열기Name[ku]=Paceyeke nû vekeName[lt]=Atverti naują langąName[nb]=Åpne et nytt vinduName[nl]=Nieuw venster openenName[pt]=Abrir nova janelaName[pt_BR]=Abrir nova janelaName[ro]=Deschide o fereastră nouăName[ru]=Новое окноName[sk]=Otvoriť nové oknoName[sl]=Odpri novo oknoName[sv]=Öppna ett nytt fönsterName[tr]=Yeni pencere açName[ug]=يېڭى كۆزنەك ئېچىشName[uk]=Відкрити нове вікноName[vi]=Mở cửa sổ mớiName[zh_CN]=新建窗口Name[zh_TW]=開啟新視窗Exec=firefox -new-window[Desktop Action new-private-window]Name=Open a New Private WindowName[ar]=افتح نافذة جديدة للتصفح الخاصName[ca]=Obre una finestra nova en mode d&#39;incògnitName[cs]=Otevřít nové anonymní oknoName[de]=Ein neues privates Fenster öffnenName[el]=Νέο ιδιωτικό παράθυροName[es]=Abrir una ventana privada nuevaName[fi]=Avaa uusi yksityinen ikkunaName[fr]=Ouvrir une nouvelle fenêtre de navigation privéeName[he]=פתיחת חלון גלישה פרטית חדשName[hu]=Új privát ablak nyitásaName[it]=Apri una nuova finestra anonimaName[nb]=Åpne et nytt privat vinduName[ru]=Новое приватное окноName[sl]=Odpri novo okno zasebnega brskanjaName[sv]=Öppna ett nytt privat fönsterName[tr]=Yeni bir pencere açName[uk]=Відкрити нове вікно у потайливому режиміName[zh_TW]=開啟新隱私瀏覽視窗Exec=/opt/firefox/firefox# Exec=/home/leek/soft/firefox/firefox %u# Exec=/home/leek/soft/firefox/firefox -new-window# Exec=/home/leek/soft/firefox/firefox -private-window</code></pre><p>Firefox.com 官网下载国际版 解压后可直接运行Firefox 文件夹下的firefox</p><p>bin 添加对应的脚步文件 打开</p><ul><li>ubuntu 安装开机界面</li><li>Linux 下载神器 motrix</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
            <tag> wine </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java实现图片压缩</title>
      <link href="/3632233999.html"/>
      <url>/3632233999.html</url>
      
        <content type="html"><![CDATA[<p>开始时是直接对流进行处理但是会有异常,虽然thumbnailator可以填写<br>，而图片对于现在的很多手机来说，拍摄出来的都是高清图片，分辨率也是相当的高，当然占用的存储空间也就大了,但不同的场景是需要不同的,微信的图片显示就是先显示压缩图然后可以选着看原图</p><pre><code>&lt;!--图片压缩--&gt;   &lt;dependency&gt;     &lt;groupId&gt;net.coobird&lt;/groupId&gt;     &lt;artifactId&gt;thumbnailator&lt;/artifactId&gt;     &lt;version&gt;0.4.8&lt;/version&gt;   &lt;/dependency&gt;</code></pre><pre><code>  // 由于直接对流进行操作导致问题 所以是保存文件到本地后压缩        File fileSize2 = new File(path_store + &quot;/size2/&quot; + &quot;m2&quot; + fileName);        File fileSize3 = new File(path_store + &quot;/small/&quot; + &quot;m3&quot; + fileName);        File fileSize4 = new File(path_store + &quot;/size4/&quot; + &quot;m4&quot; + fileName);        String size2 = fileSize2.toString();        String size3 = fileSize3.toString();        String size4 = fileSize4.toString();//通过session保存值         request.getSession().setAttribute(&quot;size2&quot;,size2);        request.getSession().setAttribute(&quot;size3&quot;,size3);        request.getSession().setAttribute(&quot;size4&quot;,size4);        Thumbnails.of(st).scale(0.2f).toFile(fileSize2);        Thumbnails.of(st).scale(0.5f).toFile(fileSize3);        Thumbnails.of(st).scale(1f).toFile(fileSize4);        String rimage = &quot;img/product/product/&quot; + fileName;        request.getSession().setAttribute(&quot;rimge&quot;, rimage);        //删除临时文件        item.delete();        //  response.getWriter().write(&quot;success&quot;+rimage);</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ajax运用的归纳整理</title>
      <link href="/6f432c85.html"/>
      <url>/6f432c85.html</url>
      
        <content type="html"><![CDATA[<p>Ajax请求包括常见三种 本人日常使用是完整版,但是最近发现ajax中发post请求也是很快的而且很方便,将多种方法都试一遍线顺便整理一下</p><ol><li>| GET请求 | <code>$.get(url,[data],[callback],[type])</code> |</li><li>| POST请求 | <code>$.post(url,[data],[callback],[type])</code> |</li><li>| AJAX请求 | `$.ajax([settings])</li></ol><h1 id="POST请求语法格式"><a href="#POST请求语法格式" class="headerlink" title="POST请求语法格式"></a>POST请求语法格式</h1><p>$.post(url, [data], [callback], [type])<br>其中，参数说明如下：<br>| 参数| 说明 |<br>| url| 请求的服务器端url地址 |<br>|data|发送给服务器端的请求参数，格式可以是key=value也可以是js对象|<br>|callback| 当请求成功后的回掉函数，可以在函数体中编写我们的逻辑代码|<br>|type| 预期的返回数据的类型，取值可以是 xml, html, script, json, text, _defaul等</p><pre><code>&quot;user/login&quot;,//请求地址   $(&quot;#loginForm&quot;).serialize(),//表单所有数据   function (resultInfo) {      if(resultInfo.flag){          //登录成功，跳转到首页         location.href=&quot;index.html&quot;;      }else{          //失败，显示消息                           $(&quot;#errorMsg&quot;).text(resultInfo.errorMsg);      } },   &quot;json&quot;);$(&quot;#errorMsg&quot;).text(&quot;请输入用户名或密码&quot;);</code></pre><p>现在感觉发post请求,同这个会更简单且更加清晰,只需要url,[data],[callback],[type]),清晰明了,各个部分以’,’分开,</p><h1 id="AJAX请求"><a href="#AJAX请求" class="headerlink" title="AJAX请求"></a>AJAX请求</h1><p>我之前是完全的ajax请求格式太多但是功能也更加全面</p><p><a href="http://www.w3school.com.cn/jquery/ajax_ajax.asp" target="_blank" rel="noopener">引用自w3school jQuery ajax</a></p><pre><code> 类型：Object    可选。AJAX 请求设置。所有选项都是可选的。async    类型：Boolean    默认值: true。默认设置下，所有请求均为异步请求。如果需要发送同步请求，请将此选项设置为 false。    注意，同步请求将锁住浏览器，用户其它操作必须等待请求完成才可以执行。beforeSend(XHR)    类型：Function    发送请求前可修改 XMLHttpRequest 对象的函数，如添加自定义 HTTP 头。    XMLHttpRequest 对象是唯一的参数。    这是一个 Ajax 事件。如果返回 false 可以取消本次 ajax 请求。cache    类型：Boolean    默认值: true，dataType 为 script 和 jsonp 时默认为 false。设置为 false 将不缓存此页面。    jQuery 1.2 新功能。complete(XHR, TS)    类型：Function    请求完成后回调函数 (请求成功或失败之后均调用)。    参数： XMLHttpRequest 对象和一个描述请求类型的字符串。    这是一个 Ajax 事件。contentType    类型：String    默认值: &quot;application/x-www-form-urlencoded&quot;。发送信息至服务器时内容编码类型。    默认值适合大多数情况。如果你明确地传递了一个 content-type 给 $.ajax() 那么它必定会发送给服务器（即使没有数据要发送）。context    类型：Object    这个对象用于设置 Ajax 相关回调函数的上下文。也就是说，让回调函数内 this 指向这个对象（如果不设定这个参数，那么 this 就指向调用本次 AJAX 请求时传递的 options 参数）。比如指定一个 DOM 元素作为 context 参数，这样就设置了 success 回调函数的上下文为这个 DOM 元素。$.ajax({ url: &quot;test.html&quot;, context: document.body, success: function(){        $(this).addClass(&quot;done&quot;);      }});</code></pre><p>route</p><pre><code>  var cid=getParameter(&quot;cid&quot;)    $.ajax({        url:&quot;/route/showPage&quot;,//请求路径        data:{&quot;currentPage&quot;:currentPage,              &quot;cid&quot;:cid},//发送参数        dataType:&quot;json&quot;, //接收类型确认        success:function (res) {            toShowRouteDetail(res)        }    })}ShowRoute(1)//显示旅游线路function toShowRouteDetail(res)  {    $(&quot;#show2Route&quot;).empty()    for(var i=0;i&lt;res.listRoute.length;i++){        var temp=$(&quot;&lt;li&gt;\n&quot; +            &quot;                            &lt;div class=\&quot;img\&quot;&gt;&lt;img width=&#39;290px&#39; src=\&quot;&quot;+res.listRoute[i].rimage+&quot;\&quot; alt=\&quot;\&quot;&gt;&lt;/div&gt;\n&quot; +            &quot;                            &lt;div class=\&quot;text1\&quot;&gt;\n&quot; +            &quot;                                &lt;p&gt;&quot;+res.listRoute[i].rname+&quot;&lt;/p&gt;\n&quot; +            &quot;                                &lt;br/&gt;\n&quot; +            &quot;                                &lt;p&gt;&quot;+res.listRoute[i].routeIntroduce+&quot;&lt;/p&gt;\n&quot; +            &quot;                            &lt;/div&gt;\n&quot; +            &quot;                            &lt;div class=\&quot;price\&quot;&gt;\n&quot; +            &quot;                                &lt;p class=\&quot;price_num\&quot;&gt;\n&quot; +            &quot;                                    &lt;span&gt;&amp;yen;&lt;/span&gt;\n&quot; +            &quot;                                    &lt;span&gt;&quot;+res.listRoute[i].price+&quot;&lt;/span&gt;\n&quot; +            &quot;                                    &lt;span&gt;起&lt;/span&gt;\n&quot; +            &quot;                                &lt;/p&gt;\n&quot; +            &quot;                                &lt;p&gt;&lt;a href=\&quot;/route_detail.html?rid=&quot;+res.listRoute[i].rid+&quot;\&quot;&gt;查看详情&lt;/a&gt;&lt;/p&gt;\n&quot; +            &quot;                            &lt;/div&gt;\n&quot; +            &quot;                        &lt;/li&gt;&quot;);        $(&quot;#show2Route&quot;).append(temp)    }</code></pre><h1 id="GET请求"><a href="#GET请求" class="headerlink" title="GET请求"></a>GET请求</h1><p>$.get(url,[data],[callback],[type data<br>方式一：key=value&amp;key=value<br>方式二：{key:value,key:value…}<br>| callback | 回调函数：当请求成功后触发的函数 |<br>|type|返回参数类型：取值可以是xml,html,script, json,text,_defaul等 |</p><pre><code>ajaxGetFn() {//Ajax的GET请求：    //方式一：key=value&amp;key=value形式传值    // $.get(&quot;/getDemo&quot;,&quot;name=&#39;张三&#39;&amp;age=18&quot;,function (res) {    //     //处理响应数据,并在浏览器上显示    //     alert(res);    // },&quot;text&quot;);    //方式二：{key:value,key:value}形式传值    $.get(&quot;/getDemo&quot;,{&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:18},function   (res) {        //处理响应数据        alert(res);    },&quot;text&quot;);}</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>S6新特性 和VUE的个人理解</title>
      <link href="/4288700677.html"/>
      <url>/4288700677.html</url>
      
        <content type="html"><![CDATA[<p>es6新特性<br><a href="https://www.jianshu.com/p/b3f3afcae230/" target="_blank" rel="noopener">ES6新特性介绍</a><br><a href="http://es6.ruanyifeng.com/?search=reduce&x=0&y=0#README" target="_blank" rel="noopener">阮一峰的翻译的ECMAScript 6 入门-图书</a></p><pre><code>增加了 const let修饰还有map reduce  indexof的替换者includes包括template(模板字符串（template string）是增强版的字符串，)在模    </code></pre><p>板字符串中嵌入变量，需要将变量名写在${}之中<br>​ 结构{temp.feid}<br>​ array.forEach(v = &gt; console.log(v));箭头表达式<br>​ 反引号 ` 来创建字符串反问号创建字符串<br>​ 美元符号加花括号包裹的变量${vraible}<br>​<br>​ 遍历器（Iterator）遍历的是一种规则数据的部署</p><p>使用for…of循环，遍历某种数据结构时，该循环会自动去寻找Iterator接口。在ES6中，有三类数据结构原生具备Iterator接口：数组、某些类似数组的对象、Set和Map结构。</p><p>S6模块通过export命令显式指定输出的代码，输入时也采用静态命令的形式。<br>​ export xxx from xxx<br>​ import xxxx from xxxx<br>如果只是需要key:value的数据结构，记得使用Map，因为Map有内建的遍历机制。<br>使用import取代require，使用export取代module.exports。这样可以在编译时就完成模块编译，效率要比CommonJS模块高。</p><hr><ul><li><p>// CommonJS模块</p><pre><code>{ stat, exists, readFile }// 等同于let _fs = require(&#39;fs&#39;);let stat = _fs.stat;let exists = _fs.exists;let readfile = _fs.readfile;</code></pre></li><li><p>无序列表// ES6模块</p><pre><code>{ stat, exists, readFile } from &#39;fs&#39;;</code></pre></li></ul><p>vue子模块</p><p>vue是基于MVVM设计的js框架.需要注意子模块和父模块的使用<br>而点vue文件需要在webpack是<br>Data 是将将原本的值以变成了方法一return来实现值处理和返回值 还有<br>保证在其他引用的方法的部分不会随着变化独立性更高</p><p>vue包括vue vue-cli vuex</p><p>而vue是可以<br>首先是是它的生命周期包括create,mount<br>注意<br>在html里面可以用v-if foreach</p><pre><code>el    data    compute    methods    watch包括组件元素vue.componet(&quot;name&quot;,{    template })var a=    ({template:return {{ xx:kkkk }})</code></pre><p>将你输入的值遍历你的值是&lt;里面 :name=”值”&gt;</p><pre><code>&lt;ol&gt;    &lt;!--      现在我们为每个 todo-item 提供 todo 对象      todo 对象是变量，即其内容可以是动态的。      我们也需要为每个组件提供一个“key”，稍后再      作详细解释。    --&gt;    &lt;todo-item      v-for=&quot;item in groceryList&quot;      v-bind:todo=&quot;item&quot;      v-bind:key=&quot;item.id&quot;&gt;    &lt;/todo-item&gt;  &lt;/ol&gt;Vue.component(&#39;todo-item&#39;, {  props: [&#39;todo&#39;],  template: &#39;&lt;li&gt;{{ todo.text }}&lt;/li&gt;&#39;})var app7 = new Vue({  el: &#39;#app-7&#39;,  data: {    groceryList: [      { id: 0, text: &#39;蔬菜&#39; },      { id: 1, text: &#39;奶酪&#39; },      { id: 2, text: &#39;随便其它什么人吃的东西&#39; }    ]  }})</code></pre><p>还包括后面是变量或者表达式没加冒号,后米娜是字符串<br>v-bind 绑定了vue数据不是普通字符串 :xxx 比如class<br>v-on:xxx 绑定事件 @click=””<br>_ dirname 是绝对路径绑定时<br>v-model<br>_直接取值使用(或$是在vue实例中因为vue内部与API冲突<br>./ 可以解释为组件能导入<br>@/是webpack设置的路径别名<br>在外界使用组件时需要注册组件 vueload</p><p>1、父组件可以使用 props 把数据传给子组件。<br>2、子组件可以使用 $emit 触发父组件的自定义事件。</p><p>vm.$emit( event, arg ) //触发当前实例上的事件</p><p>vm.$on( event, fn );//监听event事件后运行 fn；<br><a href="https://www.tangshuang.net/3507.html" target="_blank" rel="noopener">https://www.tangshuang.net/3507.html</a><br>v-bind用于绑定html元素上的attribution 不是双向绑定<br>v-model主要是用在表单元素中，它实现了双向绑定。</p>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> es6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud</title>
      <link href="/2527336709.html"/>
      <url>/2527336709.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://i.loli.net/2018/10/17/5bc6a508557d1.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2018/10/17/5bc6a508557d1.png" alt="eureka"></a><br>补充eureka闭源的消息<br><a href="https://i.loli.net/2018/10/17/5bc6a57753f6b.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2018/10/17/5bc6a57753f6b.png" alt="dubbo与springcloud对比"></a><br>添加dubbo与springcloud对比</p><p>关于<a href="https://bigleek.github.io/#/user/blog/details/da5fd6d8f37943864ac1cc817a90db72" target="_blank" rel="noopener">之前关于SpringBoot的介绍</a>是关于SpringBoot的概述</p><blockquote><p>Spring boot专注于快速、方便集成的单个个体，Spring Cloud是关注全局的服务治理框架；spring boot使用了默认大于配置的理念，很多集成方案已经帮你选择好了，能不配置就不配置，Spring Cloud很大的一部分是基于Spring boot来实现。<a href="https://www.zhihu.com/question/47304987/answer/169239519" target="_blank" rel="noopener">来自纯洁的微笑</a></p></blockquote><p>##SpringCloud<br>官网介绍<br>Spring Cloud为开发人员提供了快速构建分布式系统中一些常见模式的工具（例如配置管理，服务发现，断路器，智能路由，微代理，控制总线，一次性令牌，全局锁定，领导选举，分布式会话，集群状态）用于微服务时各个系统的同步和相互通信确保一致性.</p><p>目前的版本情况<br>| Component | Edgware.SR5 | Finchley.SR1 | Finchley.BUILD-SNAPSHOT |<br>| ————————- | ————– | ————- | ———————– |<br>| spring-cloud-aws | 1.2.3.RELEASE | 2.0.0.RELEASE | 2.0.1.BUILD-SNAPSHOT |<br>| spring-cloud-bus | 1.3.3.RELEASE | 2.0.0.RELEASE | 2.0.1.BUILD-SNAPSHOT |<br>| spring-cloud-cli | 1.4.1.RELEASE | 2.0.0.RELEASE | 2.0.1.BUILD-SNAPSHOT |<br>| spring-cloud-commons | 1.3.5.RELEASE | 2.0.1.RELEASE | 2.0.2.BUILD-SNAPSHOT |<br>| spring-cloud-contract | 1.2.6.RELEASE | 2.0.1.RELEASE | 2.0.2.BUILD-SNAPSHOT |<br>| spring-cloud-config | 1.4.5.RELEASE | 2.0.1.RELEASE | 2.0.2.BUILD-SNAPSHOT |<br>| spring-cloud-netflix | 1.4.6.RELEASE | 2.0.1.RELEASE | 2.0.2.BUILD-SNAPSHOT |<br>| spring-cloud-security | 1.2.3.RELEASE | 2.0.0.RELEASE | 2.0.1.BUILD-SNAPSHOT |<br>| spring-cloud-cloudfoundry | 1.1.2.RELEASE | 2.0.0.RELEASE | 2.0.1.BUILD-SNAPSHOT |<br>| spring-cloud-consul | 1.3.5.RELEASE | 2.0.1.RELEASE | 2.0.2.BUILD-SNAPSHOT |<br>| spring-cloud-sleuth | 1.3.5.RELEASE | 2.0.1.RELEASE | 2.0.2.BUILD-SNAPSHOT |<br>| spring-cloud-stream | Ditmars.SR4 | Elmhurst.SR1 | Elmhurst.BUILD-SNAPSHOT |<br>| spring-cloud-zookeeper | 1.2.2.RELEASE | 2.0.0.RELEASE | 2.0.1.BUILD-SNAPSHOT |<br>| spring-boot | 1.5.16.RELEASE | 2.0.4.RELEASE | 2.0.4.BUILD-SNAPSHOT |<br>| spring-cloud-task | 1.2.3.RELEASE | 2.0.0.RELEASE | 2.0.1.BUILD-SNAPSHOT |<br>| spring-cloud-vault | 1.1.2.RELEASE | 2.0.1.RELEASE | 2.0.2.BUILD-SNAPSHOT |<br>| spring-cloud-gateway | 1.0.2.RELEASE | 2.0.1.RELEASE | 2.0.2.BUILD-SNAPSHOT |<br>| spring-cloud-openfeign | | 2.0.1.RELEASE | 2.0.2.BUILD-SNAPSHOT |<br>| spring-cloud-function | 1.0.1.RELEASE | 1.0.0.RELEASE | 1.0.1.BUILD-SNAPSHOT |</p><h2 id="配置spring微服务"><a href="#配置spring微服务" class="headerlink" title="配置spring微服务"></a>配置spring微服务</h2><p>springcloud是spring提供的一台服务<br>而spring boot是简化配置文件统一版本提高开发效率能快速开启<br>配置信息可以在application.yml中配置类似脚手架<br>也能</p><pre><code>1.@ConfigurationProperties(locations=“classpath:config/user.properties”, prefix=“XXX”)将配置文件导入,2.选择@PropertySource导入外部文件3.@EnableConfigurationProperties这个注解注释调，不让springboot自动配置，使用我们的手动配置</code></pre><p>@ComponentScan(“com.lee.sh.mapper”)添加组件扫描<br>component service controller</p><h2 id="SpringCould认识"><a href="#SpringCould认识" class="headerlink" title="SpringCould认识"></a>SpringCould认识</h2><p>SpringCould中涉及到涉及的组件来自于netflix的eureka ribbon hystrix zuul<br>都是在application.yml上面可以完成,然后在启动器上面要开启,<br>就可以完成 可以实现集群解决访问量大的问题实现master 还是要<strong>辨析eureka和zookeeper的用途差异</strong></p><h3 id="Spring-Cloud-Zookeeper"><a href="#Spring-Cloud-Zookeeper" class="headerlink" title="Spring Cloud Zookeeper"></a>Spring Cloud Zookeeper</h3><p>ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，是Google的Chubby一个开源的实现，是Hadoop和Hbase的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。ZooKeeper的目标就是封装好复杂易出错的关键服务，将简单易用的接口和性能高效、功能稳定的系统提供给用户。</p><h3 id="Netflix-Eureka"><a href="#Netflix-Eureka" class="headerlink" title="Netflix Eureka"></a>Netflix Eureka</h3><p>服务中心，云端服务发现，一个基于 REST 的服务，用于定位服务，以实现云端中间层服务发现和故障转移。这个可是springcloud最牛鼻的小弟，服务中心，任何小弟需要其它小弟支持什么都需要从这里来拿，同样的你有什么独门武功的都赶紧过报道，方便以后其它小弟来调用；它的好处是你不需要直接找各种什么小弟支持，只需要到服务中心来领取，也不需要知道提供支持的其它小弟在哪里，还是几个小弟来支持的，反正拿来用就行，服务中心来保证稳定性和质量。</p><p>情况来说目</p>]]></content>
      
      
      
        <tags>
            
            <tag> springcloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu优化-输入中文和deepin-Win</title>
      <link href="/2878480242.html"/>
      <url>/2878480242.html</url>
      
        <content type="html"><![CDATA[<p>将Deepin-ThunderSpeed ，Deepin-Wechart上在/usr/share/application 完善添加管理员权限</p><p>同时 、vi /etc/sudoers 将对于是sh脚本授予管理员权限</p><p>使用的deepin-wine</p><p>deepin-wine 可以直接使用IDM 目前市面所有的下载工具 Linux可以寥寥无几像　Ｕget XMD　的用过之后还是不行，但是windows版<br>安装和都很不方便,目前只使用 微信和迅雷 但是下载方面还是很慢 最近突然发现手里还珍藏了之前绿色版的IDM 赶紧的试试不错</p><pre><code>Desktop Entry]Name=IdeaIUComment=IdeaIUExec=/home/admin-m/soft/idea2/idea-IU-172.3317.76/bin/idea.shIcon=/home/admin-m/soft/idea2/idea-IU-172.3317.76/bin/idea.pngTerminal=falseType=ApplicationCategories=Application;Development;[Desktop Entry]   每个desktop文件都以这个标签开始，说明这是一个Desktop Entry文件Version = 1.0      标明Desktop Entry的版本（可选）Name = IdeaIU    程序名称（必须），这里以创建一个idea的快捷方式为例GenericName = IdeaIU       程序通用名称（可选）Comment =IdeaIU       程序描述（可选）Exec =       程序的启动命令（必选），可以带参数运行Icon =     设置快捷方式的图标（可选），当Type为Application，此项有效Terminal = false   是否在终端中运行（可选），当Type为Application，此项有效Type = Application   desktop的类型（必选），常见值有“Application”和“Link”Categories = GNOME;Application;Network; //注明在菜单栏中显示的类别（可选）完成   desktop 需要在权限上显示</code></pre><p>不要懒，完成好计划好的 提升效率，多想想法子</p><p>sh wechat下面添加</p><pre><code>export XMODIFIERS=&quot;@im=fcitx&quot;export GTK_IM_MODULE=&quot;fcitx&quot;export QT_IM_MODULE=&quot;fcitx&quot;</code></pre><p>设置开机主题</p><p>针对Ubuntu18 部分通知没有 可以使用 topicons plus 实现wine通知的</p>]]></content>
      
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu安装软件部分</title>
      <link href="/2690029183.html"/>
      <url>/2690029183.html</url>
      
        <content type="html"><![CDATA[<p> 系统安装完后后面肯定就是安装软件，开始是在谷歌中国上安装chrome，之后是安装最新的Firefox，安装是搜狗了，这种跟着晚上的步骤就可以了，同时可以添加host你懂的加速，然后是撤换国内的镜像源提升下载速度，完成后可以安装markdownd的软件，下载uget添加aira的插件，在chrome 和Firefox上安装配套的插件就可以调用uget下载速度反正比浏览器的速度要快的，这里主要如果没配置好的的话浏览器是不能调用uget的<br>1，） 出现 unable connect 这个是uget的解决方案</p><pre><code>原因：缺少uget-integrator，出错在设置uGet为chrome的默认下载插件1 sudo add-apt-repository ppa:slgobinath/uget-chrome-wrapper2 sudo apt update3 sudo apt install uget-chrome-wrapper楼主也遇见了这个问题，经过多方查找发现：2018/5/10更新2018年uGet团队已将uget-chrome-wrapper采用官方插件并重新命名为uget-integrator 因此新的uget-extension插件不再支持uget-chrome-wrapper 解决方案：Ubuntu和Linux Mint1 sudo add-apt-repository ppa:uget-team/ppa2 sudo apt update3 sudo apt install uget-integrator其他Linux1 wget https://raw.githubusercontent.com/ugetdm/ugetintegrator/master/install/linux/install_uget_integrator.sh2 chmod +x install_uget_integrator.sh3 ./install_uget_integrator.sh</code></pre><p>2，）如果是搜狗看不到图标可以使用 在终端收入fcitx 查看启动情况，工开始出现有事搜狗启动异常的情况，要切换我就直接卸载了很多次然后又是安装了一大堆，都是一大堆问题，如果你是和我一样的话可以试试我的方法，先将下载fcitx 然后安装搜狗，必要的话按住Ctrl+h键将有sogou和fcitx的删掉，如果又不显示<br>3，）对于网易云音乐安装是比较简单的 就是会出现不能自动登录的情况，每次都要启动都要登录我是参考这个<a href="https://www.zhihu.com/question/277330447/answer/478510195" target="_blank" rel="noopener">链接</a></p><pre><code>有些用户有登录不能保持的情况（打开需要重新登录），这种情况多半是sudo方法后的后遗症：使得配置文件的权限属于root。网易云音乐配置文件存在于两个地方，正常情况下的权限如下图：~/.config/netease-cloud-music   (~ 代表当前用户的家目录)~/.cache/netease-cloud-music  （这是缓存目录，是可以直接删的）友情提示，如果你没有 ll 命令，可以 ls -al 代替其中fancy是我的用户名，如果你的文件权限是root，那么就需要修改为你可以访问的状态，执行下面的命令就行啦：# 修改文件的所属用户和组，以及权限find ~/.config/netease-cloud-music -exec sudo chown $USER:$USER {} +find ~/.config/netease-cloud-music -exec sudo chmod 755 {} + find ~/.cache/netease-cloud-music  -exec sudo chown $USER:$USER {} +find ~/.cache/netease-cloud-music  -exec sudo chmod 755 {} +</code></pre><p>时候就可以保持登录状态了<br>4，）就是安装deepin-wine了参考了<a href="https://github.com/wszqkzqk/deepin-wine-ubuntu" target="_blank" rel="noopener">这位兄弟</a> 这里<strong>有个地方要主要</strong><br>提供上面的下载链接是有问题的安装时会出现安装包损坏，用下面那个链接我出现安装后点图标没有后面是在 /opt/deepinwine/apps/Deepin-WeChat 这个路径下运行的</p>]]></content>
      
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
            <tag> 软件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>idea配置同步</title>
      <link href="/4293079570.html"/>
      <url>/4293079570.html</url>
      
        <content type="html"><![CDATA[<ol><li><p>项目目录</p><ol><li>.idea 目录和 demo.iml 和我们开发无关，是IDEA工具自己使用的</li><li>out 目录是存储编译后的.class文件</li><li>src 目录是存储我们编写的.java源文件</li><li>右单击模块,show in explorer :快速进入代码所在文件夹</li></ol></li><li><p>常用快捷键</p><ol><li>Alt+Enter 导入包，自动修正代码(重要)</li><li>Ctrl+Y 删除光标所在行</li><li>Ctrl+D 复制光标所在行的内容，插入光标位置下面</li><li>Ctrl+Alt+L 格式化代码 (重要)</li><li>Ctrl+/ 单行注释(记住)</li><li>Ctrl+Shift+/ 选中代码注释，多行注释，再按取消注释(记住)</li><li>Alt+Ins 自动生成代码，toString，get，set等方法</li><li>Alt+Shift+上下箭头 移动当前代码行</li></ol><ul><li>当前用的到的</li></ul><ol><li>psvm: main方法的快捷生成方式</li><li>sout: 输出语句</li><li>fori: for语句</li><li>100.for : for (int i = 0; i &lt; 100; i++)</li></ol></li><li><p>修改快捷键</p><ol><li>在IDEA工具中， Ctrl+空格 的快捷键，可以帮助我们补全代码，但是这个快捷键和Windows中的输入法切换快捷键冲突，需要修改IDEA中的快捷键。</li><li>File-&gt;Settings-&gt;keymap-&gt;Main menu-&gt;code-&gt;Completion-&gt;Basic</li></ol></li><li><p>导入和关闭项目</p><ol><li>关闭IDEA中已经存在的项目， File-&gt;Close Project</li><li>在IDEA的启动界面上，点击 OPEN ，选择项目目录即可</li><li>因为以后大家要看老师的代码,最好专门建立一个文件夹,存放</li></ol></li><li><p>方法</p><ol><li>回顾-方法的定义和调用<ol><li>9*9乘法表</li></ol></li><li>概念:方法也可以称为函数,是完成特定功能的代码块.(25m)</li></ol></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> intellj </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kibana完成的对Elasticsraech的处理</title>
      <link href="/9bad30c2.html"/>
      <url>/9bad30c2.html</url>
      
        <content type="html"><![CDATA[<p>创建索引,然后才能对索引进行映射配置包括映射配置的映射字段,查看映射关系,字段属性的详解<br>PUT demo/_mapping/log<br>{<br>“properties”: {<br> “name”:{<br> “type”:”text”,<br> “index”: true,<br> “store”: true,<br> “analyzer”: “standard”<br> },<br> “images”: {<br> “type”: “keyword”,<br> “index”: “false”<br> },<br> “price”: {<br> “type”: “float”<br> }<br>}<br>}<br>PUT demo<br>{<br>“settings”: {<br> “number_of_replicas”: 1,<br> “number_of_shards”: 5<br>}<br>}<br>POST demo/log<br>{<br>“name”:”王大海”,<br>“images”:”<a href="http://image.leyou.com/12479122.jpg&quot;" target="_blank" rel="noopener">http://image.leyou.com/12479122.jpg&quot;</a>,<br> “price”:2699.00,<br> “hobby”:” 大 桌球 “<br>}<br>GET _search<br>{<br>“query”: {<br> “match_all”: {}<br>}<br>}<br>GET demo/_mapping</p>]]></content>
      
      
      
        <tags>
            
            <tag> kibana </tag>
            
            <tag> elasticsraech </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring 整合回顾</title>
      <link href="/857262000000000.html"/>
      <url>/857262000000000.html</url>
      
        <content type="html"><![CDATA[<h1 id="spring-整合回顾"><a href="#spring-整合回顾" class="headerlink" title="spring 整合回顾"></a>spring 整合回顾</h1><p>注意spring的对bean的管理必须是建立在你声明的情况下,不然是不会管理的,还有针对配置文件必须要将给类使用也是必须要注解声明<br>在spring整合中要注意包括<br>webapp下的web,xml需要配置</p><pre><code>dispatch 服务启动时要跟着启动拦截器保证你拦截到.do或者其他的值(在springmvc配置文件中)中文乱码确保能读取spring-xxx.xml的这类文件</code></pre><p>!!配置监听器过程启动时启动ioc容器!!</p><p>将重要的文件什么会员才能下载的jsp文件都需要放在WEB-INF下面,确保能完成,还有一部分静态资源可以放在static文件夹下面,html的话可以放在主路径下面,</p><p>然后就是核心配置文件的配置包括<br>resource下面spring核心配置文件 注入DataSource bean<br>开启配置文件扫描</p><p>spring_MVC</p><pre><code>配置文件:开启扫描 原本是在WEB-INF下面现在是都放在web下面注解开启   配置拦截路径和指向哪里 .jsp 还有静态文件全部放在controller下开启restcontroller respestMapping&lt;!--重要别忘了解决静态资源被拦截的问题--&gt;&lt;mvc:default-servlet-handler/&gt;    转换器啊cover    &lt;mvc:annotation-driven&gt;    &lt;mvc:message-converters&gt;        &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt;            &lt;constructor-arg name=&quot;defaultCharset&quot; value=&quot;UTF-8&quot;/&gt;        &lt;/bean&gt;    &lt;/mvc:message-converters&gt;&lt;/mvc:annotation-driven&gt;</code></pre><p>mybatis</p><pre><code>导入数据库连接池的bean 开启包扫描 注解开启   注解开发扫描mybatis sql的文件 sql必须要1),名字和接口名一样        2),@paremater提供        3).对象里面还有对象的复杂模型        4).</code></pre><p>!! 配置基包!!</p><pre><code>mybatis导入插件&lt;plugins&gt;    &lt;plugin interceptor=&quot;com.github.pagehelper.PageInterceptor&quot;/&gt;    &lt;plugin interceptor=&quot;com.github.abel533.mapperhelper.MapperInterceptor&quot;&gt;        &lt;!--指定主键自增回写方法,默认值MYSQL,详细说明请看文档 --&gt;        &lt;property name=&quot;IDENTITY&quot; value=&quot;MYSQL&quot; /&gt;        &lt;!--通用Mapper接口，多个通用接口用逗号隔开 --&gt;        &lt;property name=&quot;mappers&quot; value=&quot;com.github.abel533.mapper.Mapper&quot; /&gt;    &lt;/plugin&gt;    &lt;/plugins&gt;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot搭建</title>
      <link href="/1278275595.html"/>
      <url>/1278275595.html</url>
      
        <content type="html"><![CDATA[<p>Spring将很多魔法带入了Spring应用程序的开发之中，其中最重要的是以下四个核心。<br><a href="http://tengj.top/2017/02/26/springboot1/" target="_blank" rel="noopener">Spring Boot干货系列</a><br>这位博主上面有不少干货</p><ul><li>自动配置：针对很多Spring应用程序常见的应用功能，Spring Boot能自动提供相关配置</li><li>起步依赖：告诉Spring Boot需要什么功能，它就能引入需要的库。</li><li>命令行界面：这是Spring Boot的可选特性，借此你只需写代码就能完成完整的应用程序，无需传统项目构建。</li><li>Actuator：让你能够深入运行中的Spring Boot应用程序，一探究竟。<br>详细的我们就不展开，等你爱上后自然会去深入的了解，后续章节我们会一一展开介绍。接下来让我们开搞吧。我已经迫不及待的要尝尝Spring Boot的味道了</li></ul><p>现在就将我把问题记录一下</p><p>1).报missing servletwebServerFactory bean</p><p><a href="https://i.loli.net/2018/09/26/5bab642b9f157.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2018/09/26/5bab642b9f157.png" alt="报missing servletwebServerFactory bean"></a><br>是我将pom.xml配置文件打乱了我的文件,开始以为是技术论坛中大家常说的应用入口类缺少@SpringBootApplication标注，或者是Spring bean缺少@EnableAutoConfiguration标注等问题。maven的依赖问题没弄好.有冲突导致的问题</p><p>2.)配置properties时IDEA报错</p><p><a href="https://i.loli.net/2018/09/26/5bab65ec7c3dd.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2018/09/26/5bab65ec7c3dd.png" alt="配置properties时IDEA报错"></a><br>这个由于idea预先读取配置文件中未出现前缀为jdbc的所以一直报错,且默认读取application.ym;(properties),要解决只能通过</p><p>1.@ConfigurationProperties(locations=”classpath:config/user.properties”, prefix=”XXX”)将配置文件导入,<br>2.选择@PropertySource导入外部文件<br>3.@EnableConfigurationProperties这个注解注释调，不让springboot自动配置，使用我们的手动配置</p>]]></content>
      
      
      
        <tags>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springAOP使用动态代理的简单实现</title>
      <link href="/2810139133.html"/>
      <url>/2810139133.html</url>
      
        <content type="html"><![CDATA[<p>动态代理以及.Cglib动态代理通过动态代理和cglib来理解spring的AOP(Aspect Orient Programing)动态</p><hr><p>动态代理以及.Cglib动态代理<br>通过动态代理和cglib来理解spring的AOP(Aspect Orient Programing)动态代理是通过JDK实现了反射是<br>–出现的</p><hr><p>1). 代理设计模式：为其他对象提供一种代理以控制对这个对象的访问。</p><ol><li><p>类加载器</p><ol><li>概述<ol><li>JDK 提供的代码.<ol><li>运行时代码. 引导类加载器<ol><li>扩展代码. 扩展类加载器</li><li>自己编写的代码.（以及第三方包) 应用类加载器</li></ol></li></ol></li><li>三种类加载器<ol><li>引导类加载器（Bootstrap ClassLoader）<ol><li>负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类</li></ol></li><li>扩展类加载器（Extension ClassLoader）<ol><li>负责加载java平台中扩展功能的一些jar包，包括$JAVA_HOME中jre/lib/*.jar（jre/lib/ext)</li></ol></li><li>应用类加载器：（Application ClassLoader）<ol><li>加载编写的代码</li></ol></li></ol></li><li>继承关系<ol><li>引导类加载器由C++实现，不是ClassLoader子类（属于JVM的一部分）</li><li>扩展类加载器是引导类加载器子类</li><li>应用类加载器是扩展类加载器子类</li></ol></li><li>双亲委托机制: 一个class文件只会加载一次，在内存有且只有一个Class对象<ol><li>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的加载器都是如此，因此所有的类加载请求都会传给顶层的启动类加载器</li><li>只有当父加载器反馈自己无法完成该加载请求（该加载器的搜索范围中没有找到对应的类）时，子加载器才会尝试自己去加载。</li></ol></li></ol></li></ol></li><li><p>动态代理</p><ol><li>在运行时动态的创建代理类对象（无需定义一个代理类）<ol><li>java动态代理机制以巧妙的方式实现了代理模式的设计理念</li><li>作用：在被调用方法时，对委托者（被代理对象）进行 拦截和控制</li><li></li></ol></li></ol></li><li><p>结构</p><ol><li>代理类对象 proxy （本质是一个匿名类对象）</li><li>委托类对象（被代理的对象）<ol><li>接口（必须要有），被拦截的是接口中的方法</li></ol></li></ol></li><li><p>代码含义</p><ol><li>Proxy.newProxyInstance(loader, interfaces, new InvocationHandler(){}）；<ol><li>参数loader：代理类对象是运行时动态创建的，因为代理类在代码中并没有定义，需要在运行时动态加载，故需要类加载器（和被代理类加载器一样即可）</li><li>参数interfaces：接口用来动态的创建代理类，本质上这个代理类（匿名类）是接口的实现类，拥有接口中的所有方法（这个参数是复数，一般将委托类实现的所有接口传入）</li><li>InvocationHandler：调用处理器，本质是接口回调<br>2.重写 public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {</li><li>proxy：代理类对象本身（几乎没作用）</li><li>method：当前代理类对象执行的方法（拦截）</li><li>args：当前方法所需要的参数</li><li>返回值：当前方法的返回值</li></ol></li></ol><p>final CustomerDao customerDao= new CustomerDaoImpl();</p><pre><code>ClassLoader classLoader = customerDao.getClass().getClassLoader();Class&lt;?&gt;[] interfaces = customerDao.getClass().getInterfaces();InvocationHandler h =new InvocationHandler() {    @Override    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {        System.out.print(method.getName()+&quot;  &quot;);       if(args==null){           System.out.println(&quot;没有参数不增强&quot;);       }else {           Object invoke = method.invoke(customerDao, args);           System.out.println(&quot;方法增强&quot;);       }       return null;    }};CustomerDao case =(CustomerDao) Proxy.newProxyInstance(classLoader, interfaces,h);case.update();</code></pre></li></ol><p>2).Cglib动态代理<br>​ 本质是生成这个目标类的子类实现功能<br>final CustomerDao customerDao=new CustomerDaoImpl();</p><pre><code>ClassLoader classLoader = customerDao.getClass().getClassLoader();Class&lt;?&gt;[] interfaces = customerDao.getClass().getInterfaces();InvocationHandler h =new InvocationHandler() {    @Override    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {        Annotation[] annos = method.getAnnotations();        for (Annotation anno : annos) {            if (anno.equals(&quot;Deprecated&quot;)){                System.out.println(&quot;注解标注增强功能&quot;);                method.invoke(customerDao, args);            }        }        return null;    }};CustomerDao case =(CustomerDao) Proxy.newProxyInstance(classLoader, interfaces,h);case.change(&quot;ff&quot;);</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring处理响应的过程</title>
      <link href="/3343205230.html"/>
      <url>/3343205230.html</url>
      
        <content type="html"><![CDATA[<p>springMVC<br>的运行原理梳理是将 将浏览器发送过来信息处理已Model Vever Conctroller 将不同功能区分</p><pre><code>dispacherServlethandlermapperninghandlerAdapater  --&gt;handler(Controller)Viewer</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu优化-修改软件权限挂着磁盘</title>
      <link href="/1312199450.html"/>
      <url>/1312199450.html</url>
      
        <content type="html"><![CDATA[<p>sublime_text</p><p>sudo chmod +x subl shell脚步 /usr/bin/subl</p><pre><code>Exec=bash -c &quot;LD_PRELOAD=/opt/sublime_text/libsublime-imfix.so exec /opt/sublime_text/sublime_text -n&quot;</code></pre><p>完善</p><pre><code># /dev/nvme0n1p1:beiUUID=&quot;31777183-00e9-459a-898f-4405b03e2c1e&quot; PARTUUID=&quot;a174f198-ae87-4ca7-b340-f4a6e8fda28f&quot; UUID=31777183-00e9-459a-898f-4405b03e2c1e /home/leek/device   ext4    defaults         0      1</code></pre><p>sudo mount -a /etc/fstab</p><pre><code>&lt;fs spec&gt; &lt;fs file&gt; &lt;fs vfstype&gt; &lt;fs mntops&gt; &lt;fs freq&gt; &lt;fs passno&gt;具体说明，以挂载/dev/sdb1为例：&lt;fs spec&gt;：分区定位，可以给UUID或LABEL，例如：UUID=6E9ADAC29ADA85CD或LABEL=software&lt;fs file&gt;：具体挂载点的位置，例如：/data&lt;fs vfstype&gt;：挂载磁盘类型，linux分区一般为ext4，windows分区一般为ntfs&lt;fs mntops&gt;：挂载参数，一般为defaults&lt;fs freq&gt;：磁盘检查，默认为0&lt;fs passno&gt;：磁盘检查，默认为0，不需要检查作者：a11en0链接：https://www.jianshu.com/p/336758411dbf来源：简书简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用fileupload</title>
      <link href="/7e2892da.html"/>
      <url>/7e2892da.html</url>
      
        <content type="html"><![CDATA[<p>使用commons-fileupload插件来帮我们处理上传后的数据而让我们自己手动处理的话,也是可以的,但是十分麻烦,因为我们需要将所有的请求体获取到,</p><hr><p>首先maven下载fileupload和commons-io可以这两个类可以对浏览器的发送请求头保存,并能实现结束</p><pre><code>&lt;!--upload 文件--&gt;    &lt;dependency&gt;      &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;      &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;      &lt;version&gt;1.3.1&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;commons-io&lt;/groupId&gt;      &lt;artifactId&gt;commons-io&lt;/artifactId&gt;      &lt;version&gt;2.5&lt;/version&gt;    &lt;/dependency&gt;</code></pre><p>浏览器端的代码</p><p>#html #</p><pre><code>&lt;br&gt;    &lt;!--&lt;form enctype=&quot;multipart/form-data&quot;&gt;--&gt;        &lt;div class=&quot;modal-header&quot;&gt;            &lt;button type=&quot;button&quot; class=&quot;close&quot; data-dismiss=&quot;modal&quot; aria-label=&quot;Close&quot;&gt;&lt;span aria-hidden=&quot;true&quot;&gt;&amp;times;&lt;/span&gt;&lt;/button&gt;            &lt;h4 class=&quot;modal-title&quot; id=&quot;myModalLabel&quot;&gt;拖入文件上传&lt;/h4&gt;        &lt;/div&gt;        &lt;div class=&quot;form-group&quot;&gt;            &lt;input id=&quot;file-1&quot; type=&quot;file&quot; class=&quot;file&quot; data-overwrite-initial=&quot;false&quot;                   data-min-file-count=&quot;1&quot;&gt;        &lt;/div&gt;</code></pre><h1 id="js"><a href="#js" class="headerlink" title="js"></a>js</h1><pre><code>//文件上传   $(&quot;#file-1&quot;).fileinput({       language: &#39;zh&#39;, //设置语言       uploadUrl: &quot;adminAddRoute?methodName=updatePic&quot;, //上传的地址       showUpload: true, //是否显示上传按钮       showCaption: true,//是否显示标题       browseClass: &quot;btn btn-primary&quot;, //按钮样式 previewId, index       uploadExtraData: function () {           var data = {               parentId: $(&quot;#fileType&quot;).val()           };           return data;       },       &#39;theme&#39;: &#39;explorer&#39;,       maxFileCount: 1, //表示允许同时上传的最大文件个数       enctype: &#39;multipart/form-data&#39;,       validateInitialCount: true,       msgFilesTooMany: &quot;选择上传的文件数量({n}) 超过允许的最大数值{m}！&quot;,       allowedFileExtensions : [&#39;jpg&#39;, &#39;png&#39;,&#39;gif&#39;],       overwriteInitial: false,       maxFileSize: 1000,       maxFilesNum: 1,       //allowedFileTypes: [&#39;image&#39;, &#39;video&#39;, &#39;flash&#39;],       slugCallback: function(filename) {           return filename.replace(&#39;(&#39;, &#39;_&#39;).replace(&#39;]&#39;, &#39;_&#39;);       }   });</code></pre><p>将html文档放在需要实现的地方即可</p><h1 id="java后台实现"><a href="#java后台实现" class="headerlink" title="java后台实现"></a>java后台实现</h1><pre><code>String path_temp = this.getServletContext().getRealPath(&quot;temp&quot;);       //DiskFileItemFactory factory = new DiskFileItemFactory(1024*1024, new File(path_temp));       DiskFileItemFactory factory = new DiskFileItemFactory();       factory.setSizeThreshold(1024*1024);       factory.setRepository(new File(path_temp));       //2、创建文件上传的核心类       ServletFileUpload upload = new ServletFileUpload(factory);       //设置上传文件的名称的编码       upload.setHeaderEncoding(&quot;UTF-8&quot;);       List&lt;FileItem&gt; fileItems = upload.parseRequest(request);       FileItem item = fileItems.get(0);       //文件上传项       //文件的名       String fileName1 = item.getName();       System.out.println(&quot;上传文件名称 = &quot; + fileName1);       String uuid = UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;);       String fileName = uuid + &quot;.jpg&quot;;       //获得上传文件的内容       InputStream in = item.getInputStream();       //设置图片保存名字和路径       String path_store = this.getServletContext().getRealPath(&quot;img/product&quot;);           //                            if(path_store)       String st = path_store + &quot;/&quot; + fileName;       OutputStream outSize2 = new FileOutputStream(st);       //        OutputStream outSize4 = new FileOutputStream(path_store+&quot;/size4/&quot;+fileName);       //        OutputStream outSize3 = new FileOutputStream(path_store+&quot;/size3/&quot;+fileName);       //保存文件       IOUtils.copy(in, outSize2);       in.close();       outSize2.close();</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用hexo搭建个人静态博客</title>
      <link href="/1573622544.html"/>
      <url>/1573622544.html</url>
      
        <content type="html"><![CDATA[<p>参考的博客地址包括<a href="https://wsgzao.github.io/post/hexo-guide/" target="_blank" rel="noopener">使用github搭建个人博客</a></p><ul><li><a href="http://suericze.github.io/2016/03/21/史上最新版GitHub+Hexo配置系列教程-Hexo配置-一/" target="_blank" rel="noopener">史上最新版GitHub+Hexo配置系列教程-Hexo配置1</a><br>-<a href="http://suericze.github.io/2016/03/21/史上最新版GitHub+Hexo配置系列教程-GitHub配置-二/" target="_blank" rel="noopener">史上最新版GitHub+Hexo配置系列教程-Hexo配置2</a><br>-<a href="http://suericze.github.io/2016/03/21/史上最新版GitHub-Hexo配置系列教程-Hexo-GitHub关联-三/" target="_blank" rel="noopener">史上最新版GitHub+Hexo配置系列教程-Hexo配置3</a><br>类似于jekyll、Octopress、Wordpress，我们可以用hexo创建自己的博客，托管到github或Heroku上，绑定自己的域名，用markdown写文章。本博客即使用hexo创建并托管在github上。<br>先上效果图<br><a href="http://wx2.sinaimg.cn/mw690/0060lm7Tly1fvrymfi3vxj31gv0uc76h.jpg" target="_blank" rel="noopener"><img src="http://wx2.sinaimg.cn/mw690/0060lm7Tly1fvrymfi3vxj31gv0uc76h.jpg" alt="效果图"></a></li></ul><ol><li><p>首先是按照文章开头提供的链接安装node.js 通过NPM安装需要的各种js文件还有hexo 在你新建的文件夹hexo init初始化一下就会有文件夹和配置文件</p><p><img src="http://wx3.sinaimg.cn/mw690/0060lm7Tly1fvryrmfpddj30hs0b3wfs.jpg" alt="img"></p><p>然后下载hexo需要的js文件通过NPM</p><p><img src="http://wx3.sinaimg.cn/mw690/0060lm7Tly1fvrysrk2lsj30dh0k9adb.jpg" alt="img"></p><p>hexo generate生成静态网站</p><p>然后运行hexo server启动hexo服务,如果报错就修改一下配置文件是 _config.yml,这个配置文件可以修改很多东西,但是要和你安装的主题匹配不然就可能不兼容无法启动</p><p><img src="http://wx1.sinaimg.cn/mw690/0060lm7Tly1fvryua2f9kj30sy0fk0tr.jpg" alt="img"></p><p>有个source/_posts是放你写的博客你可以将写好的md文件放在这里</p><p><img src="http://wx1.sinaimg.cn/mw690/0060lm7Tly1fvryzjd6tyj30ii0hp0tm.jpg" alt="img"></p><p>在网上也可以比较方便的找到hexo支持的主题</p><p><img src="http://wx2.sinaimg.cn/mw690/0060lm7Tly1fvrz0hehuej30ii0hp0tm.jpg" alt="img"></p><p>我初始的主题是这样的</p></li></ol><p>   将_config.yml上面的</p><pre><code>   # Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: anatole</code></pre><p>修改为themes中对于的文件夹,我用的主题链接为<a href="https://github.com/Ben02/hexo-theme-Anatole/tree/master/source" target="_blank" rel="noopener">hexo-theme-Anatole</a><br><a href="https://github.com/bigleek/hexo" target="_blank" rel="noopener">本人hexo的文件在这里</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用vue-cli脚手架</title>
      <link href="/46994988.html"/>
      <url>/46994988.html</url>
      
        <content type="html"><![CDATA[<h1 id="使用vue-cli脚手架"><a href="#使用vue-cli脚手架" class="headerlink" title="使用vue-cli脚手架"></a>使用vue-cli脚手架</h1><p>创建vue初始化项目<br>感觉vue init webpack-simple这样的方式适合小项目，vue init webpack这样的方式适合中大型项目，两种方式初始化Vue-Cli的项目的目录差别比较大，你可以发现使用vue init webpack这样的方式来初始化项目，默认提供了很多的webpack的配置，也更加的方便你对代理(跨域)、最终打包资源放到服务器什么目录、以及js、css、img和项目在打包过程等优化的配置等等</p><p>当 Vue Loader 编译单文件组件中的 块时，它也会将所有遇到的资源 URL 转换为 webpack 模块请求。<br>webpack 和 Vue Loader 的结合为你提供了一个现代、灵活且极其强大的前端工作流，来帮助撰写 Vue.js 应用。<a href="https://vue-loader.vuejs.org/zh/" target="_blank" rel="noopener">vue-loader</a></p><h1 id="转换规则"><a href="#转换规则" class="headerlink" title="转换规则"></a>转换规则</h1><p>资源 URL 转换会遵循如下规则：</p><ol><li>有序列表如果路径是绝对路径 (例如 /images/foo.png)，会原样保留。</li><li>有序列表如果路径以 . 开头，将会被看作相对的模块依赖，并按照你的本地文件系统上的目录结构进行解析。</li><li>有序列表如果路径以 ~ 开头，其后的部分将会被看作模块依赖。这意味着你可以用该特性来引用一个 Node 依赖中的资源：</li><li>有序列表如果路径以 @ 开头，也会被看作模块依赖。如果你的 webpack 配置中给 @ 配置了 alias，这就很有用了。所有 vue-cli 创建的项目都默认配置了将 @ 指向 /src。<br>在导入模块和文件的简写要注意还包括./这种是有特殊含义的</li></ol><h2 id="浅谈Vue-use"><a href="#浅谈Vue-use" class="headerlink" title="浅谈Vue.use"></a>浅谈Vue.use</h2><p>写一个组件命名part.vue</p><pre><code>&lt;template&gt;    &lt;div class=&quot;loading-box&quot;&gt;       我是组件    &lt;/div&gt;&lt;/template&gt;</code></pre><p>在js中引入上面这个组件</p><pre><code>// 引入组件import LoadingComponent from &#39;./part.vue&#39;// 定义 Loading 对象const Loading={    // install 是默认的方法。当外界在 use 这个组件的时候，就会调用本身的 install 方法，同时传一个 Vue 这个类的参数。    install:function(Vue){        Vue.component(&#39;Loading&#39;,LoadingComponent)    }}// 导出export default Loading</code></pre><p>注意如果 在其他地方用上面的index.js就必须要申明Vue.use(Loading)<br>当外界在 use 这个组件的时候，就会调用本身的 install 方法，同时传一个 Vue 这个类的参数。<a href="https://www.jianshu.com/p/89a05706917a" target="_blank" rel="noopener">参考地址</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> vue-cli </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网上收集的关于spring特点的总结和spring介绍</title>
      <link href="/fd8471fb.html"/>
      <url>/fd8471fb.html</url>
      
        <content type="html"><![CDATA[<p><a href="http://blog.csdn.net/u013256816/article/details/51386182" target="_blank" rel="noopener">朱小厮CNDS</a></p><ol><li>Spring框架的作用<br> 轻量：Spring是轻量级的，基本的版本大小为2MB<br> 控制反转：Spring通过控制反转实现了松散耦合，对象们给出它们的依赖，而不是创建或查找依赖的对象们。<br> 面向切面的编程AOP:Spring支持面向切面的编程，并且把应用业务逻辑和系统服务分开。<br> 容器：Spring包含并管理应用中对象的生命周期和配置<br> MVC框架： Spring-MVC<br> 事务管理：Spring提供一个持续的事务管理接口，可以扩展到上至本地事务下至全局事务JTA<br> 异常处理：Spring提供方便的API把具体技术相关的异常</li><li>Spring的组成</li></ol><p>这里写图片描述</p><p>Spring由7个模块组成：<br> Spring Core: 核心容器提供 Spring 框架的基本功能。核心容器的主要组件是BeanFactory，它是工厂模式的实现。BeanFactory 使用控制反转 （IOC） 模式将应用程序的配置和依赖性规范与实际的应用程序代码分开。<br> Spring 上下文：Spring 上下文是一个配置文件，向 Spring 框架提供上下文信息。Spring 上下文包括企业服务，例如 JNDI、EJB、电子邮件、国际化、校验和调度功能。<br> Spring AOP：通过配置管理特性，Spring AOP 模块直接将面向方面的编程功能集成到了 Spring 框架中。所以，可以很容易地使 Spring 框架管理的任何对象支持 AOP。Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。通过使用 Spring AOP，不用依赖 EJB 组件，就可以将声明性事务管理集成到应用程序中。<br> Spring DAO：JDBC DAO 抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理和不同数据库供应商抛出的错误消息。异常层次结构简化了错误处理，并且极大地降低了需要编写的异常代码数量（例如打开和关闭连接）。Spring DAO 的面向 JDBC 的异常遵从通用的 DAO 异常层次结构。<br> Spring ORM：Spring 框架插入了若干个 ORM 框架，从而提供了 ORM 的对象关系工具，其中包括 JDO、Hibernate 和 iBatis SQL Map。所有这些都遵从 Spring 的通用事务和 DAO 异常层次结构。<br> Spring Web 模块：Web 上下文模块建立在应用程序上下文模块之上，为基于 Web 的应用程序提供了上下文。所以，Spring 框架支持与 Jakarta Struts 的集成。Web 模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。<br> Spring MVC 框架：MVC 框架是一个全功能的构建 Web 应用程序的 MVC 实现。通过策略接口，MVC 框架变成为高度可配置的，MVC 容纳了大量视图技术，其中包括 JSP、Velocity、Tiles、iText 和 POI。</p><ol><li>Spring容器</li></ol><p>Sping的容器可以分为两种类型</p><ol><li>BeanFactory：（org.springframework.beans.factory.BeanFactory接口定义）是最简答的容器，提供了基本的DI支持。最常用的BeanFactory实现就是XmlBeanFactory类，它根据XML文件中的定义加载beans，该容器从XML文件读取配置元数据并用它去创建一个完全配置的系统或应用。</li><li>ApplicationContext应用上下文：（org.springframework.context.ApplicationContext）基于BeanFactory之上构建，并提供面向应用的服务。</li><li>ApplicationContext通常的实现<br> ClassPathXmlApplicationContext：从类路径下的XML配置文件中加载上下文定义，把应用上下文定义文件当做类资源。<br> FileSystemXmlApplicationContext：读取文件系统下的XML配置文件并加载上下文定义。<br> XmlWebApplicationContext：读取Web应用下的XML配置文件并装载上下文定义。<br>ApplicationContext context = new ClassPathXmlApplicationContext(“applicationContext.xml”);</li><li>IOC &amp; DI</li></ol><p>Inversion of Control， 一般分为两种类型：依赖注入DI(Dependency Injection)和依赖查找（Dependency Lookup）.依赖注入应用比较广泛。</p><p>Spring IOC负责创建对象，管理对象（DI），装配对象，配置对象，并且管理这些对象的整个生命周期。</p><p>优点：把应用的代码量降到最低。容器测试，最小的代价和最小的侵入性使松散耦合得以实现。IOC容器支持加载服务时的饿汉式初始化和懒加载。</p><p>DI依赖注入是IOC的一个方面，是个通常的概念，它有多种解释。这概念是说你不用床架对象，而只需要描述它如何被创建。你不在代码里直接组装你的组件和服务，但是要在配置文件里描述组件需要哪些服务，之后一个IOC容器辅助把他们组装起来。</p><p>IOC的注入方式：1. 构造器依赖注入；2. Setter方法注入。</p><ol><li>如何给spring容器提供配置元数据<br> XML配置文件<br> 基于注解的配置<br> 基于Java的配置@Configuration, @Bean</li><li>bean标签中的属性：</li></ol><p>id</p><p>name</p><p>class</p><p>init-method：Bean实例化后会立刻调用的方法</p><p>destory-method:Bean从容器移除和销毁前，会调用的方法</p><p>factory-method:运行我们调用一个指定的静态方法，从而代替构造方法来创建一个类的实例。</p><p>scope：Bean的作用域，包括singleton(默认)，prototype(每次调用都创建一个实例), request,session, global-session（注意spring中的单例bean不是线程安全的）</p><p>autowired:自动装配 byName, byType, constructor, autodetect(首先阐释使用constructor自动装配，如果没有发现与构造器相匹配的Bean时，Spring将尝试使用byType自动装配)</p><ol><li>beans标签中相关属性</li></ol><p>default-init-method</p><p>default-destory-method</p><p>default-autowire：默认为none，应用于Spring配置文件中的所有Bean，注意这里不是指Spring应用上下文，因为你可以定义多个配置文件</p><ol><li>Bean的生命周期</li></ol><p>1) 创建Bean的实例(factory-method, autowireConstrutor)</p><p>2) 属性注入(autowireByName, autowireByType)</p><p>3) 初始化Bean</p><p>3.1 激活Aware方法：（invokeAwaresMethods）Spring中提供了一些Aware相关接口，比如BeanNameAware, BeanFactoryAware, ApplicationContextAware等，实现这些Aware接口的bean在被初始化之后，可以取得一些相对应的资源。</p><p>private void invokeAwareMethods(final String beanName, final Object bean){ if(bean instanceof Aware) { if(bean instanceof BeanNameAware){ ((BeanNameAware) bean).setBeanName(beanName); } if(bean instanceof BeanClassLoaderAware){ ((BeanClassLoaderAware) bean).setBeanClassLoader(getBeanClassLoader()); } if(bean instanceof BeanFactoryAware){ ((BeanFactoryAware) bean).setBeanFactory(AbstactAutowire CapableBeanFactory.this); } } }</p><p>3.2 处理器的应用(BeanPostProcessor接口)：调用客户自定义初始化方法前以及调用自定义初始化方法后分别会调用BeanPostProcessor的postProcessBeforeInitialization和postProcessAfterInitialization方法，使用户可以根据自己的业务需求进行响应的处理。</p><p>3.3 激活自定义的init方法（init-method &amp; 自定义实现InitializingBean接口）</p><p>protected Object initializeBean(final String beanName, final Object bean, RootBeanDefinetion mbd){ if(System.getSecurityManager() != null){ AccessController.doPrivileged(new PrivilegedAction(){ @Override public Object run() { invokeAwareMethods(beanName,bean); return null; } }); } else{ //对特殊的bean处理：Aware, BeanClassLoaderAware, BeanFactoryAware invokeAwareMethods(beanName,bean); } Object wrappedBean = bean; if(mbd == null !! !mbd.isSynthetic()){ wrappedBean = applyBeanPostProcessorsBeforeInitialization(wappedBean,beanName); } try{ invokeInitMethods(beanName, wappedBean, mbd); } catch(Throwable ex){ throw new BeanCreationException((mbd != null ? mbd.getResourceDescription():null),beanName,”Invocation of init method failed”,ex); } if(mbd == null || ！mbd.isSynthetic()){ wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName); } return wappedBean; }</p><p>4) 使用Bean。 驻留在应用的上下文中，直到该应用上下文被销毁。</p><p>5) 销毁(destory-mthod &amp; 实现DisposableBean接口)</p><p>Or represent like this:</p><ol><li>Bean的构造</li><li>调用setXXX()方法设置Bean的属性</li><li>调用BeanNameAware的setBeanName()</li><li>调用BeanFactoryAware的setBeanFactory()方法</li><li>调用BeanPostProcessor的postProcessBeforeInitialization()方法</li><li>调用InitializingBean的afterPropertiesSet()方法</li><li>调用自定义的初始化方法</li><li>调用BeanPostProcessor类的postProcessAfterInitialization()方法</li><li>调用DisposableBean的destroy()方法</li><li>调用自定义的销毁方法</li><li>Spring中注入集合</li><li>允许值相同</li><li>不允许值相同</li><li>键和值都可以为任意类型，key, key-ref, value-ref, value可以任意搭配</li><li>XXX键和值都只能是String类型</li><li>装配空值</li></ol><ol><li>自动装配(autowiring)</li></ol><p>有助于减少甚至消除配置和元素，让Spring自动识别如何装配Bean的依赖关系。<a href="context:annotation-config/">context:annotation-config/</a></p><p>与之对应的是：自动检测(autodiscovery)，比自动装配更近了一步，让Spring能够自动识别哪些类需要被配置成SpringBean，从而减少对元素的使用。<a href="context:component-scan">context:component-scan</a></p><ol><li>注解</li></ol><p>Spring容器默认禁用注解装配。最简单的开启方式<a href="context:annotation-config/">context:annotation-config/</a>。</p><p>Spring支持的几种不同的用于自动装配的注解：<br> Spring自带的@Autowired注解<br> JSR-330的@Inject注解<br> JSR-250的@Resource注解</p><ol><li>@Autowired</li></ol><p>@Autowired具有强契约特征，其所标注的属性或参数必须是可装配的。如果没有Bean可以装配到@Autowired所标注的属性或参数中，自动装配就会失败，抛出NoSuchBeanDefinitionException.</p><p>属性不一定非要装配，null值也是可以接受的。在这种场景下可以通过设置@Autowired的required属性为false来配置自动装配是可选的，如：</p><p>@Autowired(required=false) private Object obj;</p><p>注意required属性可以用于@Autowired注解所使用的任意地方。但是当使用构造器装配时，只有一个构造器可以将@Autowired的required属性设置为true。其他使用@Autowired注解所标注的构造器只能将required属性设置为false。此外，当使用@Autowired标注多个构造器时，Spring就会从所有满足装配条件的构造器中选择入参最多的那个构造器。</p><p>可以使用@Qualifier明确指定要装配的Bean.如下：</p><p>@Autowired @Qualifier(“objName”) private Object obj;</p><ol><li>自定义的限定器</li></ol><p>@Target({ElementType.FIELF, ElementType.PARAMETER, ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @Qualifier public @Interface SpecialQualifier{}</p><p>此时，可以通过自定义的@SpecialQualifier注解来代替@Qualifier来标注，也可以和@Autowired一起使用：</p><p>@Autowired @SpecialQualifier private Object obj;</p><p>此时,Spring会把自动装配的范围缩小到被@SpecialQualifier标注的Bean中。如果被@SpecialQualifier标注的Bean有多个，我们还可以通过自定义的另一个限定器@SpecialQualifier2来进一步缩小范围。</p><ol><li>@Autowired优缺点</li></ol><p>Spring的@Autowired注解是减少Spring XML配置的一种方式。但是它的类会映入对Spring的特定依赖（即使依赖只是一个注解）。</p><ol><li>@Inject</li></ol><p>和@Autowired注解一样，@Inject可以用来自动装配属性、方法和构造器；与@Autowired不同的是，@Inject没有required属性。因此@Inject注解所标注的依赖关系必须存在，如果不存在，则会抛出异常。</p><ol><li>@Named</li></ol><p>相对于@Autowired对应的Qualifier，@Inject所对应的是@Named注解。</p><p>@Inject @Named(“objName”) private Object obj;</p><ol><li>SpEL表达式</li></ol><p>语法形式在#{}中使用表达式,如：</p><ol><li>@Value</li></ol><p>@Value是一个新的装配注解，可以让我们使用注解装配String类型的值和基本类型的值，如int, boolean。我们可以通过@Value直接标注某个属性，方法或者方法参数，并传入一个String类型的表达式来装配属性，如：</p><p>@Value(“Eruption”) private String song;</p><p>@Value可以配合SpEL表达式一起使用，譬如有些情况下需要读取properties文件中的内容，可以使用：</p><p>@Value(“#{configProperties[‘ora_driver’]}”)</p><p>详细可以参考Spring+Mybatis多数据源配置（三）——Spring如何获取Properties文件的信息</p><ol><li>自动检测Bean</li></ol><p><a href="context:component-scan">context:component-scan</a>元素除了完成与<a href="context:annotation-config">context:annotation-config</a>一样的工作，还允许Spring自动检测Bean和定义Bean.<a href="context:component-scan">context:component-scan</a>元素会扫描指定的包和其所有子包，如下：</p><p>&lt;context:component-scan base-package=”com.zzh.dao” /&gt;</p><ol><li>为自动检测标注Bean</li></ol><p>默认情况下，查找使用构造型（stereotype）注解所标注的类，这些特殊的注解如下：</p><ul><li>@Component：通用的构造型注解，标志此类为Spring组件</li><li>@Controller：标识将该类定义为SpringMVC controller</li><li>@Repository：标识将该类定义为数据仓库</li><li>@Service：标识将该类定义为服务</li></ul><p>以@Component为例：</p><p>@Component public class Guitar implements Intrument{}</p><p>这里@Component会自动注册Guitar 为Spring Bean，并设置默认的Bean的Id为guitar，首字母大写变小写。注意如果第一个和第二个字母都是大写，默认的Bean的id会有特殊处理。</p><p>也可以指定Bean的Id如：</p><p>@Component(“guitarOne”) public class Guitar implements Intrument{}</p><ol><li>AOP</li></ol><p>面向切面的编程AOP，是一种编程技术，允许程序模块化横向切割关注点，或横切典型的责任划分，如日志和事务管理。</p><p>AOP的核心是切面，它将多个类的通用行为封装成可重用的模块，该模块含有一组API提供横切功能。比如，一个日志模块可以被称作日志的AOP切面。根据需求的不同，一个应用程序可以有若干切面。在SpringAOP中，切面通过带有@Aspect注解的类实现。</p><p>关注点是应用中的一个模块的行为，一个关注点可能会被定义成一个我们想实现的一个功能。</p><p>横切关注点一个关注点，此关注点是整个应用都会使用的功能，并影响整个应用，比如日志，安全和数据传输，几乎应用的每个模块都需要的功能。因此这些都属于横切关注点。</p><p>连接点代表一个应用程序的某个位置，在这个位置我们可以插入一个AOP切面，它实际上是个应用程序执行Spring AOP的位置。</p><p>切点是一个或一组连接点，通知将在这些位置执行。可以通过表达式或匹配的方式指明切入点。</p><p>引入运行我们在已存在的类中添加新的方法和属性。</p><ol><li>AOP通知</li></ol><p>通知是个在方法执行前后要做的动作，实际上是程序执行时要通过SpringAOP框架触发的代码</p><p>Spring切面可以应用五种类型的通知：</p><p>before：前置通知，在一个方法执行前被调用。@Before</p><p>after: 在方法执行之后调用的通知，无论方法执行是否成功。@After</p><p>after-returning: 仅当方法成功完成后执行的通知。@AfterReturning</p><p>after-throwing: 在方法抛出异常退出时执行的通知。@AfterThrowing</p><p>around: 在方法执行之前和之后调用的通知。@Around</p><ol><li>Spring的事务类型</li></ol><p>编程式事务管理：这意味你通过编程的方式管理事务，给你带来极大的灵活性，但是难维护。</p><p>声明式事务管理：这意味着你可以将业务代码和事务管理分离，你只需用注解和XML配置来管理事务。</p><ol><li>ACID</li><li>Atomic原子性：事务是由一个或多个活动所组成的一个工作单元。原子性确保事务中的所有操作全部发生或者全部不发生。</li><li>Consistent一致性：一旦事务完成，系统必须确保它所建模的业务处于一致的状态</li><li>Isolated隔离线：事务允许多个用户对象头的数据进行操作，每个用户的操作不会与其他用户纠缠在一起。</li><li>Durable持久性：一旦事务完成，事务的结果应该持久化，这样就能从任何的系统崩溃中恢复过来。</li><li>JDBC事务</li></ol><p>如果在应用程序中直接使用JDBC来进行持久化，譬如博主采用的是Mybatis，DataSourceTransactionManager会为你处理事务边界。譬如：</p><pre><code>&lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;         destroy-method=&quot;close&quot;&gt;         &lt;property name=&quot;driverClassName&quot; value=&quot;${driver}&quot; /&gt;         &lt;property name=&quot;url&quot; value=&quot;${url}&quot; /&gt;         &lt;property name=&quot;username&quot; value=&quot;zzh&quot; /&gt;         &lt;property name=&quot;password&quot; value=&quot;zzh&quot; /&gt;         &lt;property name=&quot;validationQuery&quot; value=&quot;SELECT 1&quot;/&gt;     &lt;/bean&gt;     &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;         &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;     &lt;/bean&gt;</code></pre><ol><li>JTA事务</li></ol><p>如果你的事务需要跨多个事务资源（例如：两个或多个数据库；或者如Sping+ActiveMQ整合需要将ActiveMQ和数据库的事务整合起来），就需要使用JtaTransactionManager:</p><p>&lt;bean id=”jtaTransactionManager”class=”org.springframework.transaction.jta.JtaTransactionManager”/&gt;<br>JtaTransactionManager将事务管理的职责委托给了一个JTA的实现。JTA规定了应用程序与一个或多个数据源之间协调事务的标准API。transactionManagerName属性指明了要在JNDI上查找的JTA事务管理器。</p><p>\29. 声明式事务</p><p>\1. 隔离级别(isolation) ISOLATION_DEFAULT: 使用底层数据库预设的隔离层级 ISOLATION_READ_COMMITTED: 允许事务读取其他并行的事务已经送出（Commit）的数据字段，可以防止Dirty read问题 ISOLATION_READ_UNCOMMITTED: 允许事务读取其他并行的事务还没送出的数据，会发生Dirty、Nonrepeatable、Phantom read等问题 ISOLATION_REPEATABLE_READ: 要求多次读取的数据必须相同，除非事务本身更新数据，可防止Dirty、Nonrepeatable read问题 ISOLATION_SERIALIZABLE: 完整的隔离层级，可防止Dirty、Nonrepeatable、Phantom read等问题，会锁定对应的数据表格，因而有效率问题2. 传播行为(propagation) PROPAGATION_REQUIRED–支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择。 PROPAGATION_SUPPORTS–支持当前事务，如果当前没有事务，就以非事务方式执行。 PROPAGATION_MANDATORY–支持当前事务，如果当前没有事务，就抛出异常。 PROPAGATION_REQUIRES_NEW–新建事务，如果当前存在事务，把当前事务挂起。 PROPAGATION_NOT_SUPPORTED–以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。 PROPAGATION_NEVER–以非事务方式执行，如果当前存在事务，则抛出异常。 PROPAGATION_NESTED–如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则进行与PROPAGATION_REQUIRED类似的操作。3. 只读(read-only)</p><p>\4. 事务超时(timeout)</p><p>\5. 回滚规则(rollback-for, no-rollback-for)：rollback-for指事务对于那些检查型异常应当回滚而不提交；no-rollback-for指事务对于那些异常应当继续运行而不回滚。默认情况下，Spring声明事务对所有的运行时异常都进行回滚。</p><p>\6. SpringMVC</p><p>核心架构的具体流程：9. 首先用户发送请求——&gt;DispatcherServlet，前端控制器收到请求后自己不进行处理，而是委托给其他的解析器进行处理，作为统一访问点，进行全局的流程控制；10. DispatcherServlet——&gt;HandlerMapping， HandlerMapping将会把请求映射为HandlerExecutionChain对象（包含一个Handler处理器（页面控制器）对象、多个HandlerInterceptor拦截器）对象，通过这种策略模式，很容易添加新的映射策略；11. DispatcherServlet——&gt;HandlerAdapter，HandlerAdapter将会把处理器包装为适配器，从而支持多种类型的处理器，即适配器设计模式的应用，从而很容易支持很多类型的处理器；12. HandlerAdapter——&gt;处理器功能处理方法的调用，HandlerAdapter将会根据适配的结果调用真正的处理器的功能处理方法，完成功能处理；并返回一个ModelAndView对象（包含模型数据、逻辑视图名）；13. ModelAndView的逻辑视图名——&gt; ViewResolver， ViewResolver将把逻辑视图名解析为具体的View，通过这种策略模式，很容易更换其他视图技术；14. View——&gt;渲染，View会根据传进来的Model模型数据进行渲染，此处的Model实际是一个Map数据结构，因此很容易支持其他视图技术；15. 返回控制权给DispatcherServlet，由DispatcherServlet返回响应给用户，到此一个流程结束。16. DispatcherServlet</p><p>viewspace org.springframework.web.servlet.DispatcherServlet 2</p><p>接下来，必须申明DispatcherServlet处理那些URL：</p><p>通过将DispatcherServlet映射到/，声明了它会作为默认的servlet并且会处理所有的请求，包括对静态资源的请求。</p><p>&lt;mvc:resources mapping=”/images/“ location=”/js/“ cache-period=”31556926” /&gt; &lt;mvc:resources mapping=”/css/**” location=”/css/“ cache-period=”31556926” /&gt;</p><p>\32. 配置HandlerMapping</p><p>&lt;mvc:annotation-driven /&gt;</p><p>在构建控制器的时候，我们还需要使用注解将请求参数绑定到控制器的方法参数上进行校验以及信息转换。提供注解驱动的特性。</p><ol><li>配置HandlerAdapter</li></ol><ol start="2"><li>配置视图</li></ol><p>在SpringMVC中大量使用了约定优于配置的开发模式。InternalResourceViewResolver就是一个面向约定的元素。它将逻辑视图名称解析为View对象，而该对象将渲染的任务委托给Web应用程序上下文中的一个模板。</p><pre><code>&lt;!-- 配置视图解析器，将ModelAndView及字符串解析为具体的页面 --&gt;     &lt;bean         class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;         &lt;property name=&quot;viewClass&quot;             value=&quot;org.springframework.web.servlet.view.JstlView&quot; /&gt;         &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt;         &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;     &lt;/bean&gt;</code></pre><p>当DispatcherServlet要求InternalResourceViewResolver解析视图的时候，它将获取一个逻辑视图名称，添加”/WEB-INF/jsp/”前缀和”.jsp”后缀。等待的结果就是渲染输出的JSP路径。在内部，InternalResourceViewResolver接下来会将这个路径传递给View对象，View对象将请求传递给JSP.</p><p>持续更新<del>~</del></p><p>请保留转载连接~<br>参考文献</p><ol><li>《Sping In Action》 Craig Walls.</li><li>69道Spring面试题和答案</li><li>Sping+ActiveMQ整合<br>欢迎支持笔者新书：《RabbitMQ实战指南》以及关注微信公众号：Kafka技术专栏。</li></ol><p>这里写图片描述</p>]]></content>
      
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最近折腾Ubuntu16的过程记录</title>
      <link href="/3642578636.html"/>
      <url>/3642578636.html</url>
      
        <content type="html"><![CDATA[<p>上周到了一台戴尔的xps13，考虑win10喜欢频繁升级和对高分辨的显示不算好的支持，所以觉得折腾一下Ubuntu，其实很久之前就折腾过也尝试过将它设为主力系统，其实当时陆陆续续已经出现时网易云音乐和WPS已经类似于IDM的uget 当时还是不算好用，同时当时没怎么涉及到开发，现在算是比较合适与我开发。<br>先说一下安装的情况，刚开始由于没有课BIOS硬盘的acid的设置导致，启动盘不能识别硬盘不能继续安装，后面是一安装重启就出现,在grub引导后都没有出现登录见面，当时就很慌 ，以为是安装过程中BIOS到处出现安装出的问题吧BIOS全部折腾几遍，又安装又TMD的是黑屏–晚上看了看都是登录时后面出现黑屏，是NVIDIA和Intel的集成显卡的问题，我照着网上先是尝试在grub前面编辑一下</p><pre><code>启动黑屏在启动Ubuntu的时候出现黑屏的情况，是因为升级了内核导致显卡不兼容，启动的时候应该告诉内核不要加载显卡：在引导界面，按e进入grub编辑界面，在quiet splash后面添加nomodeset按F10接着引导启动进入登录界面，输入用户名和密码发现闪一下又跳回登录界面 先不用着急解决登录界面循环的问题，前面的grub配置文件的修改只是暂时的，现在需要永久性的修改 Ctrl+Alt+（F1-F6）进入命令行tty界面，登录之后，sudo vi /etc/default/grub1找到quiet splash并在后面添加nomodeset。然后输入sudo update-grub1更新了grub配置文件后，重启即可。 对于在tty命令行界面中文乱码的问题可以参考博客：http://blog.csdn.net/VictoriaW/article/details/56484552--------------------- 作者：CodeTutor 来源：CSDN 原文：https://blog.csdn.net/VictoriaW/article/details/56484119 版权声明：本文为博主原创文章，转载请附上博文链接！</code></pre><p>没想到不行当时就检查一遍又一遍看，又在安装一遍然后设置不安装显卡的驱动，避开还是不行搞到两点没看到头绪<br>第二天我先可能是我这边是我安装引导文件的问题，然后选择try ubuntu 进入系统安装引导修复文件Boot-Repair. 试了一遍也不行真的是心灰意冷了，最后将启动盘工具<br>universal usb installer这个工具换成软碟通，搞完后就成功了，就是这个工具的问题</p>]]></content>
      
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES相关的知识总结一</title>
      <link href="/3632233998.html"/>
      <url>/3632233998.html</url>
      
        <content type="html"><![CDATA[<p>1）type</p><p>Elasticsearch中支持的数据类型非常丰富：</p><ul><li>String类型，又分两种：<ul><li>text：可分词，不可参与聚合</li><li>keyword：不可分词，数据会作为完整字段进行匹配，可以参与聚合</li></ul></li><li>Numerical：数值类型，分两类<ul><li>基本数据类型：long、interger、short、byte、double、float、half_float</li><li>浮点数的高精度类型：scaled_float<ul><li>需要指定一个精度因子，比如10或100。elasticsearch会把真实值乘以这个因子后存储，取出时再还原。</li></ul></li></ul></li><li>Date：日期类型<br>elasticsearch可以对日期格式化为字符串存储，但是建议我们存储为毫秒值，存储为long，节省空间。</li></ul><p>2）index</p><p>index影响字段的索引情况。</p><ul><li>true：字段会被索引，则可以用来进行搜索。默认值就是true</li><li>false：字段不会被索引，不能用来搜索</li></ul><p>index的默认值就是true，也就是说你不进行任何配置，所有字段都会被索引。</p><p>但是有些字段是我们不希望被索引的，比如商品的图片信息，就需要手动设置index为false。</p><p>3）store</p><p>是否将数据进行额外存储。_source</p><p>在学习lucene和solr时，我们知道如果一个字段的store设置为false，那么在文档列表中就不会有这个字段的值，用户的搜索结果中不会显示出来。</p><p>但是在Elasticsearch中，即便store设置为false，也可以搜索到结果。</p><p>原因是Elasticsearch在创建文档索引时，会将文档中的原始数据备份，保存到一个叫做_source的属性中。最终我们查询数据是从_source中来取值，所以可以通过过滤_source来选择哪些要显示，哪些不显示。</p><p>而如果设置store为true，就会在_source以外额外存储一份数据，多余，因此一般我们都会将store设置为false，事实上，store的默认值就是false。</p><p>4）boost</p><p>激励因子，这个与lucene中一样</p><p>其它的不再一一讲解，用的不多，大家参考官方文档：</p><p>还有查询的更多东西(mathch all)<br>GET /heima/_search<br>{<br>​ “query”:{<br>​ “match_all”: {}<br>​ }<br>}<br>匹配查询(match)<br>GET /heima/_search<br>{<br>​ “query”:{<br>​ “match”:{<br>​ “title”:”小米电视”<br>​ }<br>​ }<br>}<br>多字段查询(multi_match)<br>GET /heima/_search<br>{<br>​ “query”:{<br>​ “multi_match”: {<br>​ “query”: “小米”,<br>​ “fields”: [ “title”, “subTitle” ]<br>​ }<br>​ }<br>}<br>词条匹配(term)<br>GET /heima/_search<br>{<br>​ “query”:{<br>​ “term”:{<br>​ “price”:2699.00<br>​ }<br>​ }<br>}<br>多词条精确匹配(terms)<br>GET /heima/_search<br>{<br>​ “query”:{<br>​ “terms”:{<br>​ “price”:[2699.00,2899.00,3899.00]<br>​ }<br>​ }<br>}</p><p>结果过滤</p><p>默认情况下，elasticsearch在搜索的结果中，会把文档中保存在_source的所有字段都返回。</p><p>如果我们只想获取其中的部分字段，我们可以添加_source的过滤<br>GET /heima/_search<br>{<br>“_source”: [“title”,”price”],====&gt;includi exclud<br>“query”: {<br>​ “term”: {<br>​ “price”: 2699<br>​ }<br>}<br>}</p>]]></content>
      
      
      
        <tags>
            
            <tag> elasticsearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES相关的知识总结二</title>
      <link href="/3632233997.html"/>
      <url>/3632233997.html</url>
      
        <content type="html"><![CDATA[<p>聚合aggregations</p><p>聚合可以让我们极其方便的实现对数据的统计、分析。例如：<br>Elasticsearch中的聚合，包含多种类型，最常用的两种，一个叫桶，一个叫度量：</p><p>桶（bucket）,阿里文档称之为存储单元</p><p>桶的作用，是按照某种方式对数据进行分组，每一组数据在ES中称为一个桶， 例如我们根据国籍对人划分，可以得到中国桶、英国桶，日本桶……或者我们按照年龄段对人进行划分：0<del>10,10</del>20,20<del>30,30</del>40等。</p><p>Elasticsearch中提供的划分桶的方式有很多：</p><ul><li>Date Histogram Aggregation：根据日期阶梯分组，例如给定阶梯为周，会自动每周分为一个存储单元</li><li>Histogram Aggregation：根据数值阶梯分组，与日期类似</li><li>Terms Aggregation：根据词条内容分组，词条内容完全匹配的为一个存储单元</li><li>Range Aggregation：数值和日期的范围分组，指定开始和结束，然后按段分</li><li>……</li></ul><p>综上所述，我们发现bucket aggregations 只负责对数据进行分组，并不进行计算，因此往往bucket中往往会嵌套另一种聚合：metrics aggregations即度量</p><p>度量（metrics）</p><p>分组完成以后，我们一般会对组中的数据进行聚合运算，例如求平均值、最大、最小、求和等，这些在ES中称为度量</p><p>比较常用的一些聚合度量方式：</p><ul><li>Avg Aggregation：求平均值</li><li>Max Aggregation：求最大值</li><li>Min Aggregation：求最小值</li><li>Percentiles Aggregation：求百分比</li><li>Stats Aggregation：同时返回avg、max、min、sum、count等</li><li>Sum Aggregation：求和</li><li>Top hits Aggregation：求前几</li><li>Value Count Aggregation：求总数</li></ul><p>聚合为桶<br>GET /cars/_search<br>{<br>​ “size” : 10,<br>​ “aggs” : {<br>​ “popular_colors” : {<br>​ “terms” : {<br>​ “field” : “color”<br>​ }<br>​ }<br>​ }<br>}</p><ul><li>hits：查询结果为空，因为我们设置了size为0</li><li>aggregations：聚合的结果</li><li>popular_colors：我们定义的聚合名称</li><li>buckets：查找到的桶，每个不同的color字段值都会形成一个桶<ul><li>key：这个桶对应的color字段的值</li><li>doc_count：这个桶中的文档数量</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> elasticsearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring定时任务</title>
      <link href="/1075226630.html"/>
      <url>/1075226630.html</url>
      
        <content type="html"><![CDATA[<pre><code>  &lt;bean id=&quot;schedulerJobDetail&quot; class=&quot;org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean&quot;&gt;         &lt;property name=&quot;targetObject&quot; ref=&quot;scheduleInfoAction&quot;/&gt;         &lt;property name=&quot;targetMethod&quot; value=&quot;simpleJobTest&quot;/&gt;         &lt;property name=&quot;concurrent&quot; value=&quot;false&quot;/&gt;     &lt;/bean&gt;     &lt;bean id=&quot;cronTrigger&quot; class=&quot;org.springframework.scheduling.quartz.CronTriggerBean&quot; &gt;          &lt;property name=&quot;jobDetail&quot; ref=&quot;schedulerJobDetail&quot;/&gt;          &lt;property name=&quot;cronExpression&quot;&gt;              &lt;value&gt;0/10 * * * * ?&lt;/value&gt;          &lt;/property&gt;      &lt;/bean&gt;     &lt;bean id=&quot;schedulerFactory&quot;     class=&quot;org.springframework.scheduling.quartz.SchedulerFactoryBean&quot;&gt;         &lt;property name=&quot;triggers&quot;&gt;             &lt;list&gt;                 &lt;ref local=&quot;cronTrigger&quot;/&gt;             &lt;/list&gt;         &lt;/property&gt;&lt;/bean&gt;</code></pre><p><a href="https://www.cnblogs.com/liuling/archive/2013/01/31/liulinga.html" target="_blank" rel="noopener">链接</a></p><pre><code>定时任务每隔5秒执行一次：*/5 * * * * ? 每隔1分钟执行一次：0 */1 * * * ? 每天23点执行一次：0 0 23 * * ? 每天凌晨1点执行一次：0 0 1 * * ? 每月1号凌晨1点执行一次：0 0 1 1 * ? 每月最后一天23点执行一次：0 0 23 L * ? 每周星期天凌晨1点实行一次：0 0 1 ? * L 在26分、29分、33分执行一次：0 26,29,33 * * * ? 每天的0点、13点、18点、21点都执行一次：0 0 0,13,18,21 * * ?</code></pre><p><a href="https://www.jianshu.com/p/2fafcc32561f" target="_blank" rel="noopener">参考链接</a></p><table><thead><tr><th align="center">特殊字符</th><th align="center"></th><th align="center">意义</th></tr></thead><tbody><tr><td align="center">*</td><td align="center"></td><td align="center">表示所有值；</td></tr><tr><td align="center">?</td><td align="center"></td><td align="center">表示未说明的值，即不关心它为何值；</td></tr><tr><td align="center">-</td><td align="center"></td><td align="center">表示一个指定的范围；</td></tr><tr><td align="center">,</td><td align="center"></td><td align="center">表示附加一个可能值；</td></tr><tr><td align="center">/</td><td align="center"></td><td align="center">符号前表示开始时间，符号后表示每次递增的值；</td></tr><tr><td align="center">L(“last”)</td><td align="center"></td><td align="center">(“last”) “L” 用在day-of-month字段意思是 “这个月最后一天”；用在 day-of-week字段, 它简单意思是 “7” or “SAT”。如果在day-of-week字段里和数字联合使用，它的意思就是 “这个月的最后一个星期几” – 例如： “6L” means “这个月的最后一个星期五”. 当我们用“L”时，不指明一个列表值或者范围是很重要的，不然的话，我们会得到一些意想不到的结果。</td></tr><tr><td align="center">W(“weekday”)</td><td align="center"></td><td align="center">只能用在day-of-month字段。用来描叙最接近指定天的工作日（周一到周五）。例如：在day-of-month字段用“15W”指“最接近这个月第15天的工作日”，即如果这个月第15天是周六，那么触发器将会在这个月第14天即周五触发；如果这个月第15天是周日，那么触发器将会在这个月第16 天即周一触发；如果这个月第15天是周二，那么就在触发器这天触发。注意一点：这个用法只会在当前月计算值，不会越过当前月。“W”字符仅能在day- of-month指明一天，不能是一个范围或列表。也可以用“LW”来指定这个月的最后一个工作日。</td></tr><tr><td align="center">#</td><td align="center"></td><td align="center">只能用在day-of-week字段。用来指定这个月的第几个周几。例：在day-of-week字段用”6#3”指这个月第3个周五（6指周五，3指第3个）。如果指定的日期不存在，触发器就不会触发。</td></tr><tr><td align="center">C</td><td align="center"></td><td align="center">指和calendar联系后计算过的值。例：在day-of-month 字段用“5C”指在这个月第5天或之后包括calendar的第一天；在day-of-week字段用“1C”指在这周日或之后包括calendar的第一天。</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于泛型和Java的伪泛型</title>
      <link href="/4d077bfe.html"/>
      <url>/4d077bfe.html</url>
      
        <content type="html"><![CDATA[<p>范型 就是在集合中为了将本来是object的数据进行限定但其实在编译以后还是object还有范型通配符<br>多态 为什么有多态和实现而多态却只能多重继承二实现却可以多实现并且<br>多线程还有正则表达式还有设计对象还有包括 预习数据库<br>异常 数组 多线程 （多线程安全包括同步锁）</p><h3 id="高内聚底耦合"><a href="#高内聚底耦合" class="headerlink" title="高内聚底耦合"></a>高内聚底耦合</h3><p>高内聚底耦合 单继承多实现高内聚第耦合 运行时的时间 但继承多实现<br>面试中问到的单例设计模式（单例模式，工厂模式，装饰着模式）<br>Seriablizable<br>Comparable<br>Charsequence final修改关于设计模式和</p><p>1)instanceof:实现了某接口的类的对象也是该接口的实例；某类的对象也是该类超类的实例。<br>　　 2)native()修饰的方法没有方法体，用一个分号”；”代替大括号。<br>　　3)main不是关键字。<br>　　4)System.exit(int value),也就是说，只要是int的，就能够使JVM退出System.exit(‘a’);同样的是合法的。<br>　　5)&amp;,|能用在int和boolean上，而^（异或）只能用在int上。<br>　　6）如果一个类和一个接口被定义在同一文件中，而且类被声明为public，则接口前什么都不能写，因为接口只能用public来修饰，而一个文件中又只能有一个public访问控制关键字。</p><p>　　 7）unreachable statement 下面的几种情况会出现unreachable statement</p><p>　　 （1）在reutrn语句后写语句。<br>　　 （2）在throw语句后写语句。<br>　　 （3）break、continue语句之后定义语句。<br>8）“\u10100”//合法，相当于‘\u1010’和字符串“0”</p><p>　　 9)移位运算符可以用于long int char short byte</p><p>　　 10)类的访问控制符可以是public或什么都不加.</p><p>　　 11)goto是保留字但不是关键字.then什么都不是.</p><p>　　 12)把超类的类型强制转换后赋给子类的对象时,编译无异常,但运行时会出现异常<br>Value值 field为属性</p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
